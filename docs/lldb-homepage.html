<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>LLDB: homepage</title>
        <link rel="stylesheet" type="text/css" href="css/font-awesome.min.css">
        <link rel="stylesheet" type="text/css" href="css/inote_md2.css">
        <link rel="stylesheet" type="text/css" href="css/inote_md_tb1.css">
        <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
        <link rel="stylesheet" type="text/css" href="css/style.css">
        <link rel="stylesheet" type="text/css" href="css/blog_all.css">
        
    </head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PCRLYHSNM7"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PCRLYHSNM7');
</script>
    
<body>
    <div id="in-main">
        <h1 style="text-align:center">LLDB: homepage</h1>
        <span class="published">
            <i class="fa fa-calendar"></i>
            <time>2022-11-21</time>
            <i><a href="../tags/GOAL.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>GOAL</a>&nbsp;<a href="../tags/LLDB.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>LLDB</a>&nbsp;<a href="../tags/LLDB-doc.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>LLDB-doc</a>&nbsp;<a href="../tags/LLVM-Debug.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>LLVM-Debug</a>&nbsp;<a href="../tags/Reference.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Reference</a>&nbsp;</i>
        </span>
        <br/><br/>
        <div id="in-ttb"><ol>
<a name="HEAD_todo">TODO:</a>
	<li><a name="TOC_MARK_1" href="#MARK_1" id="in-ttl">Projects &ndash; 2023&ndash;05&ndash;03 </a></li>
	<li><a name="TOC_MARK_2" href="#MARK_2" id="in-ttl">Symbols on macOS </a></li>
	<li><a name="TOC_MARK_3" href="#MARK_3" id="in-ttl">Python Reference </a></li>
	<li><a name="TOC_MARK_4" href="#MARK_4" id="in-ttl">Testing LLDB using QEMU  </a></li>
	<li><a name="TOC_MARK_5" href="#MARK_5" id="in-ttl">Videos </a></li>
	<li><a name="TOC_MARK_6" href="#MARK_6" id="in-ttl">Books </a></li>
	<li><a name="TOC_MARK_7" href="#MARK_7" id="in-ttl">Extensions </a></li>
	<li><a name="TOC_MARK_8" href="#MARK_8" id="in-ttl">Testing </a></li>
	<li><a name="TOC_MARK_9" href="#MARK_9" id="in-ttl">Fuzzing LLDB </a></li>
	<li><a name="TOC_MARK_10" href="#MARK_10" id="in-ttl">Scripting Bridge API </a></li>
	<li><a name="TOC_MARK_11" href="#MARK_11" id="in-ttl">Reference </a></li>
</ol>
</div>
        <div class="entry-content">
<ul>
	<li><a name="HEAD_HIDDEN_acd9e12d"><a href="http://lldb.llvm.org/" target="_blank">LLDB Homepage</a> &nbsp;<a href="../tags/Homepage.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Homepage</a>&nbsp;<a href="../tags/LLDB.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>LLDB</a></li>
	<br />
	<li>Compiler Integration Benefits</li>
	<br />
	<ul>
		<li>LLDB <strong><font color="red">converts debug information into Clang types</font></strong> so that it can leverage the Clang compiler infrastructure. This allows LLDB to support the latest C, C++, Objective&ndash;C and Objective&ndash;C++ language features and runtimes in expressions without having to reimplement any of this functionality. It also leverages the compiler to take care of all ABI details when making functions calls for expressions, when disassembling instructions and extracting instruction details, and much more.</li>
		<ul>
			<li><a name="HEAD_HIDDEN_526a071">&quot;converts debug information into Clang types&quot; &ndash; Better than dbg DCODE &nbsp;<a href="../tags/DCode.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>DCode</a>&nbsp;<a href="../tags/vs_DBG_LLDB.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>vs_DBG_LLDB</a></li>
			<br />
		</ul>
		<li>The major benefits include:</li>
		<ul>
			<li>Up to date language support for C, C++, Objective&ndash;C</li>
			<li>Multi&ndash;line expressions that can declare local variables and types</li>
			<li>Utilize the JIT for expressions when supported</li>
			<li>Evaluate expression Intermediate Representation (IR) when JIT can&rsquo;t be used</li>
			<br />
		</ul>
	</ul>
</ul>
	<H1><a name="HEAD_50c8e2f9" href="#TOC_HEAD_50c8e2f9">1. Project</a></H1>
	<H2><a name="HEAD_f287485d" href="#TOC_HEAD_f287485d">1.1. Features</a></H2>
<ul>
	<li>LLDB supports a broad variety of basic debugging features such as reading DWARF, supporting step, next, finish, backtraces, etc. Some more interested bits are:</li>
	<ul>
		<li>Plug&ndash;in architecture for portability and extensibility:</li>
		<ul>
			<li><a name="HEAD_HIDDEN_3ba03a25">Object file parsers for executable file formats. Support currently includes <strong>Mach&ndash;O</strong> (32 and 64&ndash;bit) &amp; <strong>ELF</strong> (32&ndash;bit). &nbsp;<a href="../tags/ELF.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>ELF</a></li>
			<li>Object container parsers to extract object files contained within a file. Support currently includes universal <strong>Mach&ndash;O</strong> files &amp; <strong>BSD</strong> Archives.</li>
			<li><a name="HEAD_HIDDEN_19d6059">Debug symbol file parsers to incrementally extract debug information from object files. Support currently includes <strong>DWARF</strong> &amp; <strong>Mach&ndash;O</strong> symbol tables. &nbsp;<a href="../tags/DWARF.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>DWARF</a>&nbsp;<a href="../tags/Mach-O.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Mach-O</a></li>
			<li>Symbol vendor plug&ndash;ins collect data from a variety of different sources for an executable object.</li>
			<li>Disassembly plug&ndash;ins for each architecture. Support currently includes an LLVM disassembler for i386, x86&ndash;64 , ARM/Thumb, and PPC64le</li>
			<li>Debugger plug&ndash;ins implement the host and target specific functions required to debug.</li>
		</ul>
		<li><a name="HEAD_HIDDEN_b4cc2cf6">SWIG&ndash;generated script bridging allows Python to access and control the public API of the debugger library. &nbsp;<a href="../tags/SWIG.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>SWIG</a></li>
		<li>A remote protocol server, debugserver, implements macOS debugging on i386 and x86&ndash;64.</li>
		<li>A command line debugger &ndash; the lldb executable itself.</li>
		<li>A framework API to the library.</li>
		<br />
	</ul>
</ul>
	<H2><a name="HEAD_9432bc12" href="#TOC_HEAD_9432bc12">1.2. Status</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_aebef104" href="#HEAD_aebef104">1.2.1. Features Matrix </a></li>
	<li><a name="TOC_HEAD_515f4416" href="#HEAD_515f4416">1.2.2. Projects &ndash; 2023&ndash;05&ndash;03 &nbsp;<font color="red">@TODO</font></a></li>
</menu>

</div>
	<H3><a name="HEAD_aebef104" href="#TOC_HEAD_aebef104">1.2.1. Features Matrix</a></H3><ul><a href="../tags/Debug-Feature.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Debug-Feature</a>&nbsp;</ul>
<table id="mdt_t">
	<tr id="mdt_hd">
		<td id="mdt_td_l">Feature</td>
		<td id="mdt_td_l">FreeBSD</td>
		<td id="mdt_td_l">Linux</td>
		<td id="mdt_td_l">macOS</td>
		<td id="mdt_td_l">NetBSD</td>
		<td id="mdt_td_l">Windows</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">Backtracing</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">Breakpoints</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">C++11:</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">Unknown</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">Commandline tool</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">Core file debugging</td>
		<td id="mdt_td_l">YES (ELF)</td>
		<td id="mdt_td_l">YES (ELF)</td>
		<td id="mdt_td_l">YES (MachO)</td>
		<td id="mdt_td_l">YES (ELF)</td>
		<td id="mdt_td_l">YES (Minidump)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">Remote debugging</td>
		<td id="mdt_td_l">YES (lldb&ndash;server)</td>
		<td id="mdt_td_l">YES (lldb&ndash;server)</td>
		<td id="mdt_td_l">YES (debugserver)</td>
		<td id="mdt_td_l">YES (lldb&ndash;server)</td>
		<td id="mdt_td_l">NO</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">Disassembly</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">Expression evaluation</td>
		<td id="mdt_td_l">YES (known issues)</td>
		<td id="mdt_td_l">YES (known issues)</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">YES (known issues)</td>
		<td id="mdt_td_l">YES (known issues)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">JIT debugging</td>
		<td id="mdt_td_l">Unknown</td>
		<td id="mdt_td_l">Symbolic debugging only</td>
		<td id="mdt_td_l">Untested</td>
		<td id="mdt_td_l">Work In Progress</td>
		<td id="mdt_td_l">NO</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">Objective&ndash;C 2.0:</td>
		<td id="mdt_td_l">Unknown</td>
		<td id="mdt_td_l">N/A</td>
		<td id="mdt_td_l">YES</td>
		<td id="mdt_td_l">Unknown</td>
		<td id="mdt_td_l">N/A</td>
	</tr>
</table>
<br>
	<H3><a name="HEAD_515f4416" href="#TOC_HEAD_515f4416">1.2.2. Projects &ndash; 2023&ndash;05&ndash;03</a> <a name="MARK_1" href="#TOC_MARK_1"><strong><font color="red">@TODO</font></strong></a></H3><ul></ul>
	<H1><a name="HEAD_5271ff6c" href="#TOC_HEAD_5271ff6c">2. Use &amp; Extension</a></H1>
	<H2><a name="HEAD_f5f8f7e" href="#TOC_HEAD_f5f8f7e">2.1. Tutorial</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_391d2e9e" href="#HEAD_391d2e9e">2.1.1. Command Structure</a></li>
	<li><a name="TOC_HEAD_d1b959ff" href="#HEAD_d1b959ff">2.1.2. Loading a Program into lldb</a></li>
	<li><a name="TOC_HEAD_bcb7ec92" href="#HEAD_bcb7ec92">2.1.3. Setting Breakpoints</a></li>
	<li><a name="TOC_HEAD_94d68a59" href="#HEAD_94d68a59">2.1.4. Breakpoint Names</a></li>
	<li><a name="TOC_HEAD_9bac3c62" href="#HEAD_9bac3c62">2.1.5. Setting Watchpoints</a></li>
	<li><a name="TOC_HEAD_2a45d21c" href="#HEAD_2a45d21c">2.1.6. Starting or Attaching to Your Program</a></li>
	<li><a name="TOC_HEAD_f17237e4" href="#HEAD_f17237e4">2.1.7. Controlling Your Program</a></li>
	<li><a name="TOC_HEAD_26b3101d" href="#HEAD_26b3101d">2.1.8. Examining Thread State</a></li>
	<li><a name="TOC_HEAD_5eddc644" href="#HEAD_5eddc644">2.1.9. Examining Stack Frame State</a></li>
</menu>

</div>
<p>
	Here&rsquo;s a short precis of how to run lldb if you are familiar with the gdb command set. We will start with some details on lldb command structure and syntax to help orient you.
</p>
	<H3><a name="HEAD_391d2e9e" href="#TOC_HEAD_391d2e9e">2.1.1. Command Structure</a></H3>
<p>
	Unlike gdb&rsquo;s command set, which is rather free&ndash;form, we tried to make the lldb command syntax fairly structured. The commands are all of the form:
</p>
<pre><code>&lt;noun&gt; &lt;verb&gt; [-options [option-value]] [argument [argument...]]</code></pre>
<p>
	The command line parsing is done before command execution, so it is uniform across all the commands. The command syntax for basic commands is very simple, arguments, options and option values are all white&ndash;space separated, and either single or double&ndash;quotes (in pairs) are used to protect white&ndash;spaces in an argument. If you need to put a backslash or double&ndash;quote character in an argument you back&ndash;slash it in the argument. That makes the command syntax more regular, but it also means you may have to quote some arguments in lldb that you wouldn&rsquo;t in gdb.
</p>
<p>
	There is one other special quote character in lldb &ndash; the backtick. If you put backticks around an argument or option value, lldb will run the text of the value through the expression parser, and the result of the expression will be passed to the command. So for instance, if &ldquo;len&rdquo; is a local int variable with the value 5, then the command:
</p>
<pre><code>(lldb) memory read -c `len` 0x12345</code></pre>
<p>
	will receive the value 5 for the count option, rather than the string &ldquo;len&rdquo;.
</p>
<p>
	Options can be placed anywhere on the command line, but if the arguments begin with a &ldquo;&ndash;&rdquo; then you have to tell lldb that you&rsquo;re done with options for the current command by adding an option termination: &ldquo;–&rdquo;. So for instance, if you want to launch a process and give the &ldquo;process launch&rdquo; command the &ldquo;–stop&ndash;at&ndash;entry&rdquo; option, yet you want the process you are about to launch to be launched with the arguments &ldquo;&ndash;program_arg value&rdquo;, you would type:
</p>
<pre><code>(lldb) process launch --stop-at-entry -- -program_arg value</code></pre>
<p>
	We also tried to reduce the number of special purpose argument parsers, which sometimes forces the user to be a little more explicit about stating their intentions. The first instance you&rsquo;ll note of this is the breakpoint command. In gdb, to set a breakpoint, you might enter
</p>
<pre><code>(gdb) break foo.c:12</code></pre>
<p>
	to break at line 12 of foo.c, and:
</p>
<pre><code>(gdb) break foo</code></pre>
<p>
	to break at the function foo. As time went on, the parser that tells foo.c:12 from foo from foo.c::foo (which means the function foo in the file foo.c) got more and more complex and bizarre, and especially in C++ there are times where there&rsquo;s really no way to specify the function you want to break on. The lldb commands are more verbose but also more precise and allow for intelligent auto completion.
</p>
<p>
	To set the same file and line breakpoint in LLDB you can enter either of:
</p>
<pre><code>(lldb) breakpoint set --file foo.c --line 12
(lldb) breakpoint set -f foo.c -l 12</code></pre>
<p>
	To set a breakpoint on a function named foo in LLDB you can enter either of:
</p>
<pre><code>(lldb) breakpoint set --name foo
(lldb) breakpoint set -n foo</code></pre>
<p>
	You can use the –name option multiple times to make a breakpoint on a set of functions as well. This is convenient since it allows you to set common conditions or commands without having to specify them multiple times:
</p>
<pre><code>(lldb) breakpoint set --name foo --name bar</code></pre>
<p>
	Setting breakpoints by name is even more specialized in LLDB as you can specify that you want to set a breakpoint at a function by method name. To set a breakpoint on all C++ methods named foo you can enter either of:
</p>
<pre><code>(lldb) breakpoint set --method foo
(lldb) breakpoint set -M foo</code></pre>
<p>
	To set a breakpoint Objective&ndash;C selectors named alignLeftEdges: you can enter either of:
</p>
<pre><code>(lldb) breakpoint set --selector alignLeftEdges:
(lldb) breakpoint set -S alignLeftEdges:</code></pre>
<p>
	You can limit any breakpoints to a specific executable image by using the &ldquo;–shlib &lt;path&gt;&rdquo; (&ldquo;&ndash;s &lt;path&gt;&rdquo; for short):
</p>
<pre><code>(lldb) breakpoint set --shlib foo.dylib --name foo
(lldb) breakpoint set -s foo.dylib -n foo</code></pre>
<p>
	The –shlib option can also be repeated to specify several shared libraries.
</p>
<p>
	Suggestions on more interesting primitives of this sort are also very welcome.
</p>
<p>
	Just like gdb, the lldb command interpreter does a shortest unique string match on command names, so the following two commands will both execute the same command:
</p>
<pre><code>(lldb) breakpoint set -n "-[SKTGraphicView alignLeftEdges:]"
(lldb) br s -n "-[SKTGraphicView alignLeftEdges:]"</code></pre>
<p>
	lldb also supports command completion for source file names, symbol names, file names, etc. Completion is initiated by a hitting a TAB. Individual options in a command can have different completers, so for instance, the &ldquo;–file &lt;path&gt;&rdquo; option in &ldquo;breakpoint&rdquo; completes to source files, the &ldquo;–shlib &lt;path&gt;&rdquo; option to currently loaded shared libraries, etc. We can even do things like if you specify &ldquo;–shlib &lt;path&gt;&rdquo;, and are completing on &ldquo;–file &lt;path&gt;&rdquo;, we will only list source files in the shared library specified by &ldquo;–shlib &lt;path&gt;&rdquo;.
</p>
<p>
	The individual commands are pretty extensively documented. You can use the help command to get an overview of which commands are available or to obtain details about specific commands. There is also an apropos command that will search the help text for all commands for a particular word and dump a summary help string for each matching command.
</p>
<p>
	Finally, there is a mechanism to construct aliases for commonly used commands. For instance, if you get annoyed typing:
</p>
<pre><code>(lldb) breakpoint set --file foo.c --line 12</code></pre>
<p>
	you can do:
</p>
<pre><code>(lldb) command alias bfl breakpoint set -f %1 -l %2
(lldb) bfl foo.c 12</code></pre>
<p>
	We have added a few aliases for commonly used commands (e.g. &ldquo;step&rdquo;, &ldquo;next&rdquo; and &ldquo;continue&rdquo;) but we haven&rsquo;t tried to be exhaustive because in our experience it is more convenient to make the basic commands unique down to a letter or two, and then learn these sequences than to fill the namespace with lots of aliases, and then have to type them all the way out.
</p>
<p>
	However, users are free to customize lldb&rsquo;s command set however they like, and since lldb reads the file &tilde;/.lldbinit at startup, you can store all your aliases there and they will be generally available to you. Your aliases are also documented in the help command so you can remind yourself of what you&rsquo;ve set up.
</p>
<p>
	One alias of note that we do include by popular demand is a weak emulator of gdb&rsquo;s &ldquo;break&rdquo; command. It doesn&rsquo;t try to do everything that gdb&rsquo;s break command does (for instance, it doesn&rsquo;t handle foo.c::bar. But it mostly works, and makes the transition easier. Also, by popular demand, it is aliased to b. If you actually want to learn the lldb command set natively, that means it will get in the way of the rest of the breakpoint commands. Fortunately, if you don&rsquo;t like one of our aliases, you can easily get rid of it by running (for example):
</p>
<pre><code>(lldb) command unalias b</code></pre>
<p>
	I actually also do:
</p>
<pre><code>(lldb) command alias b breakpoint</code></pre>
<p>
	so I can run the native lldb breakpoint command with just b
</p>
<p>
	The lldb command parser also supports &ldquo;raw&rdquo; commands, where, after command options are stripped off, the rest of the command string is passed uninterpreted to the command. This is convenient for commands whose arguments might be some complex expression that would be painful to backslash protect. For instance, the &ldquo;expression&rdquo; command is a &ldquo;raw&rdquo; command for obvious reasons. The &ldquo;help&rdquo; output for a command will tell you if it is &ldquo;raw&rdquo; or not, so you know what to expect. The one thing you have to watch out for is that since raw commands still can have options, if your command string has dashes in it, you&rsquo;ll have to indicate these are not option markers by putting &ldquo;–&rdquo; after the command name, but before your command string.
</p>
<p>
	lldb also has a built&ndash;in Python interpreter, which is accessible by the &ldquo;script&rdquo; command. All the functionality of the debugger is available as classes in the Python interpreter, so the more complex commands that in gdb you would introduce with the &ldquo;define&rdquo; command can be done by writing Python functions using the lldb&ndash;Python library, then loading the scripts into your running session and accessing them with the &ldquo;script&rdquo; command.
</p>
<p>
	Having given an overview of lldb&rsquo;s command syntax, we proceed to lay out the stages of a standard debug session.
</p>
	<H3><a name="HEAD_d1b959ff" href="#TOC_HEAD_d1b959ff">2.1.2. Loading a Program into lldb</a></H3>
<p>
	First we need to set the program to debug. As with gdb, you can start lldb and specify the file you wish to debug on the command line:
</p>
<pre><code>$ lldb /Projects/Sketch/build/Debug/Sketch.app
Current executable set to '/Projects/Sketch/build/Debug/Sketch.app' (x86_64).</code></pre>
<p>
	or you can specify it after the fact with the &ldquo;file&rdquo; command:
</p>
<pre><code>$ lldb
(lldb) file /Projects/Sketch/build/Debug/Sketch.app
Current executable set to '/Projects/Sketch/build/Debug/Sketch.app' (x86_64).</code></pre>
	<H3><a name="HEAD_bcb7ec92" href="#TOC_HEAD_bcb7ec92">2.1.3. Setting Breakpoints</a></H3>
<p>
	We&rsquo;ve discussed how to set breakpoints above. You can use help breakpoint set to see all the options for breakpoint setting. For instance, we might do:
</p>
<pre><code>(lldb) breakpoint set --selector alignLeftEdges:
Breakpoint created: 1: name = 'alignLeftEdges:', locations = 1, resolved = 1</code></pre>
<p>
	You can find out about the breakpoints you&rsquo;ve set with:
</p>
<pre><code>(lldb) breakpoint list
Current breakpoints:
1: name = 'alignLeftEdges:', locations = 1, resolved = 1
1.1: where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405, address = 0x0000000100010d5b, resolved, hit count = 0</code></pre>
<p>
	Note that setting a breakpoint creates a logical breakpoint, which could resolve to one or more locations. For instance, break by selector would set a breakpoint on all the methods that implement that selector in the classes in your program. Similarly, a file and line breakpoint might result in multiple locations if that file and line were inlined in different places in your code.
</p>
<p>
	The logical breakpoint has an integer id, and its locations have an id within their parent breakpoint (the two are joined by a &ldquo;.&rdquo;, e.g. 1.1 in the example above).
</p>
<p>
	Also, the logical breakpoints remain live so that if another shared library were to be loaded that had another implementation of the &ldquo;alignLeftEdges:&rdquo; selector, the new location would be added to breakpoint 1 (e.g. a &ldquo;1.2&rdquo; breakpoint would be set on the newly loaded selector).
</p>
<p>
	The other piece of information in the breakpoint listing is whether the breakpoint location was resolved or not. A location gets resolved when the file address it corresponds to gets loaded into the program you are debugging. For instance if you set a breakpoint in a shared library that then gets unloaded, that breakpoint location will remain, but it will no longer be resolved.
</p>
<p>
	One other thing to note for gdb users is that lldb acts like gdb with:
</p>
<pre><code>(gdb) set breakpoint pending on</code></pre>
<p>
	That is, lldb will always make a breakpoint from your specification, even if it couldn&rsquo;t find any locations that match the specification. You can tell whether the expression was resolved or not by checking the locations field in &ldquo;breakpoint list&rdquo;, and we report the breakpoint as &ldquo;pending&rdquo; when you set it so you can tell you&rsquo;ve made a typo more easily, if that was indeed the reason no locations were found:
</p>
<p>
	(lldb) breakpoint set &ndash;&ndash;file foo.c &ndash;&ndash;line 12
	Breakpoint created: 2: file =&#039;foo.c&#039;, line = 12, locations = 0 (pending)
	WARNING: Unable to resolve breakpoint to any actual locations.
</p>
<p>
	You can delete, disable, set conditions and ignore counts either on all the locations generated by your logical breakpoint, or on any one of the particular locations your specification resolved to. For instance, if we wanted to add a command to print a backtrace when we hit this breakpoint we could do:
</p>
<pre><code>(lldb) breakpoint command add 1.1
Enter your debugger command(s). Type 'DONE' to end.
&gt; bt
&gt; DONE</code></pre>
<p>
	By default, the breakpoint command add command takes lldb command line commands. You can also specify this explicitly by passing the &ldquo;–command&rdquo; option. Use &ldquo;–script&rdquo; if you want to implement your breakpoint command using the Python script instead.
</p>
<p>
	This is a convenient point to bring up another feature of the lldb command help. Do:
</p>
<pre><code>(lldb) help break command add
Add a set of commands to a breakpoint, to be executed whenever the breakpoint is hit.

Syntax: breakpoint command add &lt;cmd-options&gt; &lt;breakpt-id&gt;
etc...</code></pre>
<p>
	When you see arguments to commands specified in the Syntax in angle brackets like &lt;breakpt&ndash;id&gt;, that indicates that that is some common argument type that you can get further help on from the command system. So in this case you could do:
</p>
<p>
	(lldb) help &lt;breakpt&ndash;id&gt; &lt;breakpt&ndash;id&gt; &ndash;&ndash; Breakpoint ID&#039;s consist major and
	minor numbers; the major etc...
</p>
	<H3><a name="HEAD_94d68a59" href="#TOC_HEAD_94d68a59">2.1.4. Breakpoint Names</a></H3>
<p>
	Breakpoints carry two orthogonal sets of information: one specifies where to set the breakpoint, and the other how to react when the breakpoint is hit. The latter set of information (e.g. commands, conditions, hit&ndash;count, auto&ndash;continue&hellip;) we call breakpoint options.
</p>
<p>
	It is fairly common to want to apply one set of options to a number of breakpoints. For instance, you might want to check that self == nil and if it is, print a backtrace and continue, on a number of methods. One convenient way to do that would be to make all the breakpoints, then configure the options with:
</p>
<pre><code>(lldb) breakpoint modify -c "self == nil" -C bt --auto-continue 1 2 3</code></pre>
<p>
	That&rsquo;s not too bad, but you have to repeat this for every new breakpoint you make, and if you wanted to change the options, you have to remember all the ones you are using this way.
</p>
<p>
	Breakpoint names provide a convenient solution to this problem. The simple solution would be to use the name to gather the breakpoints you want to affect this way into a group. So when you make the breakpoint you would do:
</p>
<pre><code>(lldb) breakpoint set -N SelfNil</code></pre>
<p>
	Then when you&rsquo;ve made all your breakpoints, you can set up or modify the options using the name to collect all the relevant breakpoints.
</p>
<pre><code>(lldb) breakpoint modify -c "self == nil" -C bt --auto-continue SelfNil</code></pre>
<p>
	That is better, but suffers from the problem that when new breakpoints get added, they don&rsquo;t pick up these modifications, and the options only exist in the context of actual breakpoints, so they are hard to store &amp; reuse.
</p>
<p>
	A even better solution is to make a fully configured breakpoint name:
</p>
<pre><code>(lldb) breakpoint name configure -c "self == nil" -C bt --auto-continue SelfNil</code></pre>
<p>
	Then you can apply the name to your breakpoints, and they will all pick up these options. The connection from name to breakpoints remains live, so when you change the options configured on the name, all the breakpoints pick up those changes. This makes it easy to use configured names to experiment with your options.
</p>
<p>
	You can make breakpoint names in your .lldbinit file, so you can use them to can behaviors that you have found useful and reapply them in future sessions.
</p>
<p>
	You can also make a breakpoint name from the options set on a breakpoint:
</p>
<pre><code>(lldb) breakpoint name configure -B 1 SelfNil</code></pre>
<p>
	which makes it easy to copy behavior from one breakpoint to a set of others.
</p>
	<H3><a name="HEAD_9bac3c62" href="#TOC_HEAD_9bac3c62">2.1.5. Setting Watchpoints</a></H3>
<p>
	In addition to breakpoints, you can use help watchpoint to see all the commands for watchpoint manipulations. For instance, we might do the following to watch a variable called &lsquo;global&rsquo; for write operation, but only stop if the condition &lsquo;(global==5)&rsquo; is true:
</p>
<pre><code>(lldb) watch set var global
Watchpoint created: Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w
declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'
(lldb) watch modify -c '(global==5)'
(lldb) watch list
Current watchpoints:
Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w
declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'
condition = '(global==5)'
(lldb) c
Process 15562 resuming
(lldb) about to write to 'global'...
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped and was programmatically restarted.
Process 15562 stopped
* thread #1: tid = 0x1c03, 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16, stop reason = watchpoint 1
frame #0: 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16
13
14        static void modify(int32_t &var) {
15            ++var;
-&gt; 16        }
17
18        int main(int argc, char** argv) {
19            int local = 0;
(lldb) bt
* thread #1: tid = 0x1c03, 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16, stop reason = watchpoint 1
frame #0: 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16
frame #1: 0x0000000100000eac a.out`main + 108 at main.cpp:25
frame #2: 0x00007fff8ac9c7e1 libdyld.dylib`start + 1
(lldb) frame var global
(int32_t) global = 5
(lldb) watch list -v
Current watchpoints:
Watchpoint 1: addr = 0x100001018 size = 4 state = enabled type = w
declare @ '/Volumes/data/lldb/svn/ToT/test/functionalities/watchpoint/watchpoint_commands/condition/main.cpp:12'
condition = '(global==5)'
hw_index = 0  hit_count = 5     ignore_count = 0
(lldb)</code></pre>
	<H3><a name="HEAD_2a45d21c" href="#TOC_HEAD_2a45d21c">2.1.6. Starting or Attaching to Your Program</a></H3>
<p>
	To launch a program in lldb we use the &ldquo;process launch&rdquo; command or one of its built in aliases:
</p>
<pre><code>(lldb) process launch
(lldb) run
(lldb) r</code></pre>
<p>
	You can also attach to a process by process ID or process name. When attaching to a process by name, lldb also supports the &ldquo;–waitfor&rdquo; option which waits for the next process that has that name to show up, and attaches to it
</p>
<pre><code>(lldb) process attach --pid 123
(lldb) process attach --name Sketch
(lldb) process attach --name Sketch --waitfor</code></pre>
<p>
	After you launch or attach to a process, your process might stop somewhere:
</p>
<pre><code>(lldb) process attach -p 12345
Process 46915 Attaching
Process 46915 Stopped
1 of 3 threads stopped with reasons:
* thread #1: tid = 0x2c03, 0x00007fff85cac76a, where = libSystem.B.dylib`__getdirentries64 + 10, stop reason = signal = SIGSTOP, queue = com.apple.main-thread</code></pre>
<p>
	Note the line that says &ldquo;1 of 3 threads stopped with reasons:&rdquo; and the lines that follow it. In a multi&ndash;threaded environment it is very common for more than one thread to hit your breakpoint(s) before the kernel actually returns control to the debugger. In that case, you will see all the threads that stopped for some interesting reason listed in the stop message.
</p>
	<H3><a name="HEAD_f17237e4" href="#TOC_HEAD_f17237e4">2.1.7. Controlling Your Program</a></H3>
<p>
	After launching, we can continue until we hit our breakpoint. The primitive commands for process control all exist under the &ldquo;thread&rdquo; command:
</p>
<pre><code>(lldb) thread continue
Resuming thread 0x2c03 in process 46915
Resuming process 46915
(lldb)</code></pre>
<p>
	At present you can only operate on one thread at a time, but the design will ultimately support saying &ldquo;step over the function in Thread 1, and step into the function in Thread 2, and continue Thread 3&rdquo; etc. When we eventually support keeping some threads running while others are stopped this will be particularly important. For convenience, however, all the stepping commands have easy aliases. So &ldquo;thread continue&rdquo; is just &ldquo;c&rdquo;, etc.
</p>
<p>
	The other program stepping commands are pretty much the same as in gdb. You&rsquo;ve got:
</p>
<pre><code>(lldb) thread step-in    // The same as gdb's "step" or "s"
(lldb) thread step-over  // The same as gdb's "next" or "n"
(lldb) thread step-out   // The same as gdb's "finish" or "f"</code></pre>
<p>
	By default, lldb does defined aliases to all common gdb process control commands (&ldquo;s&rdquo;, &ldquo;step&rdquo;, &ldquo;n&rdquo;, &ldquo;next&rdquo;, &ldquo;finish&rdquo;). If we have missed any, please add them to your &tilde;/.lldbinit file using the &ldquo;command alias&rdquo; command.
</p>
<p>
	lldb also supported the step by instruction versions:
</p>
<pre><code>(lldb) thread step-inst       // The same as gdb's "stepi" / "si"
(lldb) thread step-over-inst  // The same as gdb's "nexti" / "ni"</code></pre>
<p>
	Finally, lldb has a run until line or frame exit stepping mode:
</p>
<pre><code>(lldb) thread until 100</code></pre>
<p>
	This command will run the thread in the current frame till it reaches line 100 in this frame or stops if it leaves the current frame. This is a pretty close equivalent to gdb&rsquo;s &ldquo;until&rdquo; command.
</p>
<p>
	A process, by default, will share the lldb terminal with the inferior process. When in this mode, much like when debugging with gdb, when the process is running anything you type will go to the STDIN of the inferior process. To interrupt your inferior program, type CTRL+C.
</p>
<p>
	If you attach to a process, or launch a process with the &ldquo;–no&ndash;stdin&rdquo; option, the command interpreter is always available to enter commands. It might be a little disconcerting to gdb users to always have an (lldb) prompt. This allows you to set a breakpoint, etc without having to explicitly interrupt the program you are debugging:
</p>
<pre><code>(lldb) process continue
(lldb) breakpoint set --name stop_here</code></pre>
<p>
	There are many commands that won&rsquo;t work while running, and the command interpreter should do a good job of letting you know when this is the case. If you find any instances where the command interpreter isn&rsquo;t doing its job, please file a bug. This way of operation will set us up for a future debugging mode called thread centric debugging. This mode will allow us to run all threads and only stop the threads that are at breakpoints or have exceptions or signals.
</p>
<p>
	The commands that currently work while running include interrupting the process to halt execution (&ldquo;process interrupt&rdquo;), getting the process status (&ldquo;process status&rdquo;), breakpoint setting and clearing (&rdquo; breakpoint [set|clear|enable|disable|list] &hellip;&rdquo;), and memory reading and writing (&rdquo; memory [read|write] &hellip;&rdquo;).
</p>
<p>
	The question of disabling stdio when running brings up a good opportunity to show how to set debugger properties in general. If you always want to run in the –no&ndash;stdin mode, you can set this as a generic process property using the lldb &ldquo;settings&rdquo; command, which is equivalent to gdb&rsquo;s &ldquo;set&rdquo; command. For instance, in this case you would say:
</p>
<pre><code>(lldb) settings set target.process.disable-stdio true</code></pre>
<p>
	Over time, gdb&rsquo;s &ldquo;set command became a wilderness of disordered options, so that there were useful options that even experienced gdb users didn&rsquo;t know about because they were too hard to find. We tried to organize the settings hierarchically using the structure of the basic entities in the debugger. For the most part anywhere you can specify a setting on a generic entity (threads, for example) you can also apply the option to a particular instance, which can also be convenient at times. You can view the available settings with &ldquo;settings list&rdquo; and there is help on the settings command explaining how it works more generally.
</p>
	<H3><a name="HEAD_26b3101d" href="#TOC_HEAD_26b3101d">2.1.8. Examining Thread State</a></H3>
<p>
	Once you&rsquo;ve stopped, lldb will choose a current thread, usually the one that stopped &ldquo;for a reason&rdquo;, and a current frame in that thread (on stop this is always the bottom&ndash;most frame). Many the commands for inspecting state work on this current thread/frame.
</p>
<p>
	To inspect the current state of your process, you can start with the threads:
</p>
<pre><code>(lldb) thread list
Process 46915 state is Stopped
* thread #1: tid = 0x2c03, 0x00007fff85cac76a, where = libSystem.B.dylib`__getdirentries64 + 10, stop reason = signal = SIGSTOP, queue = com.apple.main-thread
thread #2: tid = 0x2e03, 0x00007fff85cbb08a, where = libSystem.B.dylib`kevent + 10, queue = com.apple.libdispatch-manager
thread #3: tid = 0x2f03, 0x00007fff85cbbeaa, where = libSystem.B.dylib`__workq_kernreturn + 10</code></pre>
<p>
	The * indicates that Thread 1 is the current thread. To get a backtrace for that thread, do:
</p>
<pre><code>(lldb) thread backtrace
thread #1: tid = 0x2c03, stop reason = breakpoint 1.1, queue = com.apple.main-thread
frame #0: 0x0000000100010d5b, where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405
frame #1: 0x00007fff8602d152, where = AppKit`-[NSApplication sendAction:to:from:] + 95
frame #2: 0x00007fff860516be, where = AppKit`-[NSMenuItem _corePerformAction] + 365
frame #3: 0x00007fff86051428, where = AppKit`-[NSCarbonMenuImpl performActionWithHighlightingForItemAtIndex:] + 121
frame #4: 0x00007fff860370c1, where = AppKit`-[NSMenu performKeyEquivalent:] + 272
frame #5: 0x00007fff86035e69, where = AppKit`-[NSApplication _handleKeyEquivalent:] + 559
frame #6: 0x00007fff85f06aa1, where = AppKit`-[NSApplication sendEvent:] + 3630
frame #7: 0x00007fff85e9d922, where = AppKit`-[NSApplication run] + 474
frame #8: 0x00007fff85e965f8, where = AppKit`NSApplicationMain + 364
frame #9: 0x0000000100015ae3, where = Sketch`main + 33 at /Projects/Sketch/SKTMain.m:11
frame #10: 0x0000000100000f20, where = Sketch`start + 52</code></pre>
<p>
	You can also provide a list of threads to backtrace, or the keyword &ldquo;all&rdquo; to see all threads:
</p>
<pre><code>(lldb) thread backtrace all</code></pre>
<p>
	You can select the current thread, which will be used by default in all the commands in the next section, with the &ldquo;thread select&rdquo; command:
</p>
<pre><code>(lldb) thread select 2</code></pre>
<p>
	where the thread index is just the one shown in the &ldquo;thread list&rdquo; listing.
</p>
	<H3><a name="HEAD_5eddc644" href="#TOC_HEAD_5eddc644">2.1.9. Examining Stack Frame State</a></H3>
<p>
	The most convenient way to inspect a frame&rsquo;s arguments and local variables is to use the &ldquo;frame variable&rdquo; command:
</p>
<pre><code>(lldb) frame variable
self = (SKTGraphicView *) 0x0000000100208b40
_cmd = (struct objc_selector *) 0x000000010001bae1
sender = (id) 0x00000001001264e0
selection = (NSArray *) 0x00000001001264e0
i = (NSUInteger) 0x00000001001264e0
c = (NSUInteger) 0x00000001001253b0</code></pre>
<p>
	As you see above, if you don&rsquo;t specify any variable names, all arguments and locals will be shown. If you call &ldquo;frame variable&rdquo; passing in the names of a particular local(s), only those variables will be printed. For instance:
</p>
<pre><code>(lldb) frame variable self
(SKTGraphicView *) self = 0x0000000100208b40</code></pre>
<p>
	You can also pass in a path to some subelement of one of the available locals, and that sub&ndash;element will be printed. For instance:
</p>
<pre><code>(lldb) frame variable self.isa
(struct objc_class *) self.isa = 0x0000000100023730</code></pre>
<p>
	The &ldquo;frame variable&rdquo; command is not a full expression parser but it does support a few simple operations like &amp;, *, &ndash;&gt;, [] (no overloaded operators). The array brackets can be used on pointers to treat pointers as arrays:
</p>
<pre><code>(lldb) frame variable *self
(SKTGraphicView *) self = 0x0000000100208b40
(NSView) NSView = {
(NSResponder) NSResponder = {
...

(lldb) frame variable &self
(SKTGraphicView **) &self = 0x0000000100304ab

(lldb) frame variable argv[0]
(char const *) argv[0] = 0x00007fff5fbffaf8 "/Projects/Sketch/build/Debug/Sketch.app/Contents/MacOS/Sketch"</code></pre>
<p>
	The frame variable command will also perform &ldquo;object printing&rdquo; operations on variables (currently we only support ObjC printing, using the object&rsquo;s &ldquo;description&rdquo; method. Turn this on by passing the &ndash;o flag to frame variable:
</p>
<pre><code>(lldb) frame variable -o self (SKTGraphicView *) self = 0x0000000100208b40 &lt;SKTGraphicView: 0x100208b40&gt;
You can select another frame to view with the "frame select" command

(lldb) frame select 9
frame #9: 0x0000000100015ae3, where = Sketch`function1 + 33 at /Projects/Sketch/SKTFunctions.m:11</code></pre>
<p>
	You can also move up and down the stack by passing the &ldquo;–relative&rdquo; (&ldquo;&ndash;r&rdquo;) option. And we have built&ndash;in aliases &ldquo;u&rdquo; and &ldquo;d&rdquo; which behave like their gdb equivalents.
</p>
	<H2><a name="HEAD_c4c9054f" href="#TOC_HEAD_c4c9054f">2.2. GDB to LLDB command map</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_ee27fad0" href="#HEAD_ee27fad0">2.2.1. Execution Commands</a></li>
	<li><a name="TOC_HEAD_e0a231d7" href="#HEAD_e0a231d7">2.2.2. Breakpoint Commands</a></li>
	<li><a name="TOC_HEAD_2171b1a7" href="#HEAD_2171b1a7">2.2.3. Watchpoint Commands</a></li>
	<li><a name="TOC_HEAD_1cde8b75" href="#HEAD_1cde8b75">2.2.4. Examining Variables</a></li>
	<li><a name="TOC_HEAD_78f9d6d1" href="#HEAD_78f9d6d1">2.2.5. Evaluating Expressions</a></li>
	<li><a name="TOC_HEAD_26b3101d_0" href="#HEAD_26b3101d_0">2.2.6. Examining Thread State</a></li>
	<li><a name="TOC_HEAD_3d013481" href="#HEAD_3d013481">2.2.7. Executable and Shared Library Query Commands</a></li>
	<li><a name="TOC_HEAD_8f4c53ce" href="#HEAD_8f4c53ce">2.2.8. Miscellaneous</a></li>
</menu>

</div>
<p>
	Below is a table of GDB commands with their LLDB counterparts. The built in GDB&ndash;compatibility aliases in LLDB are also listed. The full lldb command names are often long, but any unique short form can be used. Instead of &ldquo;breakpoint set&rdquo;, &ldquo;br se&rdquo; is also acceptable.
</p>
	<H3><a name="HEAD_ee27fad0" href="#TOC_HEAD_ee27fad0">2.2.1. Execution Commands</a></H3>
<ul>
	<li>Launch a process no arguments.</li>
	<br />
	<pre><code>(gdb) run                                           (lldb) process launch
(gdb) r                                             (lldb) run
                                                (lldb) r	</code></pre>
	<li>Launch a process with arguments &lt;args&gt;.</li>
	<br />
	<pre><code>(gdb) run &lt;args&gt;                                    (lldb) process launch -- &lt;args&gt;
(gdb) r &lt;args&gt; 	                                    (lldb) run &lt;args&gt;
                                                (lldb) r &lt;args&gt;	</code></pre>
	<li>Launch process a.out with arguments 1 2 3 without having to supply the args every time.</li>
	<br />
	<pre><code>% gdb --args a.out 1 2 3                            % lldb -- a.out 1 2 3
(gdb) run                                           (lldb) run
...                                                 ...
(gdb) run                                           (lldb) run
...                                                 ...

Or:
(gdb) set args 1 2 3                                (lldb) settings set target.run-args 1 2 3
(gdb) run                                           (lldb) run
...                                                 ...
(gdb) run                                           (lldb) run
...                                                 ...	</code></pre>
	<li>Launch a process with arguments in new terminal window (macOS only).</li>
	<br />
	<pre><code>                                                (lldb) process launch --tty -- &lt;args&gt;
                                                (lldb) pro la -t -- &lt;args&gt;	</code></pre>
	<li>Launch a process with arguments &lt;args&gt; in existing terminal /dev/ttys006 (macOS only).</li>
	<br />
	<pre><code>                                                (lldb) process launch --tty=/dev/ttys006 -- &lt;args&gt;
                                                (lldb) pro la -t/dev/ttys006 -- &lt;args&gt;	</code></pre>
	<li>Set environment variables for process before launching.</li>
	<br />
	<pre><code>(gdb) set env DEBUG 1                               (lldb) settings set target.env-vars DEBUG=1
                                                (lldb) set se target.env-vars DEBUG=1
                                                (lldb) env DEBUG=1	</code></pre>
	<li>Unset environment variables for process before launching.</li>
	<br />
	<pre><code>(gdb) unset env DEBUG                               (lldb) settings remove target.env-vars DEBUG
                                                (lldb) set rem target.env-vars DEBUG	</code></pre>
	<li>Show the arguments that will be or were passed to the program when run.</li>
	<br />
	<pre><code>(gdb) show args                                     (lldb) settings show target.run-args
Argument list to give program being debugged        target.run-args (array of strings) =
when it is started is "1 2 3".                      [0]: "1"
                                                [1]: "2"
                                                [2]: "3"	</code></pre>
	<li>Set environment variables for process and launch process in one command.</li>
	<br />
	<pre><code>                                                (lldb) process launch -E DEBUG=1	</code></pre>
	<li>Attach to the process with process ID 123.</li>
	<br />
	<pre><code>(gdb) attach 123                                    (lldb) process attach --pid 123
                                                (lldb) attach -p 123	</code></pre>
	<li>Attach to the process named &quot;a.out&quot;.</li>
	<br />
	<pre><code>(gdb) attach a.out                                  (lldb) process attach --name a.out
                                                (lldb) pro at -n a.out	</code></pre>
	<li>Wait for a process named &quot;a.out&quot; to launch and attach.</li>
	<br />
	<pre><code>(gdb) attach -waitfor a.out                         (lldb) process attach --name a.out --waitfor
                                                (lldb) pro at -n a.out -w	</code></pre>
	<li>Attach to a remote gdb protocol server running on system &quot;eorgadd&quot;, port 8000.</li>
	<br />
	<pre><code>(gdb) target remote eorgadd:8000                    (lldb) gdb-remote eorgadd:8000	</code></pre>
	<li>Attach to a remote gdb protocol server running on the local system, port 8000.</li>
	<br />
	<pre><code>(gdb) target remote localhost:8000                  (lldb) gdb-remote 8000	</code></pre>
	<li>Attach to a Darwin kernel in kdp mode on system &quot;eorgadd&quot;.</li>
	<br />
	<pre><code>(gdb) kdp-reattach eorgadd                          (lldb) kdp-remote eorgadd	</code></pre>
	<li>Do a source level single step in the currently selected thread.</li>
	<br />
	<pre><code>(gdb) step                                          (lldb) thread step-in
(gdb) s                                             (lldb) step
                                                (lldb) s	</code></pre>
	<li>Do a source level single step over in the currently selected thread.</li>
	<br />
	<pre><code>(gdb) next                                          (lldb) thread step-over
(gdb) n                                             (lldb) next
                                                (lldb) n	</code></pre>
	<li>Do an instruction level single step in the currently selected thread.</li>
	<br />
	<pre><code>(gdb) stepi                                         (lldb) thread step-inst
(gdb) si                                            (lldb) si	</code></pre>
	<li>Do an instruction level single step over in the currently selected thread.</li>
	<br />
	<pre><code>(gdb) nexti                                         (lldb) thread step-inst-over
(gdb) ni                                            (lldb) ni	</code></pre>
	<li>Step out of the currently selected frame.</li>
	<br />
	<pre><code>(gdb) finish                                        (lldb) thread step-out
                                                (lldb) finish	</code></pre>
	<li>Return immediately from the currently selected frame, with an optional return value.</li>
	<br />
	<pre><code>(gdb) return &lt;RETURN EXPRESSION&gt;                    (lldb) thread return &lt;RETURN EXPRESSION&gt;	</code></pre>
	<li>Backtrace and disassemble every time you stop.</li>
	<br />
	<pre><code>                                                (lldb) target stop-hook add
                                                Enter your stop hook command(s). Type 'DONE' to end.
                                                &gt; bt
                                                &gt; disassemble --pc
                                                &gt; DONE
                                                Stop hook #1 added.	</code></pre>
	<li>Run until we hit line 12 or control leaves the current function.</li>
	<br />
	<pre><code>(gdb) until 12                                      (lldb) thread until 12	</code></pre>
	<li>Show the current frame and source line.</li>
	<br />
	<pre><code>(gdb) frame                                         (lldb) frame select
                                                (lldb) f
                                                (lldb) process status @	</code></pre>
</ul>
	<H3><a name="HEAD_e0a231d7" href="#TOC_HEAD_e0a231d7">2.2.2. Breakpoint Commands</a></H3>
<ul>
	<li>Set a breakpoint at all functions named main.</li>
	<br />
	<pre><code>(gdb) break main                                    (lldb) breakpoint set --name main
                                                (lldb) br s -n main
                                                (lldb) b main	</code></pre>
	<li>Set a breakpoint in file test.c at line 12.</li>
	<br />
	<pre><code>(gdb) break test.c:12                               (lldb) breakpoint set --file test.c --line 12
                                                (lldb) br s -f test.c -l 12
                                                (lldb) b test.c:12	</code></pre>
	<li>Set a breakpoint at all C++ methods whose basename is main.</li>
	<br />
	<pre><code>(gdb) break main                                    (lldb) breakpoint set --method main
(Hope that there are no C functions named main).    (lldb) br s -M main	</code></pre>
	<li>Set a breakpoint at an Objective&ndash;C function &ndash;[NSString stringWithFormat:].</li>
	<br />
	<pre><code>(gdb) break -[NSString stringWithFormat:]           (lldb) breakpoint set --name "-[NSString stringWithFormat:]"
                                                (lldb) b -[NSString stringWithFormat:]	</code></pre>
	<li>Set a breakpoint at all Objective&ndash;C methods whose selector is count.</li>
	<br />
	<pre><code>(gdb) break count                                         (lldb) breakpoint set --selector count
(Hope that there are no C or C++ functions named count).  (lldb) br s -S count	</code></pre>
	<li>Set a breakpoint by regular expression on function name.</li>
	<br />
	<pre><code>(gdb) rbreak regular-expression                     (lldb) breakpoint set --func-regex regular-expression
                                                (lldb) br s -r regular-expression	</code></pre>
	<li>Ensure that breakpoints by file and line work for #include .c/.cpp/.m files.</li>
	<br />
	<pre><code>(gdb) b foo.c:12                                    (lldb) settings set target.inline-breakpoint-strategy always
                                                (lldb) br s -f foo.c -l 12	</code></pre>
	<li>Set a breakpoint by regular expression on source file contents.</li>
	<br />
	<pre><code>(gdb) shell grep -e -n pattern source-file          (lldb) breakpoint set --source-pattern regular-expression --file SourceFile
(gdb) break source-file:CopyLineNumbers             (lldb) br s -p regular-expression -f file	</code></pre>
	<li>Set a conditional breakpoint.</li>
	<br />
	<pre><code>(gdb) break foo if strcmp(y,"hello") == 0           (lldb) breakpoint set --name foo --condition '(int)strcmp(y,"hello") == 0'
                                                (lldb) br s -n foo -c '(int)strcmp(y,"hello") == 0'	</code></pre>
	<li>List all breakpoints.</li>
	<br />
	<pre><code>(gdb) info break                                    (lldb) breakpoint list
                                                (lldb) br l	</code></pre>
	<li>Delete a breakpoint.</li>
	<br />
	<pre><code>(gdb) delete 1                                      (lldb) breakpoint delete 1
                                                (lldb) br del 1	</code></pre>
	<li>Disable a breakpoint.</li>
	<br />
	<pre><code>(gdb) disable 1                                     (lldb) breakpoint disable 1
                                                (lldb) br dis 1	</code></pre>
	<li>Enable a breakpoint.</li>
	<br />
	<pre><code>(gdb) enable 1                                      (lldb) breakpoint enable 1
                                                (lldb) br en 1	</code></pre>
</ul>
	<H3><a name="HEAD_2171b1a7" href="#TOC_HEAD_2171b1a7">2.2.3. Watchpoint Commands</a></H3>
<ul>
	<li>Set a watchpoint on a variable when it is written to.</li>
	<br />
	<pre><code>(gdb) watch global_var                              (lldb) watchpoint set variable global_var
                                                (lldb) wa s v global_var	</code></pre>
	<li>Set a watchpoint on a memory location when it is written into. The size of the region to watch for defaults to the pointer size if no &#039;&ndash;x byte_size&#039; is specified. This command takes raw input, evaluated as an expression returning an unsigned integer pointing to the start of the region, after the &#039;&ndash;&ndash;&#039; option terminator.</li>
	<br />
	<pre><code>(gdb) watch -location g_char_ptr                    (lldb) watchpoint set expression -- my_ptr
                                                (lldb) wa s e -- my_ptr	</code></pre>
	<li>Set a condition on a watchpoint.</li>
	<br />
	<pre><code>                                                (lldb) watch set var global
                                                (lldb) watchpoint modify -c '(global==5)'
                                                (lldb) c
                                                ...
                                                (lldb) bt
                                                * thread #1: tid = 0x1c03, 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16, stop reason = watchpoint 1
                                                frame #0: 0x0000000100000ef5 a.out`modify + 21 at main.cpp:16
                                                frame #1: 0x0000000100000eac a.out`main + 108 at main.cpp:25
                                                frame #2: 0x00007fff8ac9c7e1 libdyld.dylib`start + 1
                                                (lldb) frame var global
                                                (int32_t) global = 5	</code></pre>
	<li>List all watchpoints.</li>
	<br />
	<pre><code>(gdb) info break                                    (lldb) watchpoint list
                                                (lldb) watch l	</code></pre>
	<li>Delete a watchpoint.</li>
	<br />
	<pre><code>(gdb) delete 1                                      (lldb) watchpoint delete 1
                                                (lldb) watch del 1	</code></pre>
</ul>
	<H3><a name="HEAD_1cde8b75" href="#TOC_HEAD_1cde8b75">2.2.4. Examining Variables</a></H3>
<ul>
	<li>Show the arguments and local variables for the current frame.</li>
	<br />
	<pre><code>(gdb) info args                                     (lldb) frame variable
(gdb) info locals                                   (lldb) fr v	</code></pre>
	<li>Show the local variables for the current frame.</li>
	<br />
	<pre><code>(gdb) info locals                                   (lldb) frame variable --no-args
                                                (lldb) fr v -a	</code></pre>
	<li>Show the contents of local variable &quot;bar&quot;.</li>
	<br />
	<pre><code>(gdb) p bar                                         (lldb) frame variable bar
                                                (lldb) fr v bar
                                                (lldb) p bar	</code></pre>
	<li>Show the contents of local variable &quot;bar&quot; formatted as hex.</li>
	<br />
	<pre><code>(gdb) p/x bar                                       (lldb) frame variable --format x bar
                                                (lldb) fr v -f x bar	</code></pre>
	<li>Show the contents of global variable &quot;baz&quot;.</li>
	<br />
	<pre><code>(gdb) p baz                                         (lldb) target variable baz
                                                (lldb) ta v baz	</code></pre>
	<li>Show the global/static variables defined in the current source file.</li>
	<br />
	<pre><code>n/a                                                 (lldb) target variable
                                                (lldb) ta v	</code></pre>
	<li>Display the variables &quot;argc&quot; and &quot;argv&quot; every time you stop.</li>
	<br />
	<pre><code>(gdb) display argc                                  (lldb) target stop-hook add --one-liner "frame variable argc argv"
(gdb) display argv                                  (lldb) ta st a -o "fr v argc argv"
                                                (lldb) display argc
                                                (lldb) display argv	</code></pre>
	<li>Display the variables &quot;argc&quot; and &quot;argv&quot; only when you stop in the function named main.</li>
	<br />
	<pre><code>                                                (lldb) target stop-hook add --name main --one-liner "frame variable argc argv"
                                                (lldb) ta st a -n main -o "fr v argc argv"	</code></pre>
	<li>Display the variable &quot;*this&quot; only when you stop in c class named MyClass.</li>
	<br />
	<pre><code>                                                (lldb) target stop-hook add --classname MyClass --one-liner "frame variable *this"
                                                (lldb) ta st a -c MyClass -o "fr v *this"	</code></pre>
	<li>Print an array of integers in memory, assuming we have a pointer like &quot;int *ptr&quot;.</li>
	<br />
	<pre><code>(gdb) p *ptr@10                                     (lldb) parray 10 ptr	</code></pre>
</ul>
	<H3><a name="HEAD_78f9d6d1" href="#TOC_HEAD_78f9d6d1">2.2.5. Evaluating Expressions</a></H3>
<ul>
	<li>Evaluating a generalized expression in the current frame.</li>
	<br />
	<pre><code>(gdb) print (int) printf ("Print nine: %d.", 4 + 5)         (lldb) expr (int) printf ("Print nine: %d.", 4 + 5)
or if you don't want to see void returns:                   or using the print alias:
(gdb) call (int) printf ("Print nine: %d.", 4 + 5)          (lldb) print (int) printf ("Print nine: %d.", 4 + 5)	</code></pre>
	<li>Creating and assigning a value to a convenience variable.</li>
	<br />
	<pre><code>(gdb) set $foo = 5                                          In lldb you evaluate a variable declaration expression as you would write it in C:
(gdb) set variable $foo = 5                                 (lldb) expr unsigned int $foo = 5
or using the print command
(gdb) print $foo = 5
or using the call command
(gdb) call $foo = 5
and if you want to specify the type of the variable:
(gdb) set $foo = (unsigned int) 5	</code></pre>
</ul>
<p>
	Printing the ObjC &quot;description&quot; of an object.
</p>
<pre><code>(gdb) po [SomeClass returnAnObject]                         (lldb) expr -o -- [SomeClass returnAnObject]
                                                            or using the po alias:
                                                            (lldb) po [SomeClass returnAnObject]</code></pre>
<ul>
	<li>Print the dynamic type of the result of an expression.</li>
	<br />
	<pre><code>(gdb) set print object 1                                    (lldb) expr -d 1 -- [SomeClass returnAnObject]
(gdb) p someCPPObjectPtrOrReference                         (lldb) expr -d 1 -- someCPPObjectPtrOrReference
only works for C++ objects.                                 or set dynamic type printing to be the default: (lldb) settings set target.prefer-dynamic run-target	</code></pre>
	<li>Call a function so you can stop at a breakpoint in it.</li>
	<br />
	<pre><code>(gdb) set unwindonsignal 0                                  (lldb) expr -i 0 -- function_with_a_breakpoint()
(gdb) p function_with_a_breakpoint()	</code></pre>
	<li>Call a function that crashes, then stop when it does.</li>
	<br />
	<pre><code>(gdb) set unwindonsignal 0                                  (lldb) expr -u 0 -- function_which_crashes()
(gdb) p function_which_crashes()	</code></pre>
</ul>
	<H3><a name="HEAD_26b3101d_0" href="#TOC_HEAD_26b3101d_0">2.2.6. Examining Thread State</a></H3>
<ul>
	<li>List the threads in your program.</li>
	<br />
	<pre><code>(gdb) info threads                                          (lldb) thread list	</code></pre>
	<li>Select thread 1 as the default thread for subsequent commands.</li>
	<br />
	<pre><code>(gdb) thread 1                                              (lldb) thread select 1
                                                        (lldb) t 1	</code></pre>
	<li>Show the stack backtrace for the current thread.</li>
	<br />
	<pre><code>(gdb) bt                                                    (lldb) thread backtrace
                                                        (lldb) bt	</code></pre>
	<li>Show the stack backtraces for all threads.</li>
	<br />
	<pre><code>(gdb) thread apply all bt                                   (lldb) thread backtrace all
                                                        (lldb) bt all	</code></pre>
	<li>Backtrace the first five frames of the current thread.</li>
	<br />
	<pre><code>(gdb) bt 5                                                  (lldb) thread backtrace -c 5
                                                        (lldb) bt 5 (lldb-169 and later)
                                                        (lldb) bt -c 5 (lldb-168 and earlier)	</code></pre>
	<li>Select a different stack frame by index for the current thread.</li>
	<br />
	<pre><code>(gdb) frame 12                                              (lldb) frame select 12
                                                        (lldb) fr s 12
                                                        (lldb) f 12	</code></pre>
	<li>List information about the currently selected frame in the current thread.</li>
	<br />
	<pre><code>                                                        (lldb) frame info	</code></pre>
	<li>Select the stack frame that called the current stack frame.</li>
	<br />
	<pre><code>(gdb) up                                                    (lldb) up
                                                        (lldb) frame select --relative=1	</code></pre>
	<li>Select the stack frame that is called by the current stack frame.</li>
	<br />
	<pre><code>(gdb) down                                                  (lldb) down
                                                        (lldb) frame select --relative=-1
                                                        (lldb) fr s -r-1	</code></pre>
	<li>Select a different stack frame using a relative offset.</li>
	<br />
	<pre><code>(gdb) up 2                                                  (lldb) frame select --relative 2
(gdb) down 3                                                (lldb) fr s -r2
                                                        (lldb) frame select --relative -3
                                                        (lldb) fr s -r-3	</code></pre>
	<li>Show the general purpose registers for the current thread.</li>
	<br />
	<pre><code>(gdb) info registers                                        (lldb) register read	</code></pre>
	<li>Write a new decimal value &#039;123&#039; to the current thread register &#039;rax&#039;.</li>
	<br />
	<pre><code>(gdb) p $rax = 123                                          (lldb) register write rax 123	</code></pre>
	<li>Skip 8 bytes ahead of the current program counter (instruction pointer). Note that we use backticks to evaluate an expression and insert the scalar result in LLDB.</li>
	<br />
	<pre><code>(gdb) jump *$pc+8                                           (lldb) register write pc `$pc+8`	</code></pre>
	<li>Show the general purpose registers for the current thread formatted as <strong>signed decimal</strong> . LLDB tries to use the same format characters as printf(3) when possible. Type &quot;help format&quot; to see the full list of format specifiers.</li>
	<br />
	<pre><code>                                                        (lldb) register read --format i
                                                        (lldb) re r -f i
                                                        LLDB now supports the GDB shorthand format syntax but there can't be space after the command:
                                                        (lldb) register read/d	</code></pre>
	<li>Show all registers in all register sets for the current thread.</li>
	<br />
	<pre><code>(gdb) info all-registers                                    (lldb) register read --all
                                                        (lldb) re r -a	</code></pre>
	<li>Show the values for the registers named &quot;rax&quot;, &quot;rsp&quot; and &quot;rbp&quot; in the current thread.</li>
	<br />
	<pre><code>(gdb) info all-registers rax rsp rbp                        (lldb) register read rax rsp rbp	</code></pre>
	<li>Show the values for the register named &quot;rax&quot; in the current thread formatted as binary.</li>
	<br />
	<pre><code>(gdb) p/t $rax                                              (lldb) register read --format binary rax
                                                        (lldb) re r -f b rax
                                                            LLDB now supports the GDB shorthand format syntax but there
                                                            can't be space after the command:
                                                        (lldb) register read/t rax
                                                        (lldb) p/t $rax	</code></pre>
	<li>Read memory from address 0xbffff3c0 and show 4 hex uint32_t values.</li>
	<br />
	<pre><code>(gdb) x/4xw 0xbffff3c0                                      (lldb) memory read --size 4 --format x --count 4 0xbffff3c0
                                                        (lldb) me r -s4 -fx -c4 0xbffff3c0
                                                        (lldb) x -s4 -fx -c4 0xbffff3c0
                                                            LLDB now supports the GDB shorthand format syntax but there
                                                            can't be space after the command:
                                                        (lldb) memory read/4xw 0xbffff3c0
                                                        (lldb) x/4xw 0xbffff3c0
                                                        (lldb) memory read --gdb-format 4xw 0xbffff3c0	</code></pre>
	<li>Read memory starting at the expression &quot;argv[0]&quot;.</li>
	<br />
	<pre><code>(gdb) x argv[0]                                             (lldb) memory read `argv[0]`
                                                            NOTE: any command can inline a scalar expression result
                                                            (as long as the target is stopped) using backticks around any expression:
                                                        (lldb) memory read --size `sizeof(int)` `argv[0]`	</code></pre>
	<li>Read 512 bytes of memory from address 0xbffff3c0 and save the results to a local file as text.</li>
	<br />
	<pre><code>(gdb) set logging on                                        (lldb) memory read --outfile /tmp/mem.txt --count 512 0xbffff3c0
(gdb) set logging file /tmp/mem.txt                         (lldb) me r -o/tmp/mem.txt -c512 0xbffff3c0
(gdb) x/512bx 0xbffff3c0                                    (lldb) x/512bx -o/tmp/mem.txt 0xbffff3c0
(gdb) set logging off	</code></pre>
	<li>Save binary memory data starting at 0x1000 and ending at 0x2000 to a file.</li>
	<br />
	<pre><code>(gdb) dump memory /tmp/mem.bin 0x1000 0x2000                (lldb) memory read --outfile /tmp/mem.bin --binary 0x1000 0x2000
                                                        (lldb) me r -o /tmp/mem.bin -b 0x1000 0x2000	</code></pre>
	<li>Get information about a specific heap allocation (available on macOS only).</li>
	<br />
	<pre><code>(gdb) info malloc 0x10010d680                               (lldb) command script import lldb.macosx.heap
                                                        (lldb) process launch --environment MallocStackLogging=1 -- [ARGS]
                                                        (lldb) malloc_info --stack-history 0x10010d680	</code></pre>
	<li>Get information about a specific heap allocation and cast the result to any dynamic type that can be deduced (available on macOS only)</li>
	<br />
	<pre><code>                                                        (lldb) command script import lldb.macosx.heap
                                                        (lldb) malloc_info --type 0x10010d680	</code></pre>
	<li>Find all heap blocks that contain a pointer specified by an expression EXPR (available on macOS only).</li>
	<br />
	<pre><code>                                                        (lldb) command script import lldb.macosx.heap
                                                        (lldb) ptr_refs EXPR	</code></pre>
	<li>Find all heap blocks that contain a C string anywhere in the block (available on macOS only).</li>
	<br />
	<pre><code>                                                        (lldb) command script import lldb.macosx.heap
                                                        (lldb) cstr_refs CSTRING	</code></pre>
	<li>Disassemble the current function for the current frame.</li>
	<br />
	<pre><code>(gdb) disassemble                                           (lldb) disassemble --frame
                                                        (lldb) di -f	</code></pre>
	<li>Disassemble any functions named main.</li>
	<br />
	<pre><code>(gdb) disassemble main                                      (lldb) disassemble --name main
                                                        (lldb) di -n main	</code></pre>
	<li>Disassemble an address range.</li>
	<br />
	<pre><code>(gdb) disassemble 0x1eb8 0x1ec3                             (lldb) disassemble --start-address 0x1eb8 --end-address 0x1ec3
                                                        (lldb) di -s 0x1eb8 -e 0x1ec3	</code></pre>
	<li>Disassemble 20 instructions from a given address.</li>
	<br />
	<pre><code>(gdb) x/20i 0x1eb8                                          (lldb) disassemble --start-address 0x1eb8 --count 20
                                                        (lldb) di -s 0x1eb8 -c 20	</code></pre>
	<li>Show mixed source and disassembly for the current function for the current frame.</li>
	<br />
	<pre><code>n/a                                                          (lldb) disassemble --frame --mixed
                                                        (lldb) di -f -m	</code></pre>
	<li>Disassemble the current function for the current frame and show the opcode bytes.</li>
	<br />
	<pre><code>n/a                                                         (lldb) disassemble --frame --bytes
                                                        (lldb) di -f -b	</code></pre>
	<li>Disassemble the current source line for the current frame.</li>
	<br />
	<pre><code>n/a                                                         (lldb) disassemble --line
                                                        (lldb) di -l	</code></pre>
</ul>
	<H3><a name="HEAD_3d013481" href="#TOC_HEAD_3d013481">2.2.7. Executable and Shared Library Query Commands</a></H3>
<ul>
	<li>List the main executable and all dependent shared libraries.</li>
	<br />
	<pre><code>(gdb) info shared                                           (lldb) image list	</code></pre>
	<li>Look up information for a raw address in the executable or any shared libraries.</li>
	<br />
	<pre><code>(gdb) info symbol 0x1ec4                                    (lldb) image lookup --address 0x1ec4
                                                        (lldb) im loo -a 0x1ec4	</code></pre>
	<li>Look up functions matching a regular expression in a binary.</li>
	<br />
	<pre><code>(gdb) info function &lt;FUNC_REGEX&gt;                            This one finds debug symbols:
                                                        (lldb) image lookup -r -n &lt;FUNC_REGEX&gt;
                                                        This one finds non-debug symbols:
                                                        (lldb) image lookup -r -s &lt;FUNC_REGEX&gt;
                                                        Provide a list of binaries as arguments to limit the search.	</code></pre>
	<li>Find full source line information.</li>
	<br />
	<pre><code>(gdb) info line 0x1ec4                                      This one is a bit messy at present. Do:
                                                        (lldb) image lookup -v --address 0x1ec4
                                                        and look for the LineEntry line, which will have the full source path and line range information.	</code></pre>
	<li>Look up information for an address in a.out only.</li>
	<br />
	<pre><code>                                                        (lldb) image lookup --address 0x1ec4 a.out
                                                        (lldb) im loo -a 0x1ec4 a.out	</code></pre>
	<li>Look up information for for a type Point by name.</li>
	<br />
	<pre><code>(gdb) ptype Point                                           (lldb) image lookup --type Point
                                                        (lldb) im loo -t Point	</code></pre>
	<li>Dump all sections from the main executable and any shared libraries.</li>
	<br />
	<pre><code>(gdb) maintenance info sections                             (lldb) image dump sections	</code></pre>
	<li>Dump all sections in the a.out module.</li>
	<br />
	<pre><code>                                                        (lldb) image dump sections a.out	</code></pre>
	<li>Dump all symbols from the main executable and any shared libraries.</li>
	<br />
	<pre><code>                                                        (lldb) image dump symtab	</code></pre>
	<li>Dump all symbols in a.out and liba.so.</li>
	<br />
	<pre><code>                                                        (lldb) image dump symtab a.out liba.so	</code></pre>
</ul>
	<H3><a name="HEAD_8f4c53ce" href="#TOC_HEAD_8f4c53ce">2.2.8. Miscellaneous</a></H3>
<ul>
	<li>Search command help for a keyword.</li>
	<br />
	<pre><code>(gdb) apropos keyword                                       (lldb) apropos keyword	</code></pre>
	<li>Echo text to the screen.</li>
	<br />
	<pre><code>(gdb) echo Here is some text\n                              (lldb) script print "Here is some text"	</code></pre>
	<li>Remap source file pathnames for the debug session. If your source files are no longer located in the same location as when the program was built (for example, if the program was built on a different computer) you need to tell the debugger how to find the sources at their local file path instead of the build system&#039;s file path.</li>
	<br />
	<pre><code>(gdb) set pathname-substitutions /buildbot/path /my/path    (lldb) settings set target.source-map /buildbot/path /my/path	</code></pre>
	<li>Supply a catchall directory to search for source files in.</li>
	<br />
	<p>
		(gdb) directory /my/path                                        (No equivalent command &ndash; use the source&ndash;map instead.)
	</p>
</ul>
	<H2><a name="HEAD_e52bc31" href="#TOC_HEAD_e52bc31">2.3. Frame and Thread Format</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_adfbb359" href="#HEAD_adfbb359">2.3.1. Format Strings</a></li>
	<li><a name="TOC_HEAD_72879d57" href="#HEAD_72879d57">2.3.2. Variables</a></li>
	<li><a name="TOC_HEAD_ac18294d" href="#HEAD_ac18294d">2.3.3. Control Characters</a></li>
	<li><a name="TOC_HEAD_1dfd1474" href="#HEAD_1dfd1474">2.3.4. Desensitizing Characters in the Format String</a></li>
	<li><a name="TOC_HEAD_d5e5adf1" href="#HEAD_d5e5adf1">2.3.5. Scoping</a></li>
	<li><a name="TOC_HEAD_edec15ce" href="#HEAD_edec15ce">2.3.6. Making the Frame Format</a></li>
	<li><a name="TOC_HEAD_ec80048a" href="#HEAD_ec80048a">2.3.7. Making Your own Formats</a></li>
</menu>

</div>
<p>
	LLDB has a facility to allow users to define the format of the information that generates the descriptions for threads and stack frames. Typically when your program stops at a breakpoint you will get two lines that describes why your thread stopped and where:
</p>
<pre><code>* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: test`main at test.c:5</code></pre>
<p>
	Stack backtraces frames also have a similar information line:
</p>
<pre><code>(lldb) thread backtrace
* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
    frame #0: 0x0000000100000e85 a.out`main + 4 at test.c:19
    frame #1: 0x0000000100000e40 a.out`start + 52</code></pre>
<p>
	The two format strings that govern the printing in these output forms can currently be set using the settings set command:
</p>
<pre><code>(lldb) settings set thread-stop-format STRING
(lldb) settings set frame-format STRING</code></pre>
<p>
	The first of these is an abbreviated thread output, that just contains data about the thread, and not the stop frame. It will always get used in situations where the frame output follows immediately, so that information would be redundant. The second is the frame printing.
</p>
<p>
	There is another thread format used for commands like thread list where the thread information isn&rsquo;t followed by frame info. In that case, it is convenient to have frame zero information in the thread output. That format is set by:
</p>
<pre><code>(lldb) settings set thread-format STRING</code></pre>
	<H3><a name="HEAD_adfbb359" href="#TOC_HEAD_adfbb359">2.3.1. Format Strings</a></H3>
<p>
	So what is the format of the format strings? Format strings can contain plain text, control characters and variables that have access to the current program state.
</p>
<p>
	Normal characters are any text that doesn&rsquo;t contain a <code>{, }, $, or \</code> character.
</p>
<p>
	Variable names are found in between a <code>${ prefix, and end with a }</code> suffix. In other words, a variable looks like <code>${frame.pc}</code> .
</p>
	<H3><a name="HEAD_72879d57" href="#TOC_HEAD_72879d57">2.3.2. Variables</a></H3>
<p>
	A complete list of currently supported format string variables is listed below:
</p>
<table id="mdt_t">
	<tr id="mdt_hd">
		<td id="mdt_td_l">Variable Name</td>
		<td id="mdt_td_l">Description</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">file.basename</td>
		<td id="mdt_td_l">The current compile unit file basename for the current frame.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">file.fullpath</td>
		<td id="mdt_td_l">The current compile unit file fullpath for the current frame.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">language</td>
		<td id="mdt_td_l">The current compile unit language for the current frame.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">frame.index</td>
		<td id="mdt_td_l">The frame index (0, 1, 2, 3&hellip;)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">frame.no&ndash;debug</td>
		<td id="mdt_td_l">Evaluates to true if the frame has no debug info.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">frame.pc</td>
		<td id="mdt_td_l">The generic frame register for the program counter.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">frame.sp</td>
		<td id="mdt_td_l">The generic frame register for the stack pointer.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">frame.fp</td>
		<td id="mdt_td_l">The generic frame register for the frame pointer.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">frame.flags</td>
		<td id="mdt_td_l">The generic frame register for the flags register.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">frame.reg.NAME</td>
		<td id="mdt_td_l">Access to any platform specific register by name (replace NAME with the name of the desired register).</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">function.name</td>
		<td id="mdt_td_l">The name of the current function or symbol.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">function.name&ndash;with&ndash;args</td>
		<td id="mdt_td_l">The name of the current function with arguments and values or the symbol name.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">function.name&ndash;without&ndash;args</td>
		<td id="mdt_td_l">The name of the current function without arguments and values (used to include a function name in&ndash;line in the disassembly&ndash;format)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">function.mangled&ndash;name</td>
		<td id="mdt_td_l">The mangled name of the current function or symbol.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">function.pc&ndash;offset</td>
		<td id="mdt_td_l">The program counter offset within the current function or symbol</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">function.addr&ndash;offset</td>
		<td id="mdt_td_l">The offset in bytes of the current function, formatted as &rdquo; + dddd&rdquo;</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">function.concrete&ndash;only&ndash;addr&ndash;offset&ndash;no&ndash;padding</td>
		<td id="mdt_td_l">Similar to function.addr&ndash;offset except that there are no spaces in the output (e.g. &ldquo;+dddd&rdquo;) and the offset is computed from the nearest concrete function – inlined functions are not included</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">function.changed</td>
		<td id="mdt_td_l">Will evaluate to true when the line being formatted is a different symbol context from the previous line (may be used in disassembly&ndash;format to print the new function name on a line by itself at the start of a new function). Inlined functions are not considered for this variable</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">function.initial&ndash;function</td>
		<td id="mdt_td_l">Will evaluate to true if this is the start of the first function, as opposed to a change of functions (may be used in disassembly&ndash;format to print the function name for the first function being disassembled)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">line.file.basename</td>
		<td id="mdt_td_l">The line table entry basename to the file for the current line entry in the current frame.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">line.file.fullpath</td>
		<td id="mdt_td_l">The line table entry fullpath to the file for the current line entry in the current frame.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">line.number</td>
		<td id="mdt_td_l">The line table entry line number for the current line entry in the current frame.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">line.start&ndash;addr</td>
		<td id="mdt_td_l">The line table entry start address for the current line entry in the current frame.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">line.end&ndash;addr</td>
		<td id="mdt_td_l">The line table entry end address for the current line entry in the current frame.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">module.file.basename</td>
		<td id="mdt_td_l">The basename of the current module (shared library or executable)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">module.file.fullpath</td>
		<td id="mdt_td_l">The basename of the current module (shared library or executable)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">process.file.basename</td>
		<td id="mdt_td_l">The basename of the file for the process</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">process.file.fullpath</td>
		<td id="mdt_td_l">The fullname of the file for the process</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">process.id</td>
		<td id="mdt_td_l">The process ID native to the system on which the inferior runs.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">process.name</td>
		<td id="mdt_td_l">The name of the process at runtime</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">thread.id</td>
		<td id="mdt_td_l">The thread identifier for the current thread</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">thread.index</td>
		<td id="mdt_td_l">The unique one based thread index ID which is guaranteed to be unique as threads come and go.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">thread.name</td>
		<td id="mdt_td_l">The name of the thread if the target OS supports naming threads</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">thread.queue</td>
		<td id="mdt_td_l">The queue name of the thread if the target OS supports dispatch queues</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">thread.stop&ndash;reason</td>
		<td id="mdt_td_l">A textual reason why the thread stopped. If the thread have a recognized frame, this displays its recognized stop reason. Otherwise, gets the stop info description.</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">thread.stop&ndash;reason&ndash;raw</td>
		<td id="mdt_td_l">A textual reason why the thread stopped. Always returns stop info description.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">thread.return&ndash;value</td>
		<td id="mdt_td_l">The return value of the latest step operation (currently only for step&ndash;out.)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">thread.completed&ndash;expression</td>
		<td id="mdt_td_l">The expression result for a thread that just finished an interrupted expression evaluation.</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">target.arch</td>
		<td id="mdt_td_l">The architecture of the current target</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">script.target:python_func</td>
		<td id="mdt_td_l">Use a Python function to generate a piece of textual output</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">script.process:python_func</td>
		<td id="mdt_td_l">Use a Python function to generate a piece of textual output</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">script.thread:python_func</td>
		<td id="mdt_td_l">Use a Python function to generate a piece of textual output</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">script.frame:python_func</td>
		<td id="mdt_td_l">Use a Python function to generate a piece of textual output</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">current&ndash;pc&ndash;arrow</td>
		<td id="mdt_td_l">Prints either &ndash;&gt; or <code></code> <code></code> if the current pc value is matched (used in disassembly&ndash;format)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">addr&ndash;file&ndash;or&ndash;load</td>
		<td id="mdt_td_l">Formats an address either as a load address, or if process has not yet been launched, as a load address (used in disassembly&ndash;format)</td>
	</tr>
</table>
<br>
	<H3><a name="HEAD_ac18294d" href="#TOC_HEAD_ac18294d">2.3.3. Control Characters</a></H3>
<p>
	Control characters include {, }, and \.
</p>
<p>
	The { and } are used for scoping blocks, and the \ character allows you to desensitize control characters and also emit non&ndash;printable characters.
</p>
	<H3><a name="HEAD_1dfd1474" href="#TOC_HEAD_1dfd1474">2.3.4. Desensitizing Characters in the Format String</a></H3>
<p>
	The backslash control character allows your to enter the typical <code>\a, \b, \f, \n, \r, \t, \v, \\,</code> characters and along with the standard octal representation \0123 and hex \xAB characters. This allows you to enter escape characters into your format strings and will allow colorized output for terminals that support color.
</p>
	<H3><a name="HEAD_d5e5adf1" href="#TOC_HEAD_d5e5adf1">2.3.5. Scoping</a></H3>
<p>
	Many times the information that you might have in your prompt might not be available and you won<code></code>t want it to print out if it isn<code></code>t valid. To take care of this you can enclose everything that must resolve into a scope. A scope is starts with { and ends with }. For example in order to only display the current frame line table entry basename and line number when the information is available for the current frame:
</p>
<pre><code>"{ at {$line.file.basename}:${line.number}}"</code></pre>
<p>
	Broken down this is:
</p>
<ul>
	<li>The start the scope: { ,</li>
	<li>format whose content will only be displayed if all information is available: at {$line.file.basename}:${line.number}</li>
	<li>end the scope: }</li>
	<br />
</ul>
	<H3><a name="HEAD_edec15ce" href="#TOC_HEAD_edec15ce">2.3.6. Making the Frame Format</a></H3>
<p>
	The information that we see when stopped in a frame:
</p>
<pre><code>frame #0: 0x0000000100000e85 a.out`main + 4 at test.c:19</code></pre>
<p>
	can be displayed with the following format:
</p>
<pre><code>"frame #${frame.index}: ${frame.pc}{ ${module.file.basename}`${function.name}{${function.pc-offset}}}{ at ${line.file.basename}:${line.number}}\n"</code></pre>
<p>
	This breaks down to:
</p>
<ul>
	<li>Always print the frame index and frame PC: frame #${frame.index}: ${frame.pc},</li>
	<li>only print the module followed by a tick if there is a valid module for the current frame: { ${module.file.basename}`},</li>
	<li>print the function name with optional offset: {${function.name}{${function.pc&ndash;offset}}},</li>
	<li>print the line info if it is available: { at ${line.file.basename}:${line.number}},</li>
	<li>then finish off with a newline: \n.</li>
	<br />
</ul>
	<H3><a name="HEAD_ec80048a" href="#TOC_HEAD_ec80048a">2.3.7. Making Your own Formats</a></H3>
<p>
	When modifying your own format strings, it is useful to start with the default values for the frame and thread format strings. These can be accessed with the settings show command:
</p>
<pre><code>(lldb) settings show thread-format
thread-format (format-string) = "thread #${thread.index}: tid = ${thread.id%tid}{, ${frame.pc}}{ ${module.file.basename}{`${function.name-with-args}{${frame.no-debug}${function.pc-offset}}}}{ at ${line.file.basename}:${line.number}}{, name = '${thread.name}'}{, queue = '${thread.queue}'}{, activity = '${thread.info.activity.name}'}{, ${thread.info.trace_messages} messages}{, stop reason = ${thread.stop-reason}}{\nReturn value: ${thread.return-value}}{\nCompleted expression: ${thread.completed-expression}}\n"
(lldb) settings show frame-format
frame-format (format-string) = "frame #${frame.index}:{ ${frame.no-debug}${frame.pc}}{ ${module.file.basename}{`${function.name-with-args}{${frame.no-debug}${function.pc-offset}}}}{ at ${line.file.basename}:${line.number}}{${function.is-optimized} [opt]}\n"</code></pre>
<p>
	When making thread formats, you will need surround any of the information that comes from a stack frame with scopes ({ frame&ndash;content }) as the thread format doesn&rsquo;t always want to show frame information. When displaying the backtrace for a thread, we don&rsquo;t need to duplicate the information for frame zero in the thread information:
</p>
<pre><code>(lldb) thread backtrace
thread #1: tid = 0x2e03, stop reason = breakpoint 1.1 2.1
frame #0: 0x0000000100000e85 a.out`main + 4 at test.c:19
frame #1: 0x0000000100000e40 a.out`start + 52</code></pre>
<p>
	The frame related variables are:
</p>
<ul>
	<li>${file.*}</li>
	<li>${frame.*}</li>
	<li>${function.*}</li>
	<li>${line.*}</li>
	<li>${module.*}</li>
	<br />
</ul>
<p>
	Looking at the default format for the thread, and underlining the frame information:
</p>
<pre><code>thread #${thread.index}: tid = ${thread.id}{, ${frame.pc}}{ ${module.file.basename}`${function.name}{${function.pc-offset}}}{, stop reason = ${thread.stop-reason}}{, name = ${thread.name}}{, queue = ${thread.queue}}\n</code></pre>
<p>
	We can see that all frame information is contained in scopes so that when the thread information is displayed in a context where we only want to show thread information, we can do so.
</p>
<p>
	For both thread and frame formats, you can use ${script.target:python_func}, ${script.process:python_func} and ${script.thread:python_func} (and of course ${script.frame:python_func} for frame formats) In all cases, the signature of python_func is expected to be:
</p>
<pre><code>def python_func(object,unused):
...
return string</code></pre>
<p>
	Where object is an instance of the SB class associated to the keyword you are using.
</p>
<p>
	e.g. Assuming your function looks like:
</p>
<pre><code>def thread_printer_func (thread,unused):
return "Thread %s has %d frames\n" % (thread.name, thread.num_frames)</code></pre>
<p>
	And you set it up with:
</p>
<pre><code>(lldb) settings set thread-format "${script.thread:thread_printer_func}"</code></pre>
<p>
	you would see output like:
</p>
<pre><code>* Thread main has 21 frames</code></pre>
	<H2><a name="HEAD_55277b89" href="#TOC_HEAD_55277b89">2.4. Variable Formatting</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_4614af9d" href="#HEAD_4614af9d">2.4.1. Type Format</a></li>
	<li><a name="TOC_HEAD_3628e4c0" href="#HEAD_3628e4c0">2.4.2. Type Summary</a></li>
	<li><a name="TOC_HEAD_67d72fc8" href="#HEAD_67d72fc8">2.4.3. Summary Strings</a></li>
	<li><a name="TOC_HEAD_1e5b23ac" href="#HEAD_1e5b23ac">2.4.4. Formatting Summary Elements</a></li>
	<li><a name="TOC_HEAD_b4c601fa" href="#HEAD_b4c601fa">2.4.5. Element Inlining</a></li>
	<li><a name="TOC_HEAD_79b8768d" href="#HEAD_79b8768d">2.4.6. Bitfields And Array Syntax</a></li>
	<li><a name="TOC_HEAD_93d664f3" href="#HEAD_93d664f3">2.4.7. Python Scripting</a></li>
	<li><a name="TOC_HEAD_a9af26ea" href="#HEAD_a9af26ea">2.4.8. Regular Expression Typenames</a></li>
	<li><a name="TOC_HEAD_ca5b7fac" href="#HEAD_ca5b7fac">2.4.9. Names Summaries</a></li>
	<li><a name="TOC_HEAD_5180d4ba" href="#HEAD_5180d4ba">2.4.10. Synthetic Children</a></li>
	<li><a name="TOC_HEAD_30493bdb" href="#HEAD_30493bdb">2.4.11. Filters</a></li>
	<li><a name="TOC_HEAD_7d609f0e" href="#HEAD_7d609f0e">2.4.12. Callback&ndash;based type matching</a></li>
	<li><a name="TOC_HEAD_5cb78d1c" href="#HEAD_5cb78d1c">2.4.13. Objective&ndash;C Dynamic Type Discovery</a></li>
	<li><a name="TOC_HEAD_c419223c" href="#HEAD_c419223c">2.4.14. Categories</a></li>
	<li><a name="TOC_HEAD_8fe797f2" href="#HEAD_8fe797f2">2.4.15. Finding Formatters 101</a></li>
</menu>

</div>
<p>
	LLDB has a data formatters subsystem that allows users to define custom display options for their variables.
</p>
<p>
	Usually, when you type frame variable or run some expression LLDB will automatically choose the way to display your results on a per&ndash;type basis, as in the following example:
</p>
<pre><code>(lldb) frame variable
(uint8_t) x = 'a'
(intptr_t) y = 124752287</code></pre>
<p>
	Note: frame variable without additional arguments prints the list of variables of the current frame.
</p>
<p>
	However, in certain cases, you may want to associate a different style to the display for certain datatypes. To do so, you need to give hints to the debugger as to how variables should be displayed. The LLDB type command allows you to do just that.
</p>
<p>
	Using it you can change your visualization to look like this:
</p>
<pre><code>(lldb) frame variable
(uint8_t) x = chr='a' dec=65 hex=0x41
(intptr_t) y = 0x76f919f</code></pre>
<p>
	In addition, some data structures can encode their data in a way that is not easily readable to the user, in which case a data formatter can be used to show the data in a human readable way. For example, without a formatter, printing a std::deque&lt;int&gt; with the elements {2, 3, 4, 5, 6} would result in something like:
</p>
<pre><code>(lldb) frame variable a_deque
(std::deque&lt;Foo, std::allocator&lt;int&gt; &gt;) $0 = {
std::_Deque_base&lt;Foo, std::allocator&lt;int&gt; &gt; = {
    _M_impl = {
        _M_map = 0x000000000062ceb0
        _M_map_size = 8
        _M_start = {
            _M_cur = 0x000000000062cf00
            _M_first = 0x000000000062cf00
            _M_last = 0x000000000062d2f4
            _M_node = 0x000000000062cec8
        }
        _M_finish = {
            _M_cur = 0x000000000062d300
            _M_first = 0x000000000062d300
            _M_last = 0x000000000062d6f4
            _M_node = 0x000000000062ced0
        }
    }
}
}</code></pre>
<p>
	which is very hard to make sense of.
</p>
<p>
	Note: frame variable &lt;var&gt; prints out the variable &lt;var&gt; in the current frame.
</p>
<p>
	On the other hand, a proper formatter is able to produce the following output:
</p>
<pre><code>(lldb) frame variable a_deque
(std::deque&lt;Foo, std::allocator&lt;int&gt; &gt;) $0 = size=5 {
[0] = 2
[1] = 3
[2] = 4
[3] = 5
[4] = 6
}</code></pre>
<p>
	which is what the user would expect from a good debugger.
</p>
<p>
	Note: you can also use v &lt;var&gt; instead of frame variable &lt;var&gt;.
</p>
<p>
	It&rsquo;s worth mentioning that the size=5 string is produced by a summary provider and the list of children is produced by a synthetic child provider. More information about these providers is available later in this document.
</p>
<p>
	There are several features related to data visualization: formats, summaries, filters, synthetic children.
</p>
<p>
	To reflect this, the type command has five subcommands:
</p>
<pre><code>type format
type summary
type filter
type synthetic
type category</code></pre>
<p>
	These commands are meant to bind printing options to types. When variables are printed, LLDB will first check if custom printing options have been associated to a variable&rsquo;s type and, if so, use them instead of picking the default choices.
</p>
<p>
	Each of the commands (except type category) has four subcommands available:
</p>
<ul>
	<li>add: associates a new printing option to one or more types</li>
	<li>delete: deletes an existing association</li>
	<li>list: provides a listing of all associations</li>
	<li>clear: deletes all associations</li>
	<br />
</ul>
	<H3><a name="HEAD_4614af9d" href="#TOC_HEAD_4614af9d">2.4.1. Type Format</a></H3>
<p>
	Type formats enable you to quickly override the default format for displaying primitive types (the usual basic C/C++/ObjC types: int, float, char, &hellip;).
</p>
<p>
	If for some reason you want all int variables in your program to print out as hex, you can add a format to the int type.
</p>
<p>
	This is done by typing
</p>
<pre><code>(lldb) type format add --format hex int</code></pre>
<p>
	at the LLDB command line.
</p>
<p>
	The --format (which you can shorten to &ndash;f) option accepts a format name. Then, you provide one or more types to which you want the new format applied.
</p>
<p>
	A frequent scenario is that your program has a typedef for a numeric type that you know represents something that must be printed in a certain way. Again, you can add a format just to that typedef by using type format add with the name alias.
</p>
<p>
	But things can quickly get hierarchical. Let&rsquo;s say you have a situation like the following:
</p>
<pre><code>typedef int A;
typedef A B;
typedef B C;
typedef C D;</code></pre>
<p>
	and you want to show all A&rsquo;s as hex, all C&rsquo;s as byte arrays and leave the defaults untouched for other types (albeit its contrived look, the example is far from unrealistic in large software systems).
</p>
<p>
	If you simply type
</p>
<pre><code>(lldb) type format add -f hex A
(lldb) type format add -f uint8_t[] C</code></pre>
<p>
	values of type B will be shown as hex and values of type D as byte arrays, as in:
</p>
<pre><code>(lldb) frame variable -T
(A) a = 0x00000001
(B) b = 0x00000002
(C) c = {0x03 0x00 0x00 0x00}
(D) d = {0x04 0x00 0x00 0x00}</code></pre>
<p>
	This is because by default LLDB cascades formats through typedef chains. In order to avoid that you can use the option &ndash;C no to prevent cascading, thus making the two commands required to achieve your goal:
</p>
<pre><code>(lldb) type format add -C no -f hex A
(lldb) type format add -C no -f uint8_t[] C</code></pre>
<p>
	which provides the desired output:
</p>
<pre><code>(lldb) frame variable -T
(A) a = 0x00000001
(B) b = 2
(C) c = {0x03 0x00 0x00 0x00}
(D) d = 4</code></pre>
<p>
	Note, that qualifiers such as const and volatile will be stripped when matching types for example:
</p>
<pre><code>(lldb) frame var x y z
(int) x = 1
(const int) y = 2
(volatile int) z = 4
(lldb) type format add -f hex int
(lldb) frame var x y z
(int) x = 0x00000001
(const int) y = 0x00000002
(volatile int) z = 0x00000004</code></pre>
<p>
	Two additional options that you will want to look at are –skip&ndash;pointers (&ndash;p) and –skip&ndash;references (&ndash;r). These two options prevent LLDB from applying a format for type T to values of type T* and T&amp; respectively.
</p>
<pre><code>(lldb) type format add -f float32[] int
(lldb) frame variable pointer *pointer -T
(int *) pointer = {1.46991e-39 1.4013e-45}
(int) *pointer = {1.53302e-42}
(lldb) type format add -f float32[] int -p
(lldb) frame variable pointer *pointer -T
(int *) pointer = 0x0000000100100180
(int) *pointer = {1.53302e-42}</code></pre>
<p>
	While they can be applied to pointers and references, formats will make no attempt to dereference the pointer and extract the value before applying the format, which means you are effectively formatting the address stored in the pointer rather than the pointee value. For this reason, you may want to use the &ndash;p option when defining formats.
</p>
<p>
	If you need to delete a custom format simply type type format delete followed by the name of the type to which the format applies.Even if you defined the same format for multiple types on the same command, type format delete will only remove the format for the type name passed as argument.
</p>
<p>
	To delete ALL formats, use type format clear. To see all the formats defined, use type format list.
</p>
<p>
	If all you need to do, however, is display one variable in a custom format, while leaving the others of the same type untouched, you can simply type:
</p>
<pre><code>(lldb) frame variable counter -f hex</code></pre>
<p>
	This has the effect of displaying the value of counter as an hexadecimal number, and will keep showing it this way until you either pick a different format or till you let your program run again.
</p>
<p>
	Finally, this is a list of formatting options available out of which you can pick:
</p>
<table id="mdt_t">
	<tr id="mdt_hd">
		<td id="mdt_td_l">Format name</td>
		<td id="mdt_td_l">Abbreviation</td>
		<td id="mdt_td_l">Description</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">default</td>
		<td id="mdt_td_l"></td>
		<td id="mdt_td_l">the default LLDB algorithm is used to pick a format</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">boolean</td>
		<td id="mdt_td_l">B</td>
		<td id="mdt_td_l">show this as a true/false boolean, using the customary rule that 0 is false and everything else is true</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">binary</td>
		<td id="mdt_td_l">b</td>
		<td id="mdt_td_l">show this as a sequence of bits</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">bytes</td>
		<td id="mdt_td_l">y</td>
		<td id="mdt_td_l">show the bytes one after the other</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">bytes with ASCII</td>
		<td id="mdt_td_l">Y</td>
		<td id="mdt_td_l">show the bytes, but try to display them as ASCII characters as well</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">character</td>
		<td id="mdt_td_l">c</td>
		<td id="mdt_td_l">show the bytes as ASCII characters</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">printable character</td>
		<td id="mdt_td_l">C</td>
		<td id="mdt_td_l">show the bytes as printable ASCII characters</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">complex float</td>
		<td id="mdt_td_l">F</td>
		<td id="mdt_td_l">interpret this value as the real and imaginary part of a complex floating&ndash;point number</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">c&ndash;string</td>
		<td id="mdt_td_l">s</td>
		<td id="mdt_td_l">show this as a 0&ndash;terminated C string</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">decimal</td>
		<td id="mdt_td_l">d</td>
		<td id="mdt_td_l">show this as a signed integer number (this does not perform a cast, it simply shows the bytes as an integer with sign)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">enumeration</td>
		<td id="mdt_td_l">E</td>
		<td id="mdt_td_l">show this as an enumeration, printing the value&rsquo;s name if available or the integer value otherwise</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">hex</td>
		<td id="mdt_td_l">x</td>
		<td id="mdt_td_l">show this as in hexadecimal notation (this does not perform a cast, it simply shows the bytes as hex)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">float</td>
		<td id="mdt_td_l">f</td>
		<td id="mdt_td_l">show this as a floating&ndash;point number (this does not perform a cast, it simply interprets the bytes as an IEEE754 floating&ndash;point value)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">octal</td>
		<td id="mdt_td_l">o</td>
		<td id="mdt_td_l">show this in octal notation</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">OSType</td>
		<td id="mdt_td_l">O</td>
		<td id="mdt_td_l">show this as a MacOS OSType</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">unicode16</td>
		<td id="mdt_td_l">U</td>
		<td id="mdt_td_l">show this as UTF&ndash;16 characters</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">unicode32</td>
		<td id="mdt_td_l"></td>
		<td id="mdt_td_l">show this as UTF&ndash;32 characters</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">unsigned decimal</td>
		<td id="mdt_td_l">u</td>
		<td id="mdt_td_l">show this as an unsigned integer number (this does not perform a cast, it simply shows the bytes as unsigned integer)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">pointer</td>
		<td id="mdt_td_l">p</td>
		<td id="mdt_td_l">show this as a native pointer (unless this is really a pointer, the resulting address will probably be invalid)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">char[]</td>
		<td id="mdt_td_l"></td>
		<td id="mdt_td_l">show this as an array of characters</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">int8_t[], uint8_t[] int16_t[], uint16_t[] int32_t[], uint32_t[] int64_t[], uint64_t[] uint128_t[]</td>
		<td id="mdt_td_l"></td>
		<td id="mdt_td_l">show this as an array of the corresponding integer type</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">float32[], float64[]</td>
		<td id="mdt_td_l"></td>
		<td id="mdt_td_l">show this as an array of the corresponding floating&ndash;point type</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">complex integer</td>
		<td id="mdt_td_l">I</td>
		<td id="mdt_td_l">interpret this value as the real and imaginary part of a complex integer number</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">character array</td>
		<td id="mdt_td_l">a</td>
		<td id="mdt_td_l">show this as a character array</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">address</td>
		<td id="mdt_td_l">A</td>
		<td id="mdt_td_l">show this as an address target (symbol/file/line + offset), possibly also the string this address is pointing to</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">hex float</td>
		<td id="mdt_td_l"></td>
		<td id="mdt_td_l">show this as hexadecimal floating point</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">instruction</td>
		<td id="mdt_td_l">i</td>
		<td id="mdt_td_l">show this as an disassembled opcode</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">void</td>
		<td id="mdt_td_l">v</td>
		<td id="mdt_td_l">don&rsquo;t show anything</td>
	</tr>
</table>
<br>
	<H3><a name="HEAD_3628e4c0" href="#TOC_HEAD_3628e4c0">2.4.2. Type Summary</a></H3>
<p>
	Type formats work by showing a different kind of display for the value of a variable. However, they only work for basic types. When you want to display a class or struct in a custom format, you cannot do that using formats.
</p>
<p>
	A different feature, type summaries, works by extracting information from classes, structures, &hellip; (aggregate types) and arranging it in a user&ndash;defined format, as in the following example:
</p>
<p>
	before adding a summary&hellip;
</p>
<pre><code>(lldb) frame variable -T one
(i_am_cool) one = {
(int) x = 3
(float) y = 3.14159
(char) z = 'E'
}</code></pre>
<p>
	after adding a summary&hellip;
</p>
<pre><code>(lldb) frame variable one
(i_am_cool) one = int = 3, float = 3.14159, char = 69</code></pre>
<p>
	There are two ways to use type summaries: the first one is to bind a summary string to the type; the second is to write a Python script that returns the string to be used as summary. Both options are enabled by the type summary add command.
</p>
<p>
	The command to obtain the output shown in the example is:
</p>
<pre><code>(lldb) type summary add --summary-string "int = ${var.x}, float = ${var.y}, char = ${var.z%u}" i_am_cool</code></pre>
<p>
	Initially, we will focus on summary strings, and then describe the Python binding mechanism.
</p>
	<H3><a name="HEAD_67d72fc8" href="#TOC_HEAD_67d72fc8">2.4.3. Summary Strings</a></H3>
<p>
	Summary strings are written using a simple control language, exemplified by the snippet above. A summary string contains a sequence of tokens that are processed by LLDB to generate the summary.
</p>
<p>
	Summary strings can contain plain text, control characters and special variables that have access to information about the current object and the overall program state.
</p>
<p>
	Plain text is any sequence of characters that doesn&rsquo;t contain a {, }, $, or \ character, which are the syntax control characters.
</p>
<p>
	The special variables are found in between a &ldquo;${&rdquo; prefix, and end with a &ldquo;}&rdquo; suffix. Variables can be a simple name or they can refer to complex objects that have subitems themselves. In other words, a variable looks like ${object} or ${object.child.otherchild}. A variable can also be prefixed or suffixed with other symbols meant to change the way its value is handled. An example is ${*var.int_pointer[0&ndash;3]}.
</p>
<p>
	Basically, the syntax is the same one described Frame and Thread Formatting plus additional symbols specific for summary strings. The main of them is ${var, which is used refer to the variable that a summary is being created for.
</p>
<p>
	The simplest thing you can do is grab a member variable of a class or structure by typing its expression path. In the previous example, the expression path for the field float y is simply .y. Thus, to ask the summary string to display y you would type ${var.y}.
</p>
<p>
	If you have code like the following:
</p>
<pre><code>struct A {
int x;
int y;
};
struct B {
A x;
A y;
int *z;
};</code></pre>
<p>
	the expression path for the y member of the x member of an object of type B would be .x.y and you would type ${var.x.y} to display it in a summary string for type B.
</p>
<p>
	By default, a summary defined for type T, also works for types T* and T&amp; (you can disable this behavior if desired). For this reason, expression paths do not differentiate between . and &ndash;&gt;, and the above expression path .x.y would be just as good if you were displaying a B*, or even if the actual definition of B were:
</p>
<pre><code>struct B {
A *x;
A y;
int *z;
};</code></pre>
<p>
	This is unlike the behavior of frame variable which, on the contrary, will enforce the distinction. As hinted above, the rationale for this choice is that waiving this distinction enables you to write a summary string once for type T and use it for both T and T* instances. As a summary string is mostly about extracting nested members&rsquo; information, a pointer to an object is just as good as the object itself for the purpose.
</p>
<p>
	If you need to access the value of the integer pointed to by B::z, you cannot simply say ${var.z} because that symbol refers to the pointer z. In order to dereference it and get the pointed value, you should say ${*var.z}. The ${*var tells LLDB to get the object that the expression paths leads to, and then dereference it. In this example is it equivalent to *(bObject.z) in C/C++ syntax. Because . and &ndash;&gt; operators can both be used, there is no need to have dereferences in the middle of an expression path (e.g. you do not need to type ${*(var.x).x}) to read A::x as contained in *(B::x). To achieve that effect you can simply write ${var.x&ndash;&gt;x}, or even ${var.x.x}. The * operator only binds to the result of the whole expression path, rather than piecewise, and there is no way to use parentheses to change that behavior.
</p>
<p>
	Of course, a summary string can contain more than one ${var specifier, and can use ${var and ${*var specifiers together.
</p>
	<H3><a name="HEAD_1e5b23ac" href="#TOC_HEAD_1e5b23ac">2.4.4. Formatting Summary Elements</a></H3>
<p>
	An expression path can include formatting codes. Much like the type formats discussed previously, you can also customize the way variables are displayed in summary strings, regardless of the format they have applied to their types. To do that, you can use %format inside an expression path, as in ${var.x&ndash;&gt;x%u}, which would display the value of x as an unsigned integer.
</p>
<p>
	You can also use some other special format markers, not available for formats themselves, but which carry a special meaning when used in this context:
</p>
<table id="mdt_t">
	<tr id="mdt_hd">
		<td id="mdt_td_l">Symbol</td>
		<td id="mdt_td_l">Description</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">Symbol</td>
		<td id="mdt_td_l">Description</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">%S</td>
		<td id="mdt_td_l">Use this object&rsquo;s summary (the default for aggregate types)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">%V</td>
		<td id="mdt_td_l">Use this object&rsquo;s value (the default for non&ndash;aggregate types)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">%@</td>
		<td id="mdt_td_l">Use a language&ndash;runtime specific description (for C++ this does nothing, for Objective&ndash;C it calls the NSPrintForDebugger API)</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">%L</td>
		<td id="mdt_td_l">Use this object&rsquo;s location (memory address, register name, &hellip;)</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">%#</td>
		<td id="mdt_td_l">Use the count of the children of this object</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">%T</td>
		<td id="mdt_td_l">Use this object&rsquo;s datatype name</td>
	</tr>
	<tr id="mdt_tr2">
		<td id="mdt_td_l">%N</td>
		<td id="mdt_td_l">Print the variable&rsquo;s basename</td>
	</tr>
	<tr id="mdt_tr1">
		<td id="mdt_td_l">%&gt;</td>
		<td id="mdt_td_l">Print the expression path for this item</td>
	</tr>
</table>
<br>
<p>
	Since lldb 3.7.0, you can also specify ${script.var:pythonFuncName}.
</p>
<p>
	It is expected that the function name you use specifies a function whose signature is the same as a Python summary function. The return string from the function will be placed verbatim in the output.
</p>
<p>
	You cannot use element access, or formatting symbols, in combination with this syntax. For example the following:
</p>
<pre><code>${script.var.element[0]:myFunctionName%@}</code></pre>
<p>
	is not valid and will cause the summary to fail to evaluate.
</p>
	<H3><a name="HEAD_b4c601fa" href="#TOC_HEAD_b4c601fa">2.4.5. Element Inlining</a></H3>
<p>
	Option –inline&ndash;children (&ndash;c) to type summary add tells LLDB not to look for a summary string, but instead to just print a listing of all the object&rsquo;s children on one line.
</p>
<p>
	As an example, given a type pair:
</p>
<pre><code>(lldb) frame variable --show-types a_pair
(pair) a_pair = {
(int) first = 1;
(int) second = 2;
}</code></pre>
<p>
	If one types the following commands:
</p>
<pre><code>(lldb) type summary add --inline-children pair</code></pre>
<p>
	the output becomes:
</p>
<pre><code>(lldb) frame variable a_pair
(pair) a_pair = (first=1, second=2)</code></pre>
<p>
	Of course, one can obtain the same effect by typing
</p>
<pre><code>(lldb) type summary add pair --summary-string "(first=${var.first}, second=${var.second})"</code></pre>
<p>
	While the final result is the same, using –inline&ndash;children can often save time. If one does not need to see the names of the variables, but just their values, the option –omit&ndash;names (&ndash;O, uppercase letter o), can be combined with –inline&ndash;children to obtain:
</p>
<pre><code>(lldb) frame variable a_pair
(pair) a_pair = (1, 2)</code></pre>
<p>
	which is of course the same as typing
</p>
<pre><code>(lldb) type summary add pair --summary-string "(${var.first}, ${var.second})"</code></pre>
	<H3><a name="HEAD_79b8768d" href="#TOC_HEAD_79b8768d">2.4.6. Bitfields And Array Syntax</a></H3>
<p>
	Sometimes, a basic type&rsquo;s value actually represents several different values packed together in a bitfield.
</p>
<p>
	With the classical view, there is no way to look at them. Hexadecimal display can help, but if the bits actually span nibble boundaries, the help is limited.
</p>
<p>
	Binary view would show it all without ambiguity, but is often too detailed and hard to read for real&ndash;life scenarios.
</p>
<p>
	To cope with the issue, LLDB supports native bitfield formatting in summary strings. If your expression paths leads to a so&ndash;called scalar type (the usual int, float, char, double, short, long, long long, double, long double and unsigned variants), you can ask LLDB to only grab some bits out of the value and display them in any format you like. If you only need one bit you can use the [n], just like indexing an array. To extract multiple bits, you can use a slice&ndash;like syntax: [n&ndash;m], e.g.
</p>
<pre><code>(lldb) frame variable float_point
(float) float_point = -3.14159

(lldb) type summary add --summary-string "Sign: ${var[31]%B} Exponent: ${var[30-23]%x} Mantissa: ${var[0-22]%u}" float
(lldb) frame variable float_point
(float) float_point = -3.14159 Sign: true Exponent: 0x00000080 Mantissa: 4788184</code></pre>
<p>
	In this example, LLDB shows the internal representation of a float variable by extracting bitfields out of a float object.
</p>
<p>
	When typing a range, the extremes n and m are always included, and the order of the indices is irrelevant.
</p>
<p>
	LLDB also allows to use a similar syntax to display array members inside a summary string. For instance, you may want to display all arrays of a given type using a more compact notation than the default, and then just delve into individual array members that prove interesting to your debugging task. You can tell LLDB to format arrays in special ways, possibly independent of the way the array members&rsquo; datatype is formatted. e.g.
</p>
<pre><code>(lldb) frame variable sarray
(Simple [3]) sarray = {
[0] = {
    x = 1
    y = 2
    z = '\x03'
}
[1] = {
    x = 4
    y = 5
    z = '\x06'
}
[2] = {
    x = 7
    y = 8
    z = '\t'
}
}

(lldb) type summary add --summary-string "${var[].x}" "Simple [3]"

(lldb) frame variable sarray
(Simple [3]) sarray = [1,4,7]</code></pre>
<p>
	The [] symbol amounts to: if var is an array and I know its size, apply this summary string to every element of the array. Here, we are asking LLDB to display .x for every element of the array, and in fact this is what happens. If you find some of those integers anomalous, you can then inspect that one item in greater detail, without the array format getting in the way:
</p>
<pre><code>(lldb) frame variable sarray[1]
(Simple) sarray[1] = {
x = 4
y = 5
z = '\x06'
}</code></pre>
<p>
	You can also ask LLDB to only print a subset of the array range by using the same syntax used to extract bit for bitfields:
</p>
<pre><code>(lldb) type summary add --summary-string "${var[1-2].x}" "Simple [3]"

(lldb) frame variable sarray
(Simple [3]) sarray = [4,7]</code></pre>
<p>
	If you are dealing with a pointer that you know is an array, you can use this syntax to display the elements contained in the pointed array instead of just the pointer value. However, because pointers have no notion of their size, the empty brackets [] operator does not work, and you must explicitly provide higher and lower bounds.
</p>
<p>
	In general, LLDB needs the square brackets operator [] in order to handle arrays and pointers correctly, and for pointers it also needs a range. However, a few special cases are defined to make your life easier:
</p>
<p>
	you can print a 0&ndash;terminated string (C&ndash;string) using the %s format, omitting square brackets, as in:
</p>
<pre><code>(lldb) type summary add --summary-string "${var%s}" "char *"</code></pre>
<p>
	This syntax works for char* as well as for char[] because LLDB can rely on the final 0 terminator to know when the string has ended.
</p>
<p>
	LLDB has default summary strings for char* and char[] that use this special case. On debugger startup, the following are defined automatically:
</p>
<pre><code>(lldb) type summary add --summary-string "${var%s}" "char *"
(lldb) type summary add --summary-string "${var%s}" -x "char \[[0-9]+]"</code></pre>
<p>
	any of the array formats (int8_t[], float32{}, &hellip;), and the y, Y and a formats work to print an array of a non&ndash;aggregate type, even if square brackets are omitted.
</p>
<pre><code>(lldb) type summary add --summary-string "${var%int32_t[]}" "int [10]"</code></pre>
<p>
	This feature, however, is not enabled for pointers because there is no way for LLDB to detect the end of the pointed data.
</p>
<p>
	This also does not work for other formats (e.g. boolean), and you must specify the square brackets operator to get the expected output.
</p>
	<H3><a name="HEAD_93d664f3" href="#TOC_HEAD_93d664f3">2.4.7. Python Scripting</a></H3>
<p>
	Most of the times, summary strings prove good enough for the job of summarizing the contents of a variable. However, as soon as you need to do more than picking some values and rearranging them for display, summary strings stop being an effective tool. This is because summary strings lack the power to actually perform any kind of computation on the value of variables.
</p>
<p>
	To solve this issue, you can bind some Python scripting code as a summary for your datatype, and that script has the ability to both extract children variables as the summary strings do and to perform active computation on the extracted values. As a small example, let&rsquo;s say we have a Rectangle class:
</p>
<pre><code>class Rectangle
{
private:
int height;
int width;
public:
Rectangle() : height(3), width(5) {}
Rectangle(int H) : height(H), width(H*2-1) {}
Rectangle(int H, int W) : height(H), width(W) {}
int GetHeight() { return height; }
int GetWidth() { return width; }
};</code></pre>
<p>
	Summary strings are effective to reduce the screen real estate used by the default viewing mode, but are not effective if we want to display the area and perimeter of Rectangle objects
</p>
<p>
	To obtain this, we can simply attach a small Python script to the Rectangle class, as shown in this example:
</p>
<pre><code>(lldb) type summary add -P Rectangle
Enter your Python command(s). Type 'DONE' to end.
def function (valobj,internal_dict,options):
height_val = valobj.GetChildMemberWithName('height')
width_val = valobj.GetChildMemberWithName('width')
height = height_val.GetValueAsUnsigned(0)
width = width_val.GetValueAsUnsigned(0)
area = height*width
perimeter = 2*(height + width)
return 'Area: ' + str(area) + ', Perimeter: ' + str(perimeter)
DONE
(lldb) frame variable
(Rectangle) r1 = Area: 20, Perimeter: 18
(Rectangle) r2 = Area: 72, Perimeter: 36
(Rectangle) r3 = Area: 16, Perimeter: 16</code></pre>
<p>
	In order to write effective summary scripts, you need to know the LLDB public API, which is the way Python code can access the LLDB object model. For further details on the API you should look at the LLDB API reference documentation.
</p>
<p>
	As a brief introduction, your script is encapsulated into a function that is passed two parameters: valobj and internal_dict.
</p>
<p>
	internal_dict is an internal support parameter used by LLDB and you should not touch it.
</p>
<p>
	valobj is the object encapsulating the actual variable being displayed, and its type is SBValue. Out of the many possible operations on an SBValue, the basic one is retrieve the children objects it contains (essentially, the fields of the object wrapped by it), by calling GetChildMemberWithName(), passing it the child&rsquo;s name as a string.
</p>
<p>
	If the variable has a value, you can ask for it, and return it as a string using GetValue(), or as a signed/unsigned number using GetValueAsSigned(), GetValueAsUnsigned(). It is also possible to retrieve an SBData object by calling GetData() and then read the object&rsquo;s contents out of the SBData.
</p>
<p>
	If you need to delve into several levels of hierarchy, as you can do with summary strings, you can use the method GetValueForExpressionPath(), passing it an expression path just like those you could use for summary strings (one of the differences is that dereferencing a pointer does not occur by prefixing the path with a *`, but by calling the Dereference() method on the returned SBValue). If you need to access array slices, you cannot do that (yet) via this method call, and you must use GetChildAtIndex() querying it for the array items one by one. Also, handling custom formats is something you have to deal with on your own.
</p>
<p>
	options Python summary formatters can optionally define this third argument, which is an object of type lldb.SBTypeSummaryOptions, allowing for a few customizations of the result. The decision to adopt or not this third argument &ndash; and the meaning of options thereof &ndash; is up to the individual formatter&rsquo;s writer.
</p>
<p>
	Other than interactively typing a Python script there are two other ways for you to input a Python script as a summary:
</p>
<ul>
	<li>using the –python&ndash;script option to type summary add and typing the script code as an option argument; as in:</li>
	<br />
	<pre><code>(lldb) type summary add --python-script "height = valobj.GetChildMemberWithName('height').GetValueAsUnsigned(0);width = valobj.GetChildMemberWithName('width').GetValueAsUnsigned(0); return 'Area: %d' % (height*width)" Rectangle	</code></pre>
	<li>using the –python&ndash;function (&ndash;F) option to type summary add and giving the name of a Python function with the correct prototype. Most probably, you will define (or have already defined) the function in the interactive interpreter, or somehow loaded it from a file, using the command script import command. LLDB will emit a warning if it is unable to find the function you passed, but will still register the binding.</li>
	<br />
</ul>
	<H3><a name="HEAD_a9af26ea" href="#TOC_HEAD_a9af26ea">2.4.8. Regular Expression Typenames</a></H3>
<p>
	As you noticed, in order to associate the custom summary string to the array types, one must give the array size as part of the typename. This can long become tiresome when using arrays of different sizes, Simple [3], Simple [9], Simple [12], &hellip;
</p>
<p>
	If you use the &ndash;x option, type names are treated as regular expressions instead of type names. This would let you rephrase the above example for arrays of type Simple [3] as:
</p>
<pre><code>(lldb) type summary add --summary-string "${var[].x}" -x "Simple \[[0-9]+\]"
(lldb) frame variable
(Simple [3]) sarray = [1,4,7]
(Simple [2]) sother = [3,6]</code></pre>
<p>
	The above scenario works for Simple [3] as well as for any other array of Simple objects.
</p>
<p>
	While this feature is mostly useful for arrays, you could also use regular expressions to catch other type sets grouped by name. However, as regular expression matching is slower than normal name matching, LLDB will first try to match by name in any way it can, and only when this fails, will it resort to regular expression matching.
</p>
<p>
	One of the ways LLDB uses this feature internally, is to match the names of STL container classes, regardless of the template arguments provided. The details for this are found at FormatManager.cpp
</p>
<p>
	The regular expression language used by LLDB is the POSIX extended language, as defined by the Single UNIX Specification, of which macOS is a compliant implementation.
</p>
	<H3><a name="HEAD_ca5b7fac" href="#TOC_HEAD_ca5b7fac">2.4.9. Names Summaries</a></H3>
<p>
	For a given type, there may be different meaningful summary representations. However, currently, only one summary can be associated to a type at each moment. If you need to temporarily override the association for a variable, without changing the summary string for to its type, you can use named summaries.
</p>
<p>
	Named summaries work by attaching a name to a summary when creating it. Then, when there is a need to attach the summary to a variable, the frame variable command, supports a –summary option that tells LLDB to use the named summary given instead of the default one.
</p>
<pre><code>(lldb) type summary add --summary-string "x=${var.integer}" --name NamedSummary
(lldb) frame variable one
(i_am_cool) one = int = 3, float = 3.14159, char = 69
(lldb) frame variable one --summary NamedSummary
(i_am_cool) one = x=3</code></pre>
<p>
	When defining a named summary, binding it to one or more types becomes optional. Even if you bind the named summary to a type, and later change the summary string for that type, the named summary will not be changed by that. You can delete named summaries by using the type summary delete command, as if the summary name was the datatype that the summary is applied to
</p>
<p>
	A summary attached to a variable using the –summary option, has the same semantics that a custom format attached using the &ndash;f option has: it stays attached till you attach a new one, or till you let your program run again.
</p>
	<H3><a name="HEAD_5180d4ba" href="#TOC_HEAD_5180d4ba">2.4.10. Synthetic Children</a></H3>
<p>
	Summaries work well when one is able to navigate through an expression path. In order for LLDB to do so, appropriate debugging information must be available.
</p>
<p>
	Some types are opaque, i.e. no knowledge of their internals is provided. When that&rsquo;s the case, expression paths do not work correctly.
</p>
<p>
	In other cases, the internals are available to use in expression paths, but they do not provide a user&ndash;friendly representation of the object&rsquo;s value.
</p>
<p>
	For instance, consider an STL vector, as implemented by the GNU C++ Library:
</p>
<pre><code>(lldb) frame variable numbers -T
(std::vector&lt;int&gt;) numbers = {
(std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;) std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt; = {
    (std::_Vector_base&lt;int, std::allocator&tl;int&gt; &gt;::_Vector_impl) _M_impl = {
            (int *) _M_start = 0x00000001001008a0
            (int *) _M_finish = 0x00000001001008a8
            (int *) _M_end_of_storage = 0x00000001001008a8
    }
}
}</code></pre>
<p>
	Here, you can see how the type is implemented, and you can write a summary for that implementation but that is not going to help you infer what items are actually stored in the vector.
</p>
<p>
	What you would like to see is probably something like:
</p>
<pre><code>(lldb) frame variable numbers -T
(std::vector&lt;int&gt;) numbers = {
(int) [0] = 1
(int) [1] = 12
(int) [2] = 123
(int) [3] = 1234
}</code></pre>
<p>
	Synthetic children are a way to get that result.
</p>
<p>
	The feature is based upon the idea of providing a new set of children for a variable that replaces the ones available by default through the debug information. In the example, we can use synthetic children to provide the vector items as children for the std::vector object.
</p>
<p>
	In order to create synthetic children, you need to provide a Python class that adheres to a given interface (the word is italicized because Python has no explicit notion of interface, by that word we mean a given set of methods must be implemented by the Python class):
</p>
<pre><code>class SyntheticChildrenProvider:
def __init__(self, valobj, internal_dict):
    this call should initialize the Python object using valobj as the variable to provide synthetic children for
def num_children(self):
    this call should return the number of children that you want your object to have
def get_child_index(self,name):
    this call should return the index of the synthetic child whose name is given as argument
def get_child_at_index(self,index):
    this call should return a new LLDB SBValue object representing the child at the index given as argument
def update(self):
    this call should be used to update the internal state of this Python object whenever the state of the variables in LLDB changes.[1]
    Also, this method is invoked before any other method in the interface.
def has_children(self):
    this call should return True if this object might have children, and False if this object can be guaranteed not to have children.[2]
def get_value(self):
    this call can return an SBValue to be presented as the value of the synthetic value under consideration.[3]</code></pre>
<p>
	As a warning, exceptions that are thrown by python formatters are caught silently by LLDB and should be handled appropriately by the formatter itself. Being more specific, in case of exceptions, LLDB might assume that the given object has no children or it might skip printing some children, as they are printed one by one.
</p>
<p>
	[1] This method is optional. Also, a boolean value must be returned (since lldb 3.1.0). If False is returned, then whenever the process reaches a new stop, this method will be invoked again to generate an updated list of the children for a given variable. Otherwise, if True is returned, then the value is cached and this method won&rsquo;t be called again, effectively freezing the state of the value in subsequent stops. Beware that returning True incorrectly could show misleading information to the user.
</p>
<p>
	[2] This method is optional (since lldb 3.2.0). While implementing it in terms of num_children is acceptable, implementors are encouraged to look for optimized coding alternatives whenever reasonable.
</p>
<p>
	[3] This method is optional (since lldb 3.5.2). The SBValue you return here will most likely be a numeric type (int, float, &hellip;) as its value bytes will be used as&ndash;if they were the value of the root SBValue proper. As a shortcut for this, you can inherit from lldb.SBSyntheticValueProvider, and just define get_value as other methods are defaulted in the superclass as returning default no&ndash;children responses.
</p>
<p>
	If a synthetic child provider supplies a special child named $$dereference$$ then it will be used when evaluating operator * and operator &ndash;&gt; in the frame variable command and related SB API functions. It is possible to declare this synthetic child without including it in the range of children displayed by LLDB. For example, this subset of a synthetic children provider class would allow the synthetic value to be dereferenced without actually showing any synthetic children in the UI:
</p>
<pre><code>class SyntheticChildrenProvider:
    [...]
    def num_children(self):
        return 0
    def get_child_index(self, name):
        if name == '$$dereference$$':
            return 0
        return -1
    def get_child_at_index(self, index):
        if index == 0:
            return &lt;valobj resulting from dereference&gt;
        return None</code></pre>
<p>
	For examples of how synthetic children are created, you are encouraged to look at examples/synthetic in the LLDB trunk. Please, be aware that the code in those files (except bitfield/) is legacy code and is not maintained. You may especially want to begin looking at this example to get a feel for this feature, as it is a very easy and well commented example.
</p>
<p>
	The design pattern consistently used in synthetic providers shipping with LLDB is to use the <strong>init</strong> to store the SBValue instance as a part of self. The update function is then used to perform the actual initialization. Once a synthetic children provider is written, one must load it into LLDB before it can be used. Currently, one can use the LLDB script command to type Python code interactively, or use the command script import fileName command to load Python code from a Python module (ordinary rules apply to importing modules this way). A third option is to type the code for the provider class interactively while adding it.
</p>
<p>
	For example, let&rsquo;s pretend we have a class Foo for which a synthetic children provider class Foo_Provider is available, in a Python module contained in file &tilde;/Foo_Tools.py. The following interaction sets Foo_Provider as a synthetic children provider in LLDB:
</p>
<pre><code>(lldb) command script import ~/Foo_Tools.py
(lldb) type synthetic add Foo --python-class Foo_Tools.Foo_Provider
(lldb) frame variable a_foo
(Foo) a_foo = {
x = 1
y = "Hello world"
}</code></pre>
<p>
	LLDB has synthetic children providers for a core subset of STL classes, both in the version provided by libstdcpp and by libcxx, as well as for several Foundation classes.
</p>
<p>
	Synthetic children extend summary strings by enabling a new special variable: ${svar.
</p>
<p>
	This symbol tells LLDB to refer expression paths to the synthetic children instead of the real ones. For instance,
</p>
<pre><code>(lldb) type summary add --expand -x "std::vector&lt;" --summary-string "${svar%#} items"
(lldb) frame variable numbers
(std::vector&lt;int&gt;) numbers = 4 items {
(int) [0] = 1
(int) [1] = 12
(int) [2] = 123
(int) [3] = 1234
}</code></pre>
<p>
	It&rsquo;s important to mention that LLDB invokes the synthetic child provider before invoking the summary string provider, which allows the latter to have access to the actual displayable children. This applies to both inlined summary strings and python&ndash;based summary providers.
</p>
<p>
	As a warning, when programmatically accessing the children or children count of a variable that has a synthetic child provider, notice that LLDB hides the actual raw children. For example, suppose we have a std::vector, which has an actual in&ndash;memory property __begin marking the beginning of its data. After the synthetic child provider is executed, the std::vector variable won&rsquo;t show __begin as child anymore, even through the SB API. It will have instead the children calculated by the provider. In case the actual raw children are needed, a call to value.GetNonSyntheticValue() is enough to get a raw version of the value. It is import to remember this when implementing summary string providers, as they run after the synthetic child provider.
</p>
<p>
	In some cases, if LLDB is unable to use the real object to get a child specified in an expression path, it will automatically refer to the synthetic children. While in summaries it is best to always use ${svar to make your intentions clearer, interactive debugging can benefit from this behavior, as in:
</p>
<pre><code>(lldb) frame variable numbers[0] numbers[1]
(int) numbers[0] = 1
(int) numbers[1] = 12</code></pre>
<p>
	Unlike many other visualization features, however, the access to synthetic children only works when using frame variable, and is not supported in expression:
</p>
<pre><code>(lldb) expression numbers[0]
Error [IRForTarget]: Call to a function '_ZNSt33vector&lt;int, std::allocator&lt;int&gt; &gt;ixEm' that is not present in the target
error: Couldn't convert the expression to DWARF</code></pre>
<p>
	The reason for this is that classes might have an overloaded operator [], or other special provisions and the expression command chooses to ignore synthetic children in the interest of equivalency with code you asked to have compiled from source.
</p>
	<H3><a name="HEAD_30493bdb" href="#TOC_HEAD_30493bdb">2.4.11. Filters</a></H3>
<p>
	Filters are a solution to the display of complex classes. At times, classes have many member variables but not all of these are actually necessary for the user to see.
</p>
<p>
	A filter will solve this issue by only letting the user see those member variables they care about. Of course, the equivalent of a filter can be implemented easily using synthetic children, but a filter lets you get the job done without having to write Python code.
</p>
<p>
	For instance, if your class Foobar has member variables named A thru Z, but you only need to see the ones named B, H and Q, you can define a filter:
</p>
<pre><code>(lldb) type filter add Foobar --child B --child H --child Q
(lldb) frame variable a_foobar
(Foobar) a_foobar = {
(int) B = 1
(char) H = 'H'
(std::string) Q = "Hello world"
}</code></pre>
	<H3><a name="HEAD_7d609f0e" href="#TOC_HEAD_7d609f0e">2.4.12. Callback&ndash;based type matching</a></H3>
<p>
	Even though regular expression matching works well for the vast majority of data formatters (you normally know the name of the type you&rsquo;re writing a formatter for), there are some cases where it&rsquo;s useful to look at the type before deciding what formatter to apply.
</p>
<p>
	As an example scenario, imagine we have a code generator that produces some classes that inherit from a common GeneratedObject class, and we have a summary function and a synthetic child provider that work for all GeneratedObject instances (they all follow the same pattern). However, there is no common pattern in the name of these classes, so we can&rsquo;t register the formatter neither by name nor by regular expression.
</p>
<p>
	In that case, you can write a recognizer function like this:
</p>
<pre><code>def is_generated_object(sbtype, internal_dict):
for base in sbtype.get_bases_array():
    if base.GetName() == "GeneratedObject"
    return True
return False</code></pre>
<p>
	And pass this function to type summary add and type synthetic add using the flag &ndash;&ndash;recognizer&ndash;function.
</p>
<pre><code>(lldb) type summary add --expand --python-function my_summary_function --recognizer-function is_generated_object
(lldb) type synthetic add --python-class my_child_provider --recognizer-function is_generated_object</code></pre>
	<H3><a name="HEAD_5cb78d1c" href="#TOC_HEAD_5cb78d1c">2.4.13. Objective&ndash;C Dynamic Type Discovery</a></H3>
<p>
	When doing Objective&ndash;C development, you may notice that some of your variables come out as of type id (for instance, items extracted from NSArray). By default, LLDB will not show you the real type of the object. it can actually dynamically discover the type of an Objective&ndash;C variable, much like the runtime itself does when invoking a selector. In order to be shown the result of that discovery that, however, a special option to frame variable or expression is required: &ndash;&ndash;dynamic&ndash;type.
</p>
<p>
	&ndash;&ndash;dynamic&ndash;type can have one of three values:
</p>
<ul>
	<li>no&ndash;dynamic&ndash;values: the default, prevents dynamic type discovery</li>
	<li>no&ndash;run&ndash;target: enables dynamic type discovery as long as running code on the target is not required</li>
	<li>run&ndash;target: enables code execution on the target in order to perform dynamic type discovery</li>
	<br />
</ul>
<p>
	If you specify a value of either no&ndash;run&ndash;target or run&ndash;target, LLDB will detect the dynamic type of your variables and show the appropriate formatters for them. As an example:
</p>
<pre><code>(lldb) expr @"Hello"
(NSString *) $0 = 0x00000001048000b0 @"Hello"
(lldb) expr -d no-run @"Hello"
(__NSCFString *) $1 = 0x00000001048000b0 @"Hello"</code></pre>
<p>
	Because LLDB uses a detection algorithm that does not need to invoke any functions on the target process, no&ndash;run&ndash;target is enough for this to work.
</p>
<p>
	As a side note, the summary for NSString shown in the example is built right into LLDB. It was initially implemented through Python (the code is still available for reference at CFString.py). However, this is out of sync with the current implementation of the NSString formatter (which is a C++ function compiled into the LLDB core).
</p>
	<H3><a name="HEAD_c419223c" href="#TOC_HEAD_c419223c">2.4.14. Categories</a></H3>
<p>
	Categories are a way to group related formatters. For instance, LLDB itself groups the formatters for the libstdc++ types in a category named gnu&ndash;libstdc++. Basically, categories act like containers in which to store formatters for a same library or OS release.
</p>
<p>
	By default, several categories are created in LLDB:
</p>
<ul>
	<li>default: this is the category where every formatter ends up, unless another category is specified</li>
	<li>objc: formatters for basic and common Objective&ndash;C types that do not specifically depend on macOS</li>
	<li>gnu&ndash;libstdc++: formatters for std::string, std::vector, std::list and std::map as implemented by libstdcpp</li>
	<li>libcxx: formatters for std::string, std::vector, std::list and std::map as implemented by libcxx</li>
	<li>system: truly basic types for which a formatter is required</li>
	<li>AppKit: Cocoa classes</li>
	<li>CoreFoundation: CF classes</li>
	<li>CoreGraphics: CG classes</li>
	<li>CoreServices: CS classes</li>
	<li>VectorTypes: compact display for several vector types</li>
	<br />
</ul>
<p>
	If you want to use a custom category for your formatters, all the type &hellip; add provide a –category (&ndash;w) option, that names the category to add the formatter to. To delete the formatter, you then have to specify the correct category.
</p>
<p>
	Categories can be in one of two states: enabled and disabled. A category is initially disabled, and can be enabled using the type category enable command. To disable an enabled category, the command to use is type category disable.
</p>
<p>
	The order in which categories are enabled or disabled is significant, in that LLDB uses that order when looking for formatters. Therefore, when you enable a category, it becomes the second one to be searched (after default, which always stays on top of the list). The default categories are enabled in such a way that the search order is:
</p>
<ul>
	<li>default</li>
	<li>objc</li>
	<li>CoreFoundation</li>
	<li>AppKit</li>
	<li>CoreServices</li>
	<li>CoreGraphics</li>
	<li>gnu&ndash;libstdc++</li>
	<li>libcxx</li>
	<li>VectorTypes</li>
	<li>system</li>
	<br />
</ul>
<p>
	As said, gnu&ndash;libstdc++ and libcxx contain formatters for C++ STL data types. system contains formatters for char* and char[], which reflect the behavior of older versions of LLDB which had built&ndash;in formatters for these types. Because now these are formatters, you can even replace them with your own if so you wish.
</p>
<p>
	There is no special command to create a category. When you place a formatter in a category, if that category does not exist, it is automatically created. For instance,
</p>
<pre><code>(lldb) type summary add Foobar --summary-string "a foobar" --category newcategory</code></pre>
<p>
	automatically creates a (disabled) category named newcategory.
</p>
<p>
	Another way to create a new (empty) category, is to enable it, as in:
</p>
<pre><code>(lldb) type category enable newcategory</code></pre>
<p>
	However, in this case LLDB warns you that enabling an empty category has no effect. If you add formatters to the category after enabling it, they will be honored. But an empty category per se does not change the way any type is displayed. The reason the debugger warns you is that enabling an empty category might be a typo, and you effectively wanted to enable a similarly&ndash;named but not&ndash;empty category.
</p>
	<H3><a name="HEAD_8fe797f2" href="#TOC_HEAD_8fe797f2">2.4.15. Finding Formatters 101</a></H3>
<p>
	Searching for a formatter (including formats, since lldb 3.4.0) given a variable goes through a rather intricate set of rules. Namely, what happens is that LLDB starts looking in each enabled category, according to the order in which they were enabled (latest enabled first). In each category, LLDB does the following:
</p>
<ul>
	<li>If there is a formatter for the type of the variable, use it</li>
	<li>If this object is a pointer, and there is a formatter for the pointee type that does not skip pointers, use it</li>
	<li>If this object is a reference, and there is a formatter for the referred type that does not skip references, use it</li>
	<li>If this object is an Objective&ndash;C class and dynamic types are enabled, look for a formatter for the dynamic type of the object. If dynamic types are disabled, or the search failed, look for a formatter for the declared type of the object</li>
	<li>If this object&rsquo;s type is a typedef, go through typedef hierarchy (LLDB might not be able to do this if the compiler has not emitted enough information. If the required information to traverse typedef hierarchies is missing, type cascading will not work. The clang compiler, part of the LLVM project, emits the correct debugging information for LLDB to cascade). If at any level of the hierarchy there is a valid formatter that can cascade, use it.</li>
	<li>If everything has failed, repeat the above search, looking for regular expressions instead of exact matches</li>
	<br />
</ul>
<p>
	If any of those attempts returned a valid formatter to be used, that one is used, and the search is terminated (without going to look in other categories). If nothing was found in the current category, the next enabled category is scanned according to the same algorithm. If there are no more enabled categories, the search has failed.
</p>
<p>
	Warning: previous versions of LLDB defined cascading to mean not only going through typedef chains, but also through inheritance chains. This feature has been removed since it significantly degrades performance. You need to set up your formatters for every type in inheritance chains to which you want the formatter to apply.
</p>
	<H2><a name="HEAD_5e860d63" href="#TOC_HEAD_5e860d63">2.5. Symbolication</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_51d917b5" href="#HEAD_51d917b5">2.5.1. Defining Load Addresses for Sections</a></li>
	<li><a name="TOC_HEAD_3a7adbdd" href="#HEAD_3a7adbdd">2.5.2. Loading Multiple Executables</a></li>
	<li><a name="TOC_HEAD_813c6504" href="#HEAD_813c6504">2.5.3. Getting Variable Information</a></li>
	<li><a name="TOC_HEAD_ef57e29" href="#HEAD_ef57e29">2.5.4. Using Python API to Symbolicate</a></li>
	<li><a name="TOC_HEAD_7e269861" href="#HEAD_7e269861">2.5.5. Use Builtin Python Module to Symbolicate</a></li>
	<menu>
		<li><a name="TOC_HEAD_5679c0fc" href="#HEAD_5679c0fc">2.5.5.1. lldb.utils.symbolication.Address</a></li>
		<li><a name="TOC_HEAD_1051a3ed" href="#HEAD_1051a3ed">2.5.5.2. lldb.utils.symbolication.Section</a></li>
		<li><a name="TOC_HEAD_2fb27063" href="#HEAD_2fb27063">2.5.5.3. lldb.utils.symbolication.Image</a></li>
		<li><a name="TOC_HEAD_c2426d00" href="#HEAD_c2426d00">2.5.5.4. lldb.utils.symbolication.Symbolicator</a></li>
		<li><a name="TOC_HEAD_88a446b6" href="#HEAD_88a446b6">2.5.5.5. lldb.macosx.crashlog</a></li>
	</menu>
</menu>

</div>
<p>
	LLDB is separated into a shared library that contains the core of the debugger, and a driver that implements debugging and a command interpreter. LLDB can be used to symbolicate your crash logs and can often provide more information than other symbolication programs:
</p>
<ul>
	<li>Inlined functions</li>
	<li>Variables that are in scope for an address, along with their locations</li>
	<br />
</ul>
<p>
	The simplest form of symbolication is to load an executable:
</p>
<pre><code>(lldb) target create --no-dependents --arch x86_64 /tmp/a.out</code></pre>
<p>
	We use the &ndash;&ndash;no&ndash;dependents flag with the target create command so that we don&rsquo;t load all of the dependent shared libraries from the current system. When we symbolicate, we are often symbolicating a binary that was running on another system, and even though the main executable might reference shared libraries in /usr/lib, we often don&rsquo;t want to load the versions on the current computer.
</p>
<p>
	Using the image list command will show us a list of all shared libraries associated with the current target. As expected, we currently only have a single binary:
</p>
<pre><code>(lldb) image list
[  0] 73431214-6B76-3489-9557-5075F03E36B4 0x0000000100000000 /tmp/a.out
    /tmp/a.out.dSYM/Contents/Resources/DWARF/a.out</code></pre>
<p>
	Now we can look up an address:
</p>
<pre><code>(lldb) image lookup --address 0x100000aa3
    Address: a.out[0x0000000100000aa3] (a.out.__TEXT.__text + 131)
    Summary: a.out`main + 67 at main.c:13</code></pre>
<p>
	Since we haven&rsquo;t specified a slide or any load addresses for individual sections in the binary, the address that we use here is a file address. A file address refers to a virtual address as defined by each object file.
</p>
<p>
	If we didn&rsquo;t use the &ndash;&ndash;no&ndash;dependents option with target create, we would have loaded all dependent shared libraries:
</p>
<pre><code>(lldb) image list
[  0] 73431214-6B76-3489-9557-5075F03E36B4 0x0000000100000000 /tmp/a.out
    /tmp/a.out.dSYM/Contents/Resources/DWARF/a.out
[  1] 8CBCF9B9-EBB7-365E-A3FF-2F3850763C6B 0x0000000000000000 /usr/lib/system/libsystem_c.dylib
[  2] 62AA0B84-188A-348B-8F9E-3E2DB08DB93C 0x0000000000000000 /usr/lib/system/libsystem_dnssd.dylib
[  3] C0535565-35D1-31A7-A744-63D9F10F12A4 0x0000000000000000 /usr/lib/system/libsystem_kernel.dylib
...</code></pre>
<p>
	Now if we do a lookup using a file address, this can result in multiple matches since most shared libraries have a virtual address space that starts at zero:
</p>
<pre><code>(lldb) image lookup -a 0x1000
    Address: a.out[0x0000000000001000] (a.out.__PAGEZERO + 4096)

    Address: libsystem_c.dylib[0x0000000000001000] (libsystem_c.dylib.__TEXT.__text + 928)
    Summary: libsystem_c.dylib`mcount + 9

    Address: libsystem_dnssd.dylib[0x0000000000001000] (libsystem_dnssd.dylib.__TEXT.__text + 456)
    Summary: libsystem_dnssd.dylib`ConvertHeaderBytes + 38

    Address: libsystem_kernel.dylib[0x0000000000001000] (libsystem_kernel.dylib.__TEXT.__text + 1116)
    Summary: libsystem_kernel.dylib`clock_get_time + 102
...</code></pre>
<p>
	To avoid getting multiple file address matches, you can specify the name of the shared library to limit the search:
</p>
<pre><code>(lldb) image lookup -a 0x1000 a.out
    Address: a.out[0x0000000000001000] (a.out.__PAGEZERO + 4096)</code></pre>
	<H3><a name="HEAD_51d917b5" href="#TOC_HEAD_51d917b5">2.5.1. Defining Load Addresses for Sections</a></H3>
<p>
	When symbolicating your crash logs, it can be tedious if you always have to adjust your crashlog&ndash;addresses into file addresses. To avoid having to do any conversion, you can set the load address for the sections of the modules in your target. Once you set any section load address, lookups will switch to using load addresses. You can slide all sections in the executable by the same amount, or set the load address for individual sections. The target modules load &ndash;&ndash;slide command allows us to set the load address for all sections.
</p>
<p>
	Below is an example of sliding all sections in a.out by adding 0x123000 to each section&rsquo;s file address:
</p>
<pre><code>(lldb) target create --no-dependents --arch x86_64 /tmp/a.out
(lldb) target modules load --file a.out --slide 0x123000</code></pre>
<p>
	It is often much easier to specify the actual load location of each section by name. Crash logs on macOS have a Binary Images section that specifies that address of the __TEXT segment for each binary. Specifying a slide requires requires that you first find the original (file) address for the __TEXT segment, and subtract the two values. If you specify the address of the __TEXT segment with target modules load section address, you don&rsquo;t need to do any calculations. To specify the load addresses of sections we can specify one or more section name + address pairs in the target modules load command:
</p>
<pre><code>(lldb) target create --no-dependents --arch x86_64 /tmp/a.out
(lldb) target modules load --file a.out __TEXT 0x100123000</code></pre>
<p>
	We specified that the __TEXT section is loaded at 0x100123000. Now that we have defined where sections have been loaded in our target, any lookups we do will now use load addresses so we don&rsquo;t have to do any math on the addresses in the crashlog backtraces, we can just use the raw addresses:
</p>
<pre><code>(lldb) image lookup --address 0x100123aa3
    Address: a.out[0x0000000100000aa3] (a.out.__TEXT.__text + 131)
    Summary: a.out`main + 67 at main.c:13</code></pre>
	<H3><a name="HEAD_3a7adbdd" href="#TOC_HEAD_3a7adbdd">2.5.2. Loading Multiple Executables</a></H3>
<p>
	You often have more than one executable involved when you need to symbolicate a crash log. When this happens, you create a target for the main executable or one of the shared libraries, then add more modules to the target using the target modules add command.
</p>
<p>
	Lets say we have a Darwin crash log that contains the following images:
</p>
<pre><code>Binary Images:
0x100000000 -    0x100000ff7 &lt;A866975B-CA1E-3649-98D0-6C5FAA444ECF&gt; /tmp/a.out
0x7fff83f32000 - 0x7fff83ffefe7 &lt;8CBCF9B9-EBB7-365E-A3FF-2F3850763C6B&gt; /usr/lib/system/libsystem_c.dylib
0x7fff883db000 - 0x7fff883e3ff7 &lt;62AA0B84-188A-348B-8F9E-3E2DB08DB93C&gt; /usr/lib/system/libsystem_dnssd.dylib
0x7fff8c0dc000 - 0x7fff8c0f7ff7 &lt;C0535565-35D1-31A7-A744-63D9F10F12A4&gt; /usr/lib/system/libsystem_kernel.dylib</code></pre>
<p>
	First we create the target using the main executable and then add any extra shared libraries we want:
</p>
<pre><code>(lldb) target create --no-dependents --arch x86_64 /tmp/a.out
(lldb) target modules add /usr/lib/system/libsystem_c.dylib
(lldb) target modules add /usr/lib/system/libsystem_dnssd.dylib
(lldb) target modules add /usr/lib/system/libsystem_kernel.dylib</code></pre>
<p>
	If you have debug symbols in standalone files, such as dSYM files on macOS, you can specify their paths using the –symfile option for the target create (recent LLDB releases only) and target modules add commands:
</p>
<pre><code>(lldb) target create --no-dependents --arch x86_64 /tmp/a.out --symfile /tmp/a.out.dSYM
(lldb) target modules add /usr/lib/system/libsystem_c.dylib --symfile /build/server/a/libsystem_c.dylib.dSYM
(lldb) target modules add /usr/lib/system/libsystem_dnssd.dylib --symfile /build/server/b/libsystem_dnssd.dylib.dSYM
(lldb) target modules add /usr/lib/system/libsystem_kernel.dylib --symfile /build/server/c/libsystem_kernel.dylib.dSYM</code></pre>
<p>
	Then we set the load addresses for each __TEXT section (note the colors of the load addresses above and below) using the first address from the Binary Images section for each image:
</p>
<pre><code>(lldb) target modules load --file a.out 0x100000000
(lldb) target modules load --file libsystem_c.dylib 0x7fff83f32000
(lldb) target modules load --file libsystem_dnssd.dylib 0x7fff883db000
(lldb) target modules load --file libsystem_kernel.dylib 0x7fff8c0dc000</code></pre>
<p>
	Now any stack backtraces that haven&rsquo;t been symbolicated can be symbolicated using image lookup with the raw backtrace addresses.
</p>
<p>
	Given the following raw backtrace:
</p>
<pre><code>Thread 0 Crashed:: Dispatch queue: com.apple.main-thread
0   libsystem_kernel.dylib           0x00007fff8a1e6d46 __kill + 10
1   libsystem_c.dylib                0x00007fff84597df0 abort + 177
2   libsystem_c.dylib                0x00007fff84598e2a __assert_rtn + 146
3   a.out                            0x0000000100000f46 main + 70
4   libdyld.dylib                    0x00007fff8c4197e1 start + 1</code></pre>
<p>
	We can now symbolicate the load addresses:
</p>
<pre><code>(lldb) image lookup -a 0x00007fff8a1e6d46
(lldb) image lookup -a 0x00007fff84597df0
(lldb) image lookup -a 0x00007fff84598e2a
(lldb) image lookup -a 0x0000000100000f46</code></pre>
	<H3><a name="HEAD_813c6504" href="#TOC_HEAD_813c6504">2.5.3. Getting Variable Information</a></H3>
<p>
	If you add the –verbose flag to the image lookup &ndash;&ndash;address command, you can get verbose information which can often include the locations of some of your local variables:
</p>
<pre><code>(lldb) image lookup --address 0x100123aa3 --verbose
    Address: a.out[0x0000000100000aa3] (a.out.__TEXT.__text + 110)
    Summary: a.out`main + 50 at main.c:13
    Module: file = "/tmp/a.out", arch = "x86_64"
CompileUnit: id = {0x00000000}, file = "/tmp/main.c", language = "ISO C:1999"
Function: id = {0x0000004f}, name = "main", range = [0x0000000100000bc0-0x0000000100000dc9)
FuncType: id = {0x0000004f}, decl = main.c:9, compiler_type = "int (int, const char **, const char **, const char **)"
    Blocks: id = {0x0000004f}, range = [0x100000bc0-0x100000dc9)
            id = {0x000000ae}, range = [0x100000bf2-0x100000dc4)
LineEntry: [0x0000000100000bf2-0x0000000100000bfa): /tmp/main.c:13:23
    Symbol: id = {0x00000004}, range = [0x0000000100000bc0-0x0000000100000dc9), name="main"
Variable: id = {0x000000bf}, name = "path", type= "char [1024]", location = DW_OP_fbreg(-1072), decl = main.c:28
Variable: id = {0x00000072}, name = "argc", type= "int", location = r13, decl = main.c:8
Variable: id = {0x00000081}, name = "argv", type= "const char **", location = r12, decl = main.c:8
Variable: id = {0x00000090}, name = "envp", type= "const char **", location = r15, decl = main.c:8
Variable: id = {0x0000009f}, name = "aapl", type= "const char **", location = rbx, decl = main.c:8</code></pre>
<p>
	The interesting part is the variables that are listed. The variables are the parameters and local variables that are in scope for the address that was specified. These variable entries have locations which are shown in bold above. Crash logs often have register information for the first frame in each stack, and being able to reconstruct one or more local variables can often help you decipher more information from a crash log than you normally would be able to. Note that this is really only useful for the first frame, and only if your crash logs have register information for your threads.
</p>
	<H3><a name="HEAD_ef57e29" href="#TOC_HEAD_ef57e29">2.5.4. Using Python API to Symbolicate</a></H3>
<p>
	All of the commands above can be done through the python script bridge. The code below will recreate the target and add the three shared libraries that we added in the darwin crash log example above:
</p>
<pre><code>triple = "x86_64-apple-macosx"
platform_name = None
add_dependents = False
target = lldb.debugger.CreateTarget("/tmp/a.out", triple, platform_name, add_dependents, lldb.SBError())
if target:
    # Get the executable module
    module = target.GetModuleAtIndex(0)
    target.SetSectionLoadAddress(module.FindSection("__TEXT"), 0x100000000)
    module = target.AddModule ("/usr/lib/system/libsystem_c.dylib", triple, None, "/build/server/a/libsystem_c.dylib.dSYM")
    target.SetSectionLoadAddress(module.FindSection("__TEXT"), 0x7fff83f32000)
    module = target.AddModule ("/usr/lib/system/libsystem_dnssd.dylib", triple, None, "/build/server/b/libsystem_dnssd.dylib.dSYM")
    target.SetSectionLoadAddress(module.FindSection("__TEXT"), 0x7fff883db000)
    module = target.AddModule ("/usr/lib/system/libsystem_kernel.dylib", triple, None, "/build/server/c/libsystem_kernel.dylib.dSYM")
    target.SetSectionLoadAddress(module.FindSection("__TEXT"), 0x7fff8c0dc000)

    load_addr = 0x00007fff8a1e6d46
    # so_addr is a section offset address, or a lldb.SBAddress object
    so_addr = target.ResolveLoadAddress (load_addr)
    # Get a symbol context for the section offset address which includes
    # a module, compile unit, function, block, line entry, and symbol
    sym_ctx = so_addr.GetSymbolContext (lldb.eSymbolContextEverything)
    print sym_ctx</code></pre>
	<H3><a name="HEAD_7e269861" href="#TOC_HEAD_7e269861">2.5.5. Use Builtin Python Module to Symbolicate</a></H3>
<p>
	LLDB includes a module in the lldb package named lldb.utils.symbolication. This module contains a lot of symbolication functions that simplify the symbolication process by allowing you to create objects that represent symbolication class objects such as:
</p>
<ul>
	<li>lldb.utils.symbolication.Address</li>
	<li>lldb.utils.symbolication.Section</li>
	<li>lldb.utils.symbolication.Image</li>
	<li>lldb.utils.symbolication.Symbolicator</li>
	<br />
</ul>
	<H4><a name="HEAD_5679c0fc" href="#TOC_HEAD_5679c0fc">2.5.5.1. lldb.utils.symbolication.Address</a></H4>
<p>
	This class represents an address that will be symbolicated. It will cache any information that has been looked up: module, compile unit, function, block, line entry, symbol. It does this by having a lldb.SBSymbolContext as a member variable.
</p>
	<H4><a name="HEAD_1051a3ed" href="#TOC_HEAD_1051a3ed">2.5.5.2. lldb.utils.symbolication.Section</a></H4>
<p>
	This class represents a section that might get loaded in a lldb.utils.symbolication.Image. It has helper functions that allow you to set it from text that might have been extracted from a crash log file.
</p>
	<H4><a name="HEAD_2fb27063" href="#TOC_HEAD_2fb27063">2.5.5.3. lldb.utils.symbolication.Image</a></H4>
<p>
	This class represents a module that might get loaded into the target we use for symbolication. This class contains the executable path, optional symbol file path, the triple, and the list of sections that will need to be loaded if we choose the ask the target to load this image. Many of these objects will never be loaded into the target unless they are needed by symbolication. You often have a crash log that has 100 to 200 different shared libraries loaded, but your crash log stack backtraces only use a few of these shared libraries. Only the images that contain stack backtrace addresses need to be loaded in the target in order to symbolicate.
</p>
<p>
	Subclasses of this class will want to override the locate_module_and_debug_symbols method:
</p>
<pre><code>class CustomImage(lldb.utils.symbolication.Image):
def locate_module_and_debug_symbols (self):
    # Locate the module and symbol given the info found in the crash log</code></pre>
<p>
	Overriding this function allows clients to find the correct executable module and symbol files as they might reside on a build server.
</p>
	<H4><a name="HEAD_c2426d00" href="#TOC_HEAD_c2426d00">2.5.5.4. lldb.utils.symbolication.Symbolicator</a></H4>
<p>
	This class coordinates the symbolication process by loading only the lldb.utils.symbolication.Image instances that need to be loaded in order to symbolicate an supplied address.
</p>
	<H4><a name="HEAD_88a446b6" href="#TOC_HEAD_88a446b6">2.5.5.5. lldb.macosx.crashlog</a></H4>
<p>
	lldb.macosx.crashlog is a package that is distributed on macOS builds that subclasses the above classes. This module parses the information in the Darwin crash logs and creates symbolication objects that represent the images, the sections and the thread frames for the backtraces. It then uses the functions in the lldb.utils.symbolication to symbolicate the crash logs.
</p>
<p>
	This module installs a new crashlog command into the lldb command interpreter so that you can use it to parse and symbolicate macOS crash logs:
</p>
<pre><code>(lldb) command script import lldb.macosx.crashlog
"crashlog" and "save_crashlog" command installed, use the "--help" option for detailed help
(lldb) crashlog /tmp/crash.log
...</code></pre>
<p>
	The command that is installed has built in help that shows the options that can be used when symbolicating:
</p>
<pre><code>(lldb) crashlog --help
Usage: crashlog [options]  [FILE ...]</code></pre>
<p>
	Symbolicate one or more darwin crash log files to provide source file and line information, inlined stack frames back to the concrete functions, and disassemble the location of the crash for the first frame of the crashed thread. If this script is imported into the LLDB command interpreter, a crashlog command will be added to the interpreter for use at the LLDB command line. After a crash log has been parsed and symbolicated, a target will have been created that has all of the shared libraries loaded at the load addresses found in the crash log file. This allows you to explore the program as if it were stopped at the locations described in the crash log and functions can be disassembled and lookups can be performed using the addresses found in the crash log.
</p>
<pre><code>Options:
-h, --help            show this help message and exit
-v, --verbose         display verbose debug info
-g, --debug           display verbose debug logging
-a, --load-all        load all executable images, not just the images found
                        in the crashed stack frames
--images              show image list
--debug-delay=NSEC    pause for NSEC seconds for debugger
-c, --crashed-only    only symbolicate the crashed thread
-d DISASSEMBLE_DEPTH, --disasm-depth=DISASSEMBLE_DEPTH
                        set the depth in stack frames that should be
                        disassembled (default is 1)
-D, --disasm-all      enabled disassembly of frames on all threads (not just
                        the crashed thread)
-B DISASSEMBLE_BEFORE, --disasm-before=DISASSEMBLE_BEFORE
                        the number of instructions to disassemble before the
                        frame PC
-A DISASSEMBLE_AFTER, --disasm-after=DISASSEMBLE_AFTER
                        the number of instructions to disassemble after the
                        frame PC
-C NLINES, --source-context=NLINES
                        show NLINES source lines of source context (default =
                        4)
--source-frames=NFRAMES
                        show source for NFRAMES (default = 4)
--source-all          show source for all threads, not just the crashed
                        thread
-i, --interactive     parse all crash logs and enter interactive mode</code></pre>
<p>
	The source for the &ldquo;symbolication&rdquo; and &ldquo;crashlog&rdquo; modules are available in git.
</p>
	<H2><a name="HEAD_82fde2b7" href="#TOC_HEAD_82fde2b7">2.6. Symbols on macOS</a> <a name="MARK_2" href="#TOC_MARK_2"><strong><font color="red">@TODO</font></strong></a></H2><ul></ul>
	<H2><a name="HEAD_3efdd467" href="#TOC_HEAD_3efdd467">2.7. DWARF Extensions supported by LLDB</a></H2><ul><a href="../tags/DWARF-Extension.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>DWARF-Extension</a>&nbsp;</ul>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_a595c3fd" href="#HEAD_a595c3fd">2.7.1. Clang &ndash;gmodules debug info</a></li>
	<li><a name="TOC_HEAD_e3f5a540" href="#HEAD_e3f5a540">2.7.2. Apple SDK information</a></li>
	<li><a name="TOC_HEAD_69ec6947" href="#HEAD_69ec6947">2.7.3. Objective&ndash;C runtime</a></li>
</menu>

</div>
<p>
	LLDB supports some DWARF extensions produced by Clang.
</p>
	<H3><a name="HEAD_a595c3fd" href="#TOC_HEAD_a595c3fd">2.7.1. Clang &ndash;gmodules debug info</a></H3>
<ul>
	<li><a name="HEAD_HIDDEN_7ff5fbcb">On <strong>Darwin</strong> platforms, including Apple macOS and iOS, Clang can emit DWARF debug info for types found in Clang modules more efficiently. &nbsp;<a href="../tags/Darwin.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Darwin</a>&nbsp;<a href="../tags/iOS-Debug.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>iOS-Debug</a></li>
	<br />
	<li><a name="HEAD_HIDDEN_c397a832">From an on&ndash;disk storage perspective, Clang modules are precompiled header files that contain serialized Clang ASTs of all the declarations found in a Clang module. In traditional DWARF debug info, two object files that were built from sources that imported the same header file will both contain DWARF debug type info for types in that header file. This can lead to a lot of redundant debug info. &nbsp;<a href="../tags/shrink-debug-data.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>shrink-debug-data</a></li>
	<br />
</ul>
<p>
	When Clang compiles a Clang module or precompiled header with the &ndash;gmodules option, the precompiled header (.pch) or module (.pcm) files become object file containers (on Darwin: Mach&ndash;O) that hold a <code>__clang_ast</code> section with the serialized Clang AST and various DWARF sections containing debug info for the type declarations found in the header or module.
</p>
<p>
	This allows Clang to omit these type definitions from the object (.o) files and replace them with forward declarations to save space. Type declarations in a Clang module are nested inside one DW_TAG_module, or – in the case of submodules – multiple levels of DW_TAG_module. If a DWARF DIE needs to reference a type DIE from another module, Clang emits a forward declaration of the referenced DIE into a DW_TAG_module inside the same compile unit.
</p>
<p>
	When a consumer sees a forward declaration that is nested inside a DW_TAG_module, it knows that it can find the full type declaration in an external .pcm or .pch file. To facilitate locating these external dependencies, Clang emits skeleton CUs into each object file that references external modules. Clang uses the same mechanism that is used to locate external .dwo files on ELF&ndash;based platforms. The DW_AT_GNU_dwo_name contains the absolute path to the .pcm file, and the DW_AT_GNU_dwo_id is a hash of the contents that is repeated in the DW_TAG_compile_unit of the .pcm file.
</p>
<p>
	For example:
</p>
<pre><code>M.h

struct A {
int x;
};

M.pcm

DW_TAG_compile_unit
DW_AT_GNU_dwo_id  (0xabcdef)
DW_TAG_module
    DW_AT_name "M"
    DW_TAG_structure
    DW_AT_name "A"
    DW_TAG_member
        DW_AT_name "x"

A.c

A a;

A.o

DW_TAG_compile_unit
DW_TAG_module
    DW_AT_name "M"
    DW_TAG_structure
    DW_AT_name "A"
    DW_AT_declaration (true)
DW_TAG_variable
    DW_AT_name "a"
    DW_AT_type (local ref to fwd decl "A")

DW_TAG_compile_unit
DW_AT_GNU_dwo_id  (0xabcdef)
DW_AT_GNU_dwo_name    ("M.pcm")</code></pre>
<p>
	The debug info inside a .pcm file may recursively reference further external types that are defined in other .pcm files. Clang generates external references (and debug info inside the modules) for the following types:
</p>
<p>
	C:
</p>
<ul>
	<li>struct</li>
	<li>union</li>
	<li>enum</li>
	<li>typedef</li>
	<br />
</ul>
<p>
	Objective&ndash;C:
</p>
<ul>
	<li>all the C types listed above</li>
	<li>@interface</li>
	<br />
</ul>
<p>
	C++:
</p>
<ul>
	<li>all the C types listed above</li>
	<li>namespace</li>
	<li>any explicit extern template specializations</li>
	<br />
</ul>
<p>
	LLDB supports this DWARF extension only when debugging from .o files. The dsymutil debug info linker also understands this format and will resolve all module type references to point straight to the underlying defining declaration. Because of this a .dSYM bundle will never contain any &ndash;gmodules&ndash;style references.
</p>
	<H3><a name="HEAD_e3f5a540" href="#TOC_HEAD_e3f5a540">2.7.2. Apple SDK information</a></H3>
<p>
	Clang and the Swift compiler emit information about the Xcode SDK that was used to build a translation unit into the DW_TAG_compile_unit. The DW_AT_LLVM_sysroot attribute points to the SDK root (equivalent to Clang&rsquo;s &ndash;isysroot option). The DW_AT_APPLE_sdk attribute contains the name of the SDK, for example MacOSX.sdk.
</p>
	<H3><a name="HEAD_69ec6947" href="#TOC_HEAD_69ec6947">2.7.3. Objective&ndash;C runtime</a></H3>
<p>
	Clang emits the Objective&ndash;C runtime version into the DW_TAG_compile_unit using the DW_AT_APPLE_major_runtime_version attribute. The value 2 stands for Objective&ndash;C 2.0.
</p>
	<H2><a name="HEAD_93d664f3_0" href="#TOC_HEAD_93d664f3_0">2.8. Python Scripting</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_322f2e26" href="#HEAD_322f2e26">2.8.1. The Test Program and Input</a></li>
	<li><a name="TOC_HEAD_12a24a05" href="#HEAD_12a24a05">2.8.2. The Bug</a></li>
	<li><a name="TOC_HEAD_544734f1" href="#HEAD_544734f1">2.8.3. Using Depth First Search</a></li>
	<li><a name="TOC_HEAD_49dd858e" href="#HEAD_49dd858e">2.8.4. Accessing &amp; Manipulating Program Variables</a></li>
	<li><a name="TOC_HEAD_9d00305b" href="#HEAD_9d00305b">2.8.5. Explaining DFS Script in Detail</a></li>
	<li><a name="TOC_HEAD_3c02c95a" href="#HEAD_3c02c95a">2.8.6. The DFS Script in Action</a></li>
	<li><a name="TOC_HEAD_b6d68020" href="#HEAD_b6d68020">2.8.7. Using Breakpoint Command Scripts</a></li>
	<li><a name="TOC_HEAD_9254ac47" href="#HEAD_9254ac47">2.8.8. Python Breakpoint Command Scripts Are Not What They Seem</a></li>
	<li><a name="TOC_HEAD_a3b98632" href="#HEAD_a3b98632">2.8.9. The Decision Point Breakpoint Commands</a></li>
	<li><a name="TOC_HEAD_5818fa27" href="#HEAD_5818fa27">2.8.10. Actually Using The Breakpoint Commands</a></li>
	<li><a name="TOC_HEAD_f359f1b6" href="#HEAD_f359f1b6">2.8.11. Source Files for The Example</a></li>
</menu>

</div>
	<H3><a name="HEAD_322f2e26" href="#TOC_HEAD_322f2e26">2.8.1. The Test Program and Input</a></H3>
<p>
	We have a simple C program (dictionary.c) that reads in a text file, and stores all the words from the file in a Binary Search Tree, sorted alphabetically. It then enters a loop prompting the user for a word, searching for the word in the tree (using Binary Search), and reporting to the user whether or not it found the word in the tree.
</p>
<p>
	The input text file we are using to test our program contains the text for William Shakespeare&rsquo;s famous tragedy &ldquo;Romeo and Juliet&rdquo;.
</p>
	<H3><a name="HEAD_12a24a05" href="#TOC_HEAD_12a24a05">2.8.2. The Bug</a></H3>
<p>
	When we try running our program, we find there is a problem. While it successfully finds some of the words we would expect to find, such as &ldquo;love&rdquo; or &ldquo;sun&rdquo;, it fails to find the word &ldquo;Romeo&rdquo;, which MUST be in the input text file:
</p>
<pre><code>$ ./dictionary Romeo-and-Juliet.txt
Dictionary loaded.
Enter search word: love
Yes!
Enter search word: sun
Yes!
Enter search word: Romeo
No!
Enter search word: ^D
$</code></pre>
	<H3><a name="HEAD_544734f1" href="#TOC_HEAD_544734f1">2.8.3. Using Depth First Search</a></H3>
<p>
	Our first job is to determine if the word &ldquo;Romeo&rdquo; actually got inserted into the tree or not. Since &ldquo;Romeo and Juliet&rdquo; has thousands of words, trying to examine our binary search tree by hand is completely impractical. Therefore we will write a Python script to search the tree for us. We will write a recursive Depth First Search function that traverses the entire tree searching for a word, and maintaining information about the path from the root of the tree to the current node. If it finds the word in the tree, it returns the path from the root to the node containing the word. This is what our DFS function in Python would look like, with line numbers added for easy reference in later explanations:
</p>
<pre><code>1: def DFS (root, word, cur_path):
2:     root_word_ptr = root.GetChildMemberWithName ("word")
3:     left_child_ptr = root.GetChildMemberWithName ("left")
4:     right_child_ptr = root.GetChildMemberWithName ("right")
5:     root_word = root_word_ptr.GetSummary()
6:     end = len (root_word) - 1
7:     if root_word[0] == '"' and root_word[end] == '"':
8:         root_word = root_word[1:end]
9:     end = len (root_word) - 1
10:     if root_word[0] == '\'' and root_word[end] == '\'':
11:        root_word = root_word[1:end]
12:     if root_word == word:
13:         return cur_path
14:     elif word &lt; root_word:
15:         if left_child_ptr.GetValue() == None:
16:             return ""
17:         else:
18:             cur_path = cur_path + "L"
19:             return DFS (left_child_ptr, word, cur_path)
20:     else:
21:         if right_child_ptr.GetValue() == None:
22:             return ""
23:         else:
24:             cur_path = cur_path + "R"
25:             return DFS (right_child_ptr, word, cur_path)</code></pre>
	<H3><a name="HEAD_49dd858e" href="#TOC_HEAD_49dd858e">2.8.4. Accessing &amp; Manipulating Program Variables</a></H3>
<p>
	Before we can call any Python function on any of our program&rsquo;s variables, we need to get the variable into a form that Python can access. To show you how to do this we will look at the parameters for the DFS function. The first parameter is going to be a node in our binary search tree, put into a Python variable. The second parameter is the word we are searching for (a string), and the third parameter is a string representing the path from the root of the tree to our current node.
</p>
<p>
	The most interesting parameter is the first one, the Python variable that needs to contain a node in our search tree. How can we take a variable out of our program and put it into a Python variable? What kind of Python variable will it be? The answers are to use the LLDB API functions, provided as part of the LLDB Python module. Running Python from inside LLDB, LLDB will automatically give us our current frame object as a Python variable, &ldquo;lldb.frame&rdquo;. This variable has the type SBFrame (see the LLDB API for more information about SBFrame objects). One of the things we can do with a frame object, is to ask it to find and return its local variable. We will call the API function SBFrame.FindVariable on the lldb.frame object to give us our dictionary variable as a Python variable:
</p>
<pre><code>root = lldb.frame.FindVariable ("dictionary")</code></pre>
<p>
	The line above, executed in the Python script interpreter in LLDB, asks the current frame to find the variable named &ldquo;dictionary&rdquo; and return it. We then store the returned value in the Python variable named &ldquo;root&rdquo;. This answers the question of HOW to get the variable, but it still doesn&rsquo;t explain WHAT actually gets put into &ldquo;root&rdquo;. If you examine the LLDB API, you will find that the SBFrame method &ldquo;FindVariable&rdquo; returns an object of type SBValue. SBValue objects are used, among other things, to wrap up program variables and values. There are many useful methods defined in the SBValue class to allow you to get information or children values out of SBValues. For complete information, see the header file SBValue.h. The SBValue methods that we use in our DFS function are GetChildMemberWithName(), GetSummary(), and GetValue().
</p>
	<H3><a name="HEAD_9d00305b" href="#TOC_HEAD_9d00305b">2.8.5. Explaining DFS Script in Detail</a></H3>
<p>
	Before diving into the details of this code, it would be best to give a high&ndash;level overview of what it does. The nodes in our binary search tree were defined to have type <code>tree_node *</code> , which is defined as:
</p>
<pre><code>typedef struct tree_node
{
const char *word;
struct tree_node *left;
struct tree_node *right;
} tree_node;</code></pre>
<p>
	Lines 2&ndash;11 of DFS are getting data out of the current tree node and getting ready to do the actual search; lines 12&ndash;25 are the actual depth&ndash;first search. Lines 2&ndash;4 of our DFS function get the word, left and right fields out of the current node and store them in Python variables. Since root_word_ptr is a pointer to our word, and we want the actual word, line 5 calls GetSummary() to get a string containing the value out of the pointer. Since GetSummary() adds quotes around its result, lines 6&ndash;11 strip surrounding quotes off the word.
</p>
<p>
	Line 12 checks to see if the word in the current node is the one we are searching for. If so, we are done, and line 13 returns the current path. Otherwise, line 14 checks to see if we should go left (search word comes before the current word). If we decide to go left, line 15 checks to see if the left pointer child is NULL (&ldquo;None&rdquo; is the Python equivalent of NULL). If the left pointer is NULL, then the word is not in this tree and we return an empty path (line 16). Otherwise, we add an &ldquo;L&rdquo; to the end of our current path string, to indicate we are going left (line 18), and then recurse on the left child (line 19). Lines 20&ndash;25 are the same as lines 14&ndash;19, except for going right rather than going left.
</p>
<p>
	One other note: Typing something as long as our DFS function directly into the interpreter can be difficult, as making a single typing mistake means having to start all over. Therefore we recommend doing as we have done: Writing your longer, more complicated script functions in a separate file (in this case tree_utils.py) and then importing it into your LLDB Python interpreter.
</p>
	<H3><a name="HEAD_3c02c95a" href="#TOC_HEAD_3c02c95a">2.8.6. The DFS Script in Action</a></H3>
<p>
	At this point we are ready to use the DFS function to see if the word &ldquo;Romeo&rdquo; is in our tree or not. To actually use it in LLDB on our dictionary program, you would do something like this:
</p>
<pre><code>$ lldb
(lldb) process attach -n "dictionary"
Architecture set to: x86_64.
Process 521 stopped
* thread #1: tid = 0x2c03, 0x00007fff86c8bea0 libSystem.B.dylib`read$NOCANCEL + 8, stop reason = signal SIGSTOP
frame #0: 0x00007fff86c8bea0 libSystem.B.dylib`read$NOCANCEL + 8
(lldb) breakpoint set -n find_word
Breakpoint created: 1: name = 'find_word', locations = 1, resolved = 1
(lldb) continue
Process 521 resuming
Process 521 stopped
* thread #1: tid = 0x2c03, 0x0000000100001830 dictionary`find_word + 16
at dictionary.c:105, stop reason = breakpoint 1.1
frame #0: 0x0000000100001830 dictionary`find_word + 16 at dictionary.c:105
102 int
103 find_word (tree_node *dictionary, char *word)
104 {
-&gt; 105 if (!word || !dictionary)
106 return 0;
107
108 int compare_value = strcmp (word, dictionary-&gt;word);
(lldb) script
Python Interactive Interpreter. To exit, type 'quit()', 'exit()' or Ctrl-D.
&gt;&gt;&gt; import tree_utils
&gt;&gt;&gt; root = lldb.frame.FindVariable ("dictionary")
&gt;&gt;&gt; current_path = ""
&gt;&gt;&gt; path = tree_utils.DFS (root, "Romeo", current_path)
&gt;&gt;&gt; print path
LLRRL
&gt;&gt;&gt; ^D
(lldb)</code></pre>
<p>
	The first bit of code above shows starting lldb, attaching to the dictionary program, and getting to the find_word function in LLDB. The interesting part (as far as this example is concerned) begins when we enter the script command and drop into the embedded interactive Python interpreter. We will go over this Python code line by line. The first line
</p>
<pre><code>import tree_utils</code></pre>
<p>
	imports the file where we wrote our DFS function, tree_utils.py, into Python. Notice that to import the file we leave off the &ldquo;.py&rdquo; extension. We can now call any function in that file, giving it the prefix &ldquo;tree_utils.&rdquo;, so that Python knows where to look for the function. The line
</p>
<pre><code>root = lldb.frame.FindVariable ("dictionary")</code></pre>
<p>
	gets our program variable &ldquo;dictionary&rdquo; (which contains the binary search tree) and puts it into the Python variable &ldquo;root&rdquo;. See Accessing &amp; Manipulating Program Variables in Python above for more details about how this works. The next line is
</p>
<pre><code>current_path = ""</code></pre>
<p>
	This line initializes the current_path from the root of the tree to our current node. Since we are starting at the root of the tree, our current path starts as an empty string. As we go right and left through the tree, the DFS function will append an &lsquo;R&rsquo; or an &lsquo;L&rsquo; to the current path, as appropriate. The line
</p>
<pre><code>path = tree_utils.DFS (root, "Romeo", current_path)</code></pre>
<p>
	calls our DFS function (prefixing it with the module name so that Python can find it). We pass in our binary tree stored in the variable root, the word we are searching for, and our current path. We assign whatever path the DFS function returns to the Python variable path.
</p>
<p>
	Finally, we want to see if the word was found or not, and if so we want to see the path through the tree to the word. So we do
</p>
<pre><code>print path</code></pre>
<p>
	From this we can see that the word &ldquo;Romeo&rdquo; was indeed found in the tree, and the path from the root of the tree to the node containing &ldquo;Romeo&rdquo; is left&ndash;left&ndash;right&ndash;right&ndash;left.
</p>
	<H3><a name="HEAD_b6d68020" href="#TOC_HEAD_b6d68020">2.8.7. Using Breakpoint Command Scripts</a></H3>
<p>
	We are halfway to figuring out what the problem is. We know the word we are looking for is in the binary tree, and we know exactly where it is in the binary tree. Now we need to figure out why our binary search algorithm is not finding the word. We will do this using breakpoint command scripts.
</p>
<p>
	The idea is as follows. The binary search algorithm has two main decision points: the decision to follow the right branch; and, the decision to follow the left branch. We will set a breakpoint at each of these decision points, and attach a Python breakpoint command script to each breakpoint. The breakpoint commands will use the global path Python variable that we got from our DFS function. Each time one of these decision breakpoints is hit, the script will compare the actual decision with the decision the front of the path variable says should be made (the first character of the path). If the actual decision and the path agree, then the front character is stripped off the path, and execution is resumed. In this case the user never even sees the breakpoint being hit. But if the decision differs from what the path says it should be, then the script prints out a message and does NOT resume execution, leaving the user sitting at the first point where a wrong decision is being made.
</p>
	<H3><a name="HEAD_9254ac47" href="#TOC_HEAD_9254ac47">2.8.8. Python Breakpoint Command Scripts Are Not What They Seem</a></H3>
<p>
	What do we mean by that? When you enter a Python breakpoint command in LLDB, it appears that you are entering one or more plain lines of Python. BUT LLDB then takes what you entered and wraps it into a Python FUNCTION (just like using the &ldquo;def&rdquo; Python command). It automatically gives the function an obscure, unique, hard&ndash;to&ndash;stumble&ndash;across function name, and gives it two parameters: frame and bp_loc. When the breakpoint gets hit, LLDB wraps up the frame object where the breakpoint was hit, and the breakpoint location object for the breakpoint that was hit, and puts them into Python variables for you. It then calls the Python function that was created for the breakpoint command, and passes in the frame and breakpoint location objects.
</p>
<p>
	So, being practical, what does this mean for you when you write your Python breakpoint commands? It means that there are two things you need to keep in mind: 1. If you want to access any Python variables created outside your script, you must declare such variables to be global. If you do not declare them as global, then the Python function will treat them as local variables, and you will get unexpected behavior. 2. All Python breakpoint command scripts automatically have a frame and a bp_loc variable. The variables are pre&ndash;loaded by LLDB with the correct context for the breakpoint. You do not have to use these variables, but they are there if you want them.
</p>
	<H3><a name="HEAD_a3b98632" href="#TOC_HEAD_a3b98632">2.8.9. The Decision Point Breakpoint Commands</a></H3>
<p>
	This is what the Python breakpoint command script would look like for the decision to go right:
</p>
<pre><code>global path
if path[0] == 'R':
path = path[1:]
thread = frame.GetThread()
process = thread.GetProcess()
process.Continue()
else:
print "Here is the problem; going right, should go left!"
Just as a reminder, LLDB is going to take this script and wrap it up in a function, like this:


def some_unique_and_obscure_function_name (frame, bp_loc):
global path
if path[0] == 'R':
    path = path[1:]
    thread = frame.GetThread()
    process = thread.GetProcess()
    process.Continue()
else:
    print "Here is the problem; going right, should go left!"</code></pre>
<p>
	LLDB will call the function, passing in the correct frame and breakpoint location whenever the breakpoint gets hit. There are several things to notice about this function. The first one is that we are accessing and updating a piece of state (the path variable), and actually conditioning our behavior based upon this variable. Since the variable was defined outside of our script (and therefore outside of the corresponding function) we need to tell Python that we are accessing a global variable. That is what the first line of the script does. Next we check where the path says we should go and compare it to our decision (recall that we are at the breakpoint for the decision to go right). If the path agrees with our decision, then we strip the first character off of the path.
</p>
<p>
	Since the decision matched the path, we want to resume execution. To do this we make use of the frame parameter that LLDB guarantees will be there for us. We use LLDB API functions to get the current thread from the current frame, and then to get the process from the thread. Once we have the process, we tell it to resume execution (using the Continue() API function).
</p>
<p>
	If the decision to go right does not agree with the path, then we do not resume execution. We allow the breakpoint to remain stopped (by doing nothing), and we print an informational message telling the user we have found the problem, and what the problem is.
</p>
	<H3><a name="HEAD_5818fa27" href="#TOC_HEAD_5818fa27">2.8.10. Actually Using The Breakpoint Commands</a></H3>
<p>
	Now we will look at what happens when we actually use these breakpoint commands on our program. Doing a source list &ndash;n find_word shows us the function containing our two decision points. Looking at the code below, we see that we want to set our breakpoints on lines 113 and 115:
</p>
<pre><code>(lldb) source list -n find_word
File: /Volumes/Data/HD2/carolinetice/Desktop/LLDB-Web-Examples/dictionary.c.
101
102 int
103 find_word (tree_node *dictionary, char *word)
104 {
105   if (!word || !dictionary)
106     return 0;
107
108   int compare_value = strcmp (word, dictionary-&gt;word);
109
110   if (compare_value == 0)
111     return 1;
112   else if (compare_value &lt; 0)
113     return find_word (dictionary-&gt;left, word);
114   else
115     return find_word (dictionary-&gt;right, word);
116 }
117</code></pre>
<p>
	So, we set our breakpoints, enter our breakpoint command scripts, and see what happens:
</p>
<pre><code>(lldb) breakpoint set -l 113
Breakpoint created: 2: file ='dictionary.c', line = 113, locations = 1, resolved = 1
(lldb) breakpoint set -l 115
Breakpoint created: 3: file ='dictionary.c', line = 115, locations = 1, resolved = 1
(lldb) breakpoint command add -s python 2
Enter your Python command(s). Type 'DONE' to end.
&gt; global path
&gt; if (path[0] == 'L'):
&gt;     path = path[1:]
&gt;     thread = frame.GetThread()
&gt;     process = thread.GetProcess()
&gt;     process.Continue()
&gt; else:
&gt;     print "Here is the problem. Going left, should go right!"
&gt; DONE
(lldb) breakpoint command add -s python 3
Enter your Python command(s). Type 'DONE' to end.
&gt; global path
&gt; if (path[0] == 'R'):
&gt;     path = path[1:]
&gt;     thread = frame.GetThread()
&gt;     process = thread.GetProcess()
&gt;     process.Continue()
&gt; else:
&gt;     print "Here is the problem. Going right, should go left!"
&gt; DONE
(lldb) continue
Process 696 resuming
Here is the problem. Going right, should go left!
Process 696 stopped
* thread #1: tid = 0x2d03, 0x000000010000189f dictionary`find_word + 127 at dictionary.c:115, stop reason = breakpoint 3.1
frame #0: 0x000000010000189f dictionary`find_word + 127 at dictionary.c:115
112   else if (compare_value &lt; 0)
113     return find_word (dictionary-&gt;left, word);
114   else
-&gt; 115     return find_word (dictionary-&gt;right, word);
116 }
117
118 void
(lldb)</code></pre>
<p>
	After setting our breakpoints, adding our breakpoint commands and continuing, we run for a little bit and then hit one of our breakpoints, printing out the error message from the breakpoint command. Apparently at this point in the tree, our search algorithm decided to go right, but our path says the node we want is to the left. Examining the word at the node where we stopped, and our search word, we see:
</p>
<pre><code>(lldb) expr dictionary-&gt;word
(const char *) $1 = 0x0000000100100080 "dramatis"
(lldb) expr word
(char *) $2 = 0x00007fff5fbff108 "romeo"</code></pre>
<p>
	So the word at our current node is &ldquo;dramatis&rdquo;, and the word we are searching for is &ldquo;romeo&rdquo;. &ldquo;romeo&rdquo; comes after &ldquo;dramatis&rdquo; alphabetically, so it seems like going right would be the correct decision. Let&rsquo;s ask Python what it thinks the path from the current node to our word is:
</p>
<pre><code>(lldb) script print path
LLRRL</code></pre>
<p>
	According to Python we need to go left&ndash;left&ndash;right&ndash;right&ndash;left from our current node to find the word we are looking for. Let&rsquo;s double check our tree, and see what word it has at that node:
</p>
<pre><code>(lldb) expr dictionary-&gt;left-&gt;left-&gt;right-&gt;right-&gt;left-&gt;word
(const char *) $4 = 0x0000000100100880 "Romeo"</code></pre>
<p>
	So the word we are searching for is &ldquo;romeo&rdquo; and the word at our DFS location is &ldquo;Romeo&rdquo;. Aha! One is uppercase and the other is lowercase: We seem to have a case conversion problem somewhere in our program (we do).
</p>
<p>
	This is the end of our example on how you might use Python scripting in LLDB to help you find bugs in your program.
</p>
	<H3><a name="HEAD_f359f1b6" href="#TOC_HEAD_f359f1b6">2.8.11. Source Files for The Example</a></H3>
<p>
	The complete code for the Dictionary program (with case&ndash;conversion bug), the DFS function and other Python script examples (tree_utils.py) used for this example are available below.
</p>
<p>
	tree_utils.py &ndash; Example Python functions using LLDB&rsquo;s API, including DFS
</p>
<pre><code>"""
# ===-- tree_utils.py ---------------------------------------*- Python -*-===//
#
#  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
#  See https://llvm.org/LICENSE.txt for license information.
#  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ===----------------------------------------------------------------------===//

tree_utils.py  - A set of functions for examining binary
search trees, based on the example search tree defined in
dictionary.c.  These functions contain calls to LLDB API
functions, and assume that the LLDB Python module has been
imported.

For a thorough explanation of how the DFS function works, and
for more information about dictionary.c go to
http://lldb.llvm.org/scripting.html
"""


def DFS(root, word, cur_path):
"""
Recursively traverse a binary search tree containing
words sorted alphabetically, searching for a particular
word in the tree.  Also maintains a string representing
the path from the root of the tree to the current node.
If the word is found in the tree, return the path string.
Otherwise return an empty string.

This function assumes the binary search tree is
the one defined in dictionary.c  It uses LLDB API
functions to examine and traverse the tree nodes.
"""

# Get pointer field values out of node 'root'

root_word_ptr = root.GetChildMemberWithName("word")
left_child_ptr = root.GetChildMemberWithName("left")
right_child_ptr = root.GetChildMemberWithName("right")

# Get the word out of the word pointer and strip off
# surrounding quotes (added by call to GetSummary).

root_word = root_word_ptr.GetSummary()
end = len(root_word) - 1
if root_word[0] == '"' and root_word[end] == '"':
    root_word = root_word[1:end]
end = len(root_word) - 1
if root_word[0] == '\'' and root_word[end] == '\'':
    root_word = root_word[1:end]

# Main depth first search

if root_word == word:
    return cur_path
elif word &lt; root_word:

    # Check to see if left child is NULL

    if left_child_ptr.GetValue() is None:
            return ""
    else:
            cur_path = cur_path + "L"
            return DFS(left_child_ptr, word, cur_path)
else:

    # Check to see if right child is NULL

    if right_child_ptr.GetValue() is None:
            return ""
    else:
            cur_path = cur_path + "R"
            return DFS(right_child_ptr, word, cur_path)


def tree_size(root):
"""
Recursively traverse a binary search tree, counting
the nodes in the tree.  Returns the final count.

This function assumes the binary search tree is
the one defined in dictionary.c  It uses LLDB API
functions to examine and traverse the tree nodes.
"""
if (root.GetValue is None):
    return 0

if (int(root.GetValue(), 16) == 0):
    return 0

left_size = tree_size(root.GetChildAtIndex(1))
right_size = tree_size(root.GetChildAtIndex(2))

total_size = left_size + right_size + 1
return total_size


def print_tree(root):
"""
Recursively traverse a binary search tree, printing out
the words at the nodes in alphabetical order (the
search order for the binary tree).

This function assumes the binary search tree is
the one defined in dictionary.c  It uses LLDB API
functions to examine and traverse the tree nodes.
"""
if (root.GetChildAtIndex(1).GetValue() is not None) and (
            int(root.GetChildAtIndex(1).GetValue(), 16) != 0):
    print_tree(root.GetChildAtIndex(1))

print root.GetChildAtIndex(0).GetSummary()

if (root.GetChildAtIndex(2).GetValue() is not None) and (
            int(root.GetChildAtIndex(2).GetValue(), 16) != 0):
    print_tree(root.GetChildAtIndex(2))</code></pre>
<p>
	dictionary.c &ndash; Sample dictionary program, with bug
</p>
<pre><code>//===-- dictionary.c ---------------------------------------------*- C -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct tree_node {
const char *word;
struct tree_node *left;
struct tree_node *right;
} tree_node;

/* Given a char*, returns a substring that starts at the first
alphabet character and ends at the last alphabet character, i.e. it
strips off beginning or ending quotes, punctuation, etc. */

char *strip(char **word) {
char *start = *word;
int len = strlen(start);
char *end = start + len - 1;

while ((start &lt; end) && (!isalpha(start[0])))
start++;

while ((end &gt; start) && (!isalpha(end[0])))
end--;

if (start &gt; end)
return NULL;

end[1] = '\0';
*word = start;

return start;
}

/* Given a binary search tree (sorted alphabetically by the word at
each node), and a new word, inserts the word at the appropriate
place in the tree.  */

void insert(tree_node *root, char *word) {
if (root == NULL)
return;

int compare_value = strcmp(word, root-&gt;word);

if (compare_value == 0)
return;

if (compare_value &lt; 0) {
if (root-&gt;left != NULL)
    insert(root-&gt;left, word);
else {
    tree_node *new_node = (tree_node *)malloc(sizeof(tree_node));
    new_node-&gt;word = strdup(word);
    new_node-&gt;left = NULL;
    new_node-&gt;right = NULL;
    root-&gt;left = new_node;
}
} else {
if (root-&gt;right != NULL)
    insert(root-&gt;right, word);
else {
    tree_node *new_node = (tree_node *)malloc(sizeof(tree_node));
    new_node-&gt;word = strdup(word);
    new_node-&gt;left = NULL;
    new_node-&gt;right = NULL;
    root-&gt;right = new_node;
}
}
}

/* Read in a text file and storea all the words from the file in a
binary search tree.  */

void populate_dictionary(tree_node **dictionary, char *filename) {
FILE *in_file;
char word[1024];

in_file = fopen(filename, "r");
if (in_file) {
while (fscanf(in_file, "%s", word) == 1) {
    char *new_word = (strdup(word));
    new_word = strip(&new_word);
    if (*dictionary == NULL) {
    tree_node *new_node = (tree_node *)malloc(sizeof(tree_node));
    new_node-&gt;word = new_word;
    new_node-&gt;left = NULL;
    new_node-&gt;right = NULL;
    *dictionary = new_node;
    } else
    insert(*dictionary, new_word);
}
}
}

/* Given a binary search tree and a word, search for the word
in the binary search tree.  */

int find_word(tree_node *dictionary, char *word) {
if (!word || !dictionary)
return 0;

int compare_value = strcmp(word, dictionary-&gt;word);

if (compare_value == 0)
return 1;
else if (compare_value &lt; 0)
return find_word(dictionary-&gt;left, word);
else
return find_word(dictionary-&gt;right, word);
}

/* Print out the words in the binary search tree, in sorted order.  */

void print_tree(tree_node *dictionary) {
if (!dictionary)
return;

if (dictionary-&gt;left)
print_tree(dictionary-&gt;left);

printf("%s\n", dictionary-&gt;word);

if (dictionary-&gt;right)
print_tree(dictionary-&gt;right);
}

int main(int argc, char **argv) {
tree_node *dictionary = NULL;
char buffer[1024];
char *filename;
int done = 0;

if (argc == 2)
filename = argv[1];

if (!filename)
return -1;

populate_dictionary(&dictionary, filename);
fprintf(stdout, "Dictionary loaded.\nEnter search word: ");
while (!done && fgets(buffer, sizeof(buffer), stdin)) {
char *word = buffer;
int len = strlen(word);
int i;

for (i = 0; i &lt; len; ++i)
    word[i] = tolower(word[i]);

if ((len &gt; 0) && (word[len - 1] == '\n')) {
    word[len - 1] = '\0';
    len = len - 1;
}

if (find_word(dictionary, word))
    fprintf(stdout, "Yes!\n");
else
    fprintf(stdout, "No!\n");

fprintf(stdout, "Enter search word: ");
}

fprintf(stdout, "\n");
return 0;
}</code></pre>
<p>
	The text for &ldquo;Romeo and Juliet&rdquo; can be obtained from the Gutenberg Project (http://www.gutenberg.org).
</p>
	<H2><a name="HEAD_4dcb9507" href="#TOC_HEAD_4dcb9507">2.9. Python Reference</a> <a name="MARK_3" href="#TOC_MARK_3"><strong><font color="red">@TODO</font></strong></a></H2><ul></ul>
	<H2><a name="HEAD_7a19ff94" href="#TOC_HEAD_7a19ff94">2.10. Remote Debugging</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_cbba014" href="#HEAD_cbba014">2.10.1. Preparation for Remote Debugging</a></li>
	<menu>
		<li><a name="TOC_HEAD_53035729" href="#HEAD_53035729">2.10.1.1. Remote system</a></li>
		<li><a name="TOC_HEAD_b91e30a4" href="#HEAD_b91e30a4">2.10.1.2. Local system</a></li>
	</menu>
	<li><a name="TOC_HEAD_b5e39a72" href="#HEAD_b5e39a72">2.10.2. Launching a locally built process on the remote machine</a></li>
	<menu>
		<li><a name="TOC_HEAD_3458d0f8" href="#HEAD_3458d0f8">2.10.2.1. Install and run in the platform working directory</a></li>
		<li><a name="TOC_HEAD_d6cce0d3" href="#HEAD_d6cce0d3">2.10.2.2. Changing the platform working directory</a></li>
		<li><a name="TOC_HEAD_98cf5e0c" href="#HEAD_98cf5e0c">2.10.2.3. Install and run by specifying a remote install path</a></li>
		<li><a name="TOC_HEAD_dc975ff6" href="#HEAD_dc975ff6">2.10.2.4. Attaching to a remote process</a></li>
	</menu>
</menu>

</div>
<p>
	Remote debugging refers to the act of debugging a process which is running on a different system, than the debugger itself. We shall refer to the system running the debugger as the local system, while the system running the debugged process will be the remote system.
</p>
<p>
	To enable remote debugging, LLDB employs a client&ndash;server architecture. The client part runs on the local system and the remote system runs the server. The client and server communicate using the gdb&ndash;remote protocol, usually transported over TCP/IP. More information on the protocol can be found here and the LLDB&ndash;specific extensions are documented in docs/lldb&ndash;gdb&ndash;remote.txt file inside LLDB source repository. Besides the gdb&ndash;remote stub, the server part of LLDB also consists of a platform binary, which is responsible for performing advanced debugging operations, like copying files from/to the remote system and can be used to execute arbitrary shell commands on the remote system.
</p>
<p>
	In order to reduce code complexity and improve remote debugging experience LLDB on Linux and macOS uses the remote debugging stub even when debugging a process locally. This is achieved by spawning a remote stub process locally and communicating with it over the loopback interface. In the case of local debugging this whole process is transparent to the user. The platform binary is not used in this case, since no file transfers are needed.
</p>
	<H3><a name="HEAD_cbba014" href="#TOC_HEAD_cbba014">2.10.1. Preparation for Remote Debugging</a></H3>
<p>
	While the process of actual debugging (stepping, backtraces, evaluating expressions) is same as in the local case, in the case of remote debugging, more preparation is needed as the required binaries cannot started on the remote system automatically. Also, if the remote system runs a different OS or architecture, the server component needs to be compiled separately.
</p>
	<H4><a name="HEAD_53035729" href="#TOC_HEAD_53035729">2.10.1.1. Remote system</a></H4>
<p>
	On Linux and Android, all required remote functionality is contained in the lldb&ndash;server binary. This binary combines the functionality of the platform and gdb&ndash;remote stub. A single binary facilitates deployment and reduces code size, since the two functions share a lot of code. The lldb&ndash;server binary is also statically linked with the rest of LLDB (unlike lldb, which dynamically links to liblldb.so by default), so it does not have any dependencies on the rest of lldb. On macOS and iOS, the remote&ndash;gdb functionality is implemented by the debugserver binary, which you will need to deploy alongside lldb&ndash;server.
</p>
<p>
	The binaries mentioned above need to be present on the remote system to enable remote debugging. You can either compile on the remote system directly or copy them from the local machine. If compiling locally and the remote architecture differs from the local one, you will need to cross&ndash;compile the correct version of the binaries. More information on cross&ndash;compiling LLDB can be found on the build page.
</p>
<p>
	Once the binaries are in place, you just need to run the lldb&ndash;server in platform mode and specify the port it should listen on. For example, the command
</p>
<pre><code>remote% lldb-server platform --listen "*:1234" --server</code></pre>
<p>
	will start the LLDB platform and wait for incoming connections from any address to port 1234. Specifying an address instead of * will only allow connections originating from that address. Adding a –server parameter to the command line will fork off a new process for every incoming connection, allowing multiple parallel debug sessions.
</p>
	<H4><a name="HEAD_b91e30a4" href="#TOC_HEAD_b91e30a4">2.10.1.2. Local system</a></H4>
<p>
	On the local system, you need to let LLDB know that you intend to do remote debugging. This is achieved through the platform command and its sub&ndash;commands. As a first step you need to choose the correct platform plug&ndash;in for your remote system. A list of available plug&ndash;ins can be obtained through platform list.
</p>
<pre><code>local% lldb
(lldb) platform list
Available platforms:
host: Local macOS user platform plug-in.
remote-freebsd: Remote FreeBSD user platform plug-in.
remote-linux: Remote Linux user platform plug-in.
remote-netbsd: Remote NetBSD user platform plug-in.
remote-windows: Remote Windows user platform plug-in.
remote-android: Remote Android user platform plug-in.
remote-ios: Remote iOS platform plug-in.
remote-macosx: Remote macOS user platform plug-in.
ios-simulator: iOS simulator platform plug-in.
darwin-kernel: Darwin Kernel platform plug-in.
tvos-simulator: Apple TV simulator platform plug-in.
watchos-simulator: Apple Watch simulator platform plug-in.
remote-tvos: Remote Apple TV platform plug-in.
remote-watchos: Remote Apple Watch platform plug-in.
remote-gdb-server: A platform that uses the GDB remote protocol as the communication transport.</code></pre>
<p>
	The default platform is the platform host which is used for local debugging. Apart from this, the list should contain a number of plug&ndash;ins, for debugging different kinds of systems. The remote plug&ndash;ins are prefixed with &ldquo;remote&ndash;&ldquo;. For example, to debug a remote Linux application:
</p>
<pre><code>(lldb) platform select remote-linux</code></pre>
<p>
	After selecting the platform plug&ndash;in, you should receive a prompt which confirms the selected platform, and states that you are not connected. This is because remote plug&ndash;ins need to be connected to their remote platform counterpart to operate. This is achieved using the platform connect command. This command takes a number of arguments (as always, use the help command to find out more), but normally you only need to specify the address to connect to, e.g.:
</p>
<pre><code>(lldb) platform connect connect://remote:1234
Platform: remote-linux
    Triple: x86_64-gnu-linux
Hostname: remote
Connected: yes
WorkingDir: /tmp</code></pre>
<p>
	Note that the platform has a working directory of /tmp. This directory will be used as the directory that executables will be uploaded to by default when launching a process from local.
</p>
<p>
	After this, you should be able to debug normally. You can use the process attach to attach to an existing remote process or target create, process launch to start a new one. The platform plugin will transparently take care of uploading or downloading the executable in order to be able to debug. If your application needs additional files, you can transfer them using the platform commands: get&ndash;file, put&ndash;file, mkdir, etc. The environment can be prepared further using the platform shell command.
</p>
<p>
	When using the &ldquo;remote&ndash;android&rdquo; platform, the client LLDB forwards two ports, one for connecting to the platform, and another for connecting to the gdbserver. The client ports are configurable through the environment variables ANDROID_PLATFORM_LOCAL_PORT and ANDROID_PLATFORM_LOCAL_GDB_PORT, respectively.
</p>
	<H3><a name="HEAD_b5e39a72" href="#TOC_HEAD_b5e39a72">2.10.2. Launching a locally built process on the remote machine</a></H3>
	<H4><a name="HEAD_3458d0f8" href="#TOC_HEAD_3458d0f8">2.10.2.1. Install and run in the platform working directory</a></H4>
<p>
	To launch a locally built process on the remote system in the platform working directory:
</p>
<pre><code>(lldb) file a.out
(lldb) run</code></pre>
<p>
	This will cause LLDB to create a target with the &ldquo;a.out&rdquo; executable that you cross built. The &ldquo;run&rdquo; command will cause LLDB to upload &ldquo;a.out&rdquo; to the platform&rsquo;s current working directory only if the file has changed. The platform connection allows us to transfer files, but also allows us to get the MD5 checksum of the file on the other end and only upload the file if it has changed. LLDB will automatically launch a lldb&ndash;server in gdbremote mode to allow you to debug this executable, connect to it and start your debug session for you.
</p>
	<H4><a name="HEAD_d6cce0d3" href="#TOC_HEAD_d6cce0d3">2.10.2.2. Changing the platform working directory</a></H4>
<p>
	You can change the platform working directory while connected to the platform with:
</p>
<pre><code>(lldb) platform settings -w /usr/local/bin</code></pre>
<p>
	And you can verify it worked using &ldquo;platform status&rdquo;:
</p>
<pre><code>(lldb) platform status
Platform: remote-linux
    Triple: x86_64-gnu-linux
Hostname: remote
Connected: yes
WorkingDir: /usr/local/bin</code></pre>
<p>
	If we run again, the program will be installed into /usr/local/bin.
</p>
	<H4><a name="HEAD_98cf5e0c" href="#TOC_HEAD_98cf5e0c">2.10.2.3. Install and run by specifying a remote install path</a></H4>
<p>
	If you want the &ldquo;a.out&rdquo; executable to be installed into &ldquo;/bin/a.out&rdquo; instead of the platform&rsquo;s current working directory, we can set the platform file specification using python:
</p>
<pre><code>(lldb) file a.out
(lldb) script lldb.target.module['a.out'].SetPlatformFileSpec("/bin/a.out")
(lldb) run</code></pre>
<p>
	Now when you run your program, the program will be uploaded to &ldquo;/bin/a.out&rdquo; instead of the platform current working directory. Only the main executable is uploaded to the remote system by default when launching the application. If you have shared libraries that should also be uploaded, then you can add the locally build shared library to the current target and set its platform file specification:
</p>
<pre><code>(lldb) file a.out
(lldb) target module add /local/build/libfoo.so
(lldb) target module add /local/build/libbar.so
(lldb) script lldb.target.module['libfoo.so'].SetPlatformFileSpec("/usr/lib/libfoo.so")
(lldb) script lldb.target.module['libbar.so'].SetPlatformFileSpec("/usr/local/lib/libbar.so")
(lldb) run</code></pre>
	<H4><a name="HEAD_dc975ff6" href="#TOC_HEAD_dc975ff6">2.10.2.4. Attaching to a remote process</a></H4>
<p>
	If you want to attach to a remote process, you can first list the processes on the remote system:
</p>
<pre><code>(lldb) platform process list
223 matching processes were found on "remote-linux"
PID    PARENT USER       TRIPLE                   NAME
====== ====== ========== ======================== ============================
68639  90652             x86_64-apple-macosx      lldb
...</code></pre>
<p>
	Then attaching is as simple as specifying the remote process ID:
</p>
<pre><code>(lldb) attach 68639</code></pre>
	<H2><a name="HEAD_77a9260a" href="#TOC_HEAD_77a9260a">2.11. Testing LLDB using QEMU</a> <a name="MARK_4" href="#TOC_MARK_4"><strong><font color="red">@TODO</font></strong></a></H2><ul><a href="../tags/Qemu.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Qemu</a>&nbsp;</ul>
	<H2><a name="HEAD_27cccef1" href="#TOC_HEAD_27cccef1">2.12. Tracing with Intel Processor Trace</a></H2><ul><a href="../tags/Intel-PT.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Intel-PT</a>&nbsp;</ul>
<ul>
	<li><a name="HEAD_HIDDEN_8723792b">Intel&ndash;PT (name=Intel Processor Trace) &nbsp;<a href="../tags/Intel-PT.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>Intel-PT</a></li>
	<br />
</ul>
	<H2><a name="HEAD_b029cd47" href="#TOC_HEAD_b029cd47">2.13. On Demand Symbols</a></H2><ul><a href="../tags/psymtabs.html" target="_blank" id="inlntag"><i class="fa fa-tags fa-fw"></i>psymtabs</a>&nbsp;</ul>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_a6ec35f4" href="#HEAD_a6ec35f4">2.13.1. When should I consider enabling this feature?</a></li>
	<li><a name="TOC_HEAD_1ac34439" href="#HEAD_1ac34439">2.13.2. How do I enable on demand symbols?</a></li>
	<li><a name="TOC_HEAD_2d9440b9" href="#HEAD_2d9440b9">2.13.3. How does this feature work?</a></li>
	<li><a name="TOC_HEAD_eb3d6e89" href="#HEAD_eb3d6e89">2.13.4. What other things might fail?</a></li>
	<li><a name="TOC_HEAD_63ee01a" href="#HEAD_63ee01a">2.13.5. Can I troubleshoot issues when I believe this feature is impeding my debugging?</a></li>
</menu>

</div>
<p>
	On demand symbols can be enabled in LLDB for projects that generate debug info for more than what is required by a normal debug session. Some build systems enable debug information for all binaries and can end up producing many gigabytes of debug information. This amount of debug information can greatly increase debug session load times and can slow developer productivity when the debug information isn&rsquo;t indexed. It can also cause expression evaluation to be slow when types from all of the binaries have full debug info as each module is queried for very common types, or global name lookups fail due to a mistyped expression.
</p>
	<H3><a name="HEAD_a6ec35f4" href="#TOC_HEAD_a6ec35f4">2.13.1. When should I consider enabling this feature?</a></H3>
<p>
	Anyone that has a build system that produces debug information for many binaries that are not all required when you want to focus on debugging a few of the produced binaries. Some build systems enable debug info as a project wide switch and the build system files that control how things are built are not easy to modify to produce debug info for only a small subset of the files being linked. If your debug session startup times are slow because of too much debug info, this feature might help you be more productive during daily use.
</p>
	<H3><a name="HEAD_1ac34439" href="#TOC_HEAD_1ac34439">2.13.2. How do I enable on demand symbols?</a></H3>
<p>
	This feature is enabled using a LLDB setting:
</p>
<pre><code>(lldb) settings set symbols.load-on-demand true</code></pre>
<p>
	Users can also put this command into their &tilde;/.lldbinit file so it is always enabled.
</p>
	<H3><a name="HEAD_2d9440b9" href="#TOC_HEAD_2d9440b9">2.13.3. How does this feature work?</a></H3>
<p>
	This feature works by selectively enabling debug information for modules that the user focuses on. It is designed to be enabled and work without the user having to set any other settings and will try and determine when to enable debug info access from the modules automatically. All modules with debug info start off with their debug information turned off for expensive name and type lookups. The debug information for line tables are always left enabled to allow users to reliably set breakpoints by file and line. As the user debugs their target, some simple things can cause module to get its debug information enabled (called hydration): &ndash; Setting a file and line breakpoint &ndash; Any PC from any stack frame that maps to a module &ndash; Setting a breakpoint by function name &ndash; Finding a global variable by name
</p>
<p>
	Since most users set breakpoints by file and line, this is an easy way for people to inform the debugger that they want focus on this module. Breakpoints by file and line are always enabled when on demand symbols is being used. Line tables in debug information are cheap to parse and breakpoints will be able to be set in any module that has debug info. Setting breakpoints by file and line acts as one of the primary ways to enable debug info for a module as it is the most common way to stop your program at interesting areas of your code.
</p>
<p>
	Once the user hits a breakpoint, or stops the program for any other reason, like a crash, assertion or signal, the debugger will calculate the stack frames for one or more threads. Any stack frames whose PC value is contained within one of a module&rsquo;s sections will have its debug information enabled. This allows us to enable debug information for the areas of code that the user is stopped in and will allow only the important subset of modules to have their debug information enabled.
</p>
<p>
	On demand symbol loading tries to avoid indexing the names within the debug information and makes a few tradeoffs to allow name matching of functions and globals without having to always index all of the debug information. Setting breakpoints by function name can work, but we try to avoid using debug information by relying on the symbol tables from a module. Debug information name indexing is one of the most expensive operations that we are trying to avoid with the on demand symbol loading so this is one of the main tradeoffs of this feature. When setting a breakpoint by function name, if the symbol table contains a match, the debug information will be enabled for that module and the query will be completed using the debug information. This does mean that setting breakpoints on inline function names can fail for modules that have debug info, but no matches in the symbol table since inlined functions don&rsquo;t exist in symbol tables. When using on demand symbol loading it is encouraged to not strip the symbol tables of local symbols as this will allow users to set breakpoints on all concrete functions reliably. Stripped symbol tables have their local symbols removed from the symbol table which means that static functions and non exported function will not appear in the symbol tables. This can cause breakpoint setting by function name to fail when previously it wouldn&rsquo;t fail.
</p>
<p>
	Global variable lookups rely on the same methodology as breakpoint setting by function name: we use the symbol tables to find a match first if debug information isn&rsquo;t enabled for a module. If we find a match in the symbol table for a global variable lookup, we will enable debug information and complete the query using the debug information. It is encouraged to not strip your symbol tables with this features as static variables and other non exported globals will not appear in the symbol table and can lead to matches not being found.
</p>
	<H3><a name="HEAD_eb3d6e89" href="#TOC_HEAD_eb3d6e89">2.13.4. What other things might fail?</a></H3>
<p>
	The on demand symbol loading feature tries to limit expensive name lookups within debug information. As such, some lookups by name might fail when they wouldn&rsquo;t when this feature is not enabled: &ndash; Setting breakpoints by function name for inlined functions &ndash; Type lookups when the expression parser requests types by name &ndash; Global variable lookups by name when the name of the variable is stripped
</p>
<p>
	Setting breakpoints by function name can fail for inline function because this information is only contained in the debug information. No symbols are created for inlined functions unless there is a concrete copy of the inlined function in that same module. As a result, we might not end up stopping at all inlined functions when requested with this feature enabled. Setting file and line breakpoints are a good way still use on demand symbol loading effectively and still being able to stop at inline function invocations.
</p>
<p>
	The expression parser often tries to lookup types by name when the user types an expression. These are some of the most costly parts of expression evaluation as the user can type something like &ldquo;iterator&rdquo; as part of their expression and this can result in matches from all STL types in all modules. These kinds of global type lookup queries can cause thousands of results to be found if debug information is enabled. The way that most debug information is created these days has the type information inlined into each module. Typically each module will contain full type definitions in the debug info for any types that are used in code. This means that when you type an expression when stopped, you have debug information for all of the variables, arguments and global variables in your current stack frame and we should be able to find type that are important by using only the modules that have their debug information enabled.
</p>
<p>
	The expression parser can also be asked to display global variables and they can be looked up by name. For this feature to work reliably with on demand symbol loading enabled, just don&rsquo;t strip your symbol tables and the expression parser should have no problem finding your variables. Most global variables that are exported will still be in your symbol table if it is stripped, but static variables and non exported globals will not be.
</p>
	<H3><a name="HEAD_63ee01a" href="#TOC_HEAD_63ee01a">2.13.5. Can I troubleshoot issues when I believe this feature is impeding my debugging?</a></H3>
<p>
	Logging has been added that can be enabled to help notify our engineers when something is not producing results when this feature is enabled. This logging can be enabled during a debug session and can be sent to the LLDB engineers to help troubleshoot these situation. To enable logging, type the following command:
</p>
<pre><code>(lldb) log enable -f /tmp/ondemand.txt lldb on-demand</code></pre>
<p>
	When the logging is enabled, we get full visibility into each query that would have produced results if this feature were not enabled and will allow us to troublshoot issues. Enabling this logging before an expression, setting a breakpoint by name, or doing a type lookup can help us see the patterns that cause failures and will help us improve this feature.
</p>
	<H2><a name="HEAD_78b6aa3a" href="#TOC_HEAD_78b6aa3a">2.14. Troubleshooting</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_8f5bd4a1" href="#HEAD_8f5bd4a1">2.14.1. File and Line Breakpoints Are Not Getting Hit</a></li>
	<li><a name="TOC_HEAD_b06aada3" href="#HEAD_b06aada3">2.14.2. How Do I Check If I Have Debug Symbols?</a></li>
</menu>

</div>
	<H3><a name="HEAD_8f5bd4a1" href="#TOC_HEAD_8f5bd4a1">2.14.1. File and Line Breakpoints Are Not Getting Hit</a></H3>
<p>
	First you must make sure that your source files were compiled with debug information. Typically this means passing &ndash;g to the compiler when compiling your source file.
</p>
<p>
	When setting breakpoints in implementation source files (.c, cpp, cxx, .m, .mm, etc), LLDB by default will only search for compile units whose filename matches. If your code does tricky things like using #include to include source files:
</p>
<pre><code>$ cat foo.c
#include "bar.c"
#include "baz.c"
...</code></pre>
<p>
	This will cause breakpoints in &ldquo;bar.c&rdquo; to be inlined into the compile unit for &ldquo;foo.c&rdquo;. If your code does this, or if your build system combines multiple files in some way such that breakpoints from one implementation file will be compiled into another implementation file, you will need to tell LLDB to always search for inlined breakpoint locations by adding the following line to your &tilde;/.lldbinit file:
</p>
<pre><code>$ echo "settings set target.inline-breakpoint-strategy always" &gt;&gt; ~/.lldbinit</code></pre>
<p>
	This tells LLDB to always look in all compile units and search for breakpoint locations by file and line even if the implementation file doesn&rsquo;t match. Setting breakpoints in header files always searches all compile units because inline functions are commonly defined in header files and often cause multiple breakpoints to have source line information that matches many header file paths.
</p>
<p>
	If you set a file and line breakpoint using a full path to the source file, like Xcode does when setting a breakpoint in its GUI on macOS when you click in the gutter of the source view, this path must match the full paths in the debug information. If the paths mismatch, possibly due to passing in a resolved source file path that doesn&rsquo;t match an unresolved path in the debug information, this can cause breakpoints to not be resolved. Try setting breakpoints using the file basename only.
</p>
<p>
	If you are using an IDE and you move your project in your file system and build again, sometimes doing a clean then build will solve the issue.This will fix the issue if some .o files didn&rsquo;t get rebuilt after the move as the .o files in the build folder might still contain stale debug information with the old source locations.
</p>
	<H3><a name="HEAD_b06aada3" href="#TOC_HEAD_b06aada3">2.14.2. How Do I Check If I Have Debug Symbols?</a></H3>
<p>
	Checking if a module has any compile units (source files) is a good way to check if there is debug information in a module:
</p>
<pre><code>(lldb) file /tmp/a.out
(lldb) image list
[  0] 71E5A649-8FEF-3887-9CED-D3EF8FC2FD6E 0x0000000100000000 /tmp/a.out
    /tmp/a.out.dSYM/Contents/Resources/DWARF/a.out
[  1] 6900F2BA-DB48-3B78-B668-58FC0CF6BCB8 0x00007fff5fc00000 /usr/lib/dyld
....
(lldb) script lldb.target.module['/tmp/a.out'].GetNumCompileUnits()
1
(lldb) script lldb.target.module['/usr/lib/dyld'].GetNumCompileUnits()
0</code></pre>
<p>
	Above we can see that &ldquo;/tmp/a.out&rdquo; does have a compile unit, and &ldquo;/usr/lib/dyld&rdquo; does not.
</p>
<p>
	We can also list the full paths to all compile units for a module using python:
</p>
<pre><code>(lldb) script
Python Interactive Interpreter. To exit, type 'quit()', 'exit()' or Ctrl-D.
&gt;&gt;&gt; m = lldb.target.module['a.out']
&gt;&gt;&gt; for i in range(m.GetNumCompileUnits()):
...   cu = m.GetCompileUnitAtIndex(i).file.fullpath
/tmp/main.c
/tmp/foo.c
/tmp/bar.c
&gt;&gt;&gt;</code></pre>
<p>
	This can help to show the actual full path to the source files. Sometimes IDEs will set breakpoints by full paths where the path doesn&rsquo;t match the full path in the debug info and this can cause LLDB to not resolve breakpoints. You can use the breakpoint list command with the –verbose option to see the full paths for any source file and line breakpoints that the IDE set using:
</p>
<pre><code>(lldb) breakpoint list --verbose</code></pre>
	<H2><a name="HEAD_4605f99" href="#TOC_HEAD_4605f99">2.15. Links</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_1648e9d5" href="#HEAD_1648e9d5">2.15.1. Blog Posts</a></li>
	<li><a name="TOC_HEAD_98b76778" href="#HEAD_98b76778">2.15.2. Videos &nbsp;<font color="red">@TODO</font></a></li>
	<li><a name="TOC_HEAD_3d6328a" href="#HEAD_3d6328a">2.15.3. Books &nbsp;<font color="red">@TODO</font></a></li>
	<li><a name="TOC_HEAD_af84834" href="#HEAD_af84834">2.15.4. Extensions &nbsp;<font color="red">@TODO</font></a></li>
</menu>

</div>
	<H3><a name="HEAD_1648e9d5" href="#TOC_HEAD_1648e9d5">2.15.1. Blog Posts</a></H3>
<ul>
	<li><a href="2014-11-22 Dancing in the Debugger - A Waltz with LLDB.html" target="_blank">Dancing in the Debugger &mdash; A Waltz with LLDB 2014</a></li>
	<br />
	<p>
		A high level overview of LLDB with a focus on debugging Objective&ndash;C code.
	</p>
</ul>
	<H3><a name="HEAD_98b76778" href="#TOC_HEAD_98b76778">2.15.2. Videos</a> <a name="MARK_5" href="#TOC_MARK_5"><strong><font color="red">@TODO</font></strong></a></H3><ul></ul>
	<H3><a name="HEAD_3d6328a" href="#TOC_HEAD_3d6328a">2.15.3. Books</a> <a name="MARK_6" href="#TOC_MARK_6"><strong><font color="red">@TODO</font></strong></a></H3><ul></ul>
	<H3><a name="HEAD_af84834" href="#TOC_HEAD_af84834">2.15.4. Extensions</a> <a name="MARK_7" href="#TOC_MARK_7"><strong><font color="red">@TODO</font></strong></a></H3><ul></ul>
	<H1><a name="HEAD_5603451b" href="#TOC_HEAD_5603451b">3. Development</a></H1>
	<H2><a name="HEAD_e6fc9f0" href="#TOC_HEAD_e6fc9f0">3.1. Testing</a> <a name="MARK_8" href="#TOC_MARK_8"><strong><font color="red">@TODO</font></strong></a></H2><ul></ul>
	<H2><a name="HEAD_42a860eb" href="#TOC_HEAD_42a860eb">3.2. Fuzzing LLDB</a> <a name="MARK_9" href="#TOC_MARK_9"><strong><font color="red">@TODO</font></strong></a></H2><ul></ul>
	<H1><a name="HEAD_79ceadde" href="#TOC_HEAD_79ceadde">4. Design</a></H1>
	<H2><a name="HEAD_23735199" href="#TOC_HEAD_23735199">4.1. Overview</a></H2>
﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
<menu>
	<li><a name="TOC_HEAD_fdfa" href="#HEAD_fdfa">4.1.1. API</a></li>
	<li><a name="TOC_HEAD_c570a011" href="#HEAD_c570a011">4.1.2. Breakpoint</a></li>
	<li><a name="TOC_HEAD_dff06ea8" href="#HEAD_dff06ea8">4.1.3. Commands</a></li>
	<li><a name="TOC_HEAD_2023bf" href="#HEAD_2023bf">4.1.4. Core</a></li>
	<li><a name="TOC_HEAD_59111833" href="#HEAD_59111833">4.1.5. Dataformatters</a></li>
	<li><a name="TOC_HEAD_bcd6eb8" href="#HEAD_bcd6eb8">4.1.6. Expression</a></li>
	<li><a name="TOC_HEAD_2269c8" href="#HEAD_2269c8">4.1.7. Host</a></li>
	<li><a name="TOC_HEAD_ebb9de5a" href="#HEAD_ebb9de5a">4.1.8. Interpreter</a></li>
	<li><a name="TOC_HEAD_947e61b8" href="#HEAD_947e61b8">4.1.9. Symbol</a></li>
	<li><a name="TOC_HEAD_94e35db1" href="#HEAD_94e35db1">4.1.10. Target</a></li>
	<li><a name="TOC_HEAD_5c5e294c" href="#HEAD_5c5e294c">4.1.11. Utility</a></li>
</menu>

</div>
<p>
	LLDB is a large and complex codebase. This section will help you become more familiar with the pieces that make up LLDB and give a general overview of the general architecture.
</p>
<p>
	LLDB has many code groupings that makeup the source base:
</p>
	<H3><a name="HEAD_fdfa" href="#TOC_HEAD_fdfa">4.1.1. API</a></H3>
<p>
	The API folder contains the public interface to LLDB.
</p>
<p>
	We are currently vending a C++ API. In order to be able to add methods to this API and allow people to link to our classes, we have certain rules that we must follow:
</p>
<ul>
	<li>Classes can&rsquo;t inherit from any other classes.</li>
	<li>Classes can&rsquo;t contain virtual methods.</li>
	<li>Classes should be compatible with script bridging utilities like swig.</li>
	<li>Classes should be lightweight and be backed by a single member. Pointers (or shared pointers) are the preferred choice since they allow changing the contents of the backend without affecting the public object layout.</li>
	<li>The interface should be as minimal as possible in order to give a complete API.</li>
	<br />
</ul>
<p>
	By adhering to these rules we should be able to continue to vend a C++ API, and make changes to the API as any additional methods added to these classes will just be a dynamic loader lookup and they won&rsquo;t affect the class layout (since they aren&rsquo;t virtual methods, and no members can be added to the class).
</p>
	<H3><a name="HEAD_c570a011" href="#TOC_HEAD_c570a011">4.1.2. Breakpoint</a></H3>
<p>
	A collection of classes that implement our breakpoint classes. Breakpoints are resolved symbolically and always continue to resolve themselves as your program runs. Whether settings breakpoints by file and line, by symbol name, by symbol regular expression, or by address, breakpoints will keep trying to resolve new locations each time shared libraries are loaded. Breakpoints will of course unresolve themselves when shared libraries are unloaded. Breakpoints can also be scoped to be set only in a specific shared library. By default, breakpoints can be set in any shared library and will continue to attempt to be resolved with each shared library load.
</p>
<p>
	Breakpoint options can be set on the breakpoint, or on the individual locations. This allows flexibility when dealing with breakpoints and allows us to do what the user wants.
</p>
	<H3><a name="HEAD_dff06ea8" href="#TOC_HEAD_dff06ea8">4.1.3. Commands</a></H3>
<p>
	The command source files represent objects that implement the functionality for all textual commands available in our command line interface.
</p>
<p>
	Every command is backed by a lldb_private::CommandObject or lldb_private::CommandObjectMultiword object.
</p>
<p>
	lldb_private::CommandObjectMultiword are commands that have subcommands and allow command line commands to be logically grouped into a hierarchy.
</p>
<p>
	lldb_private::CommandObject command line commands are the objects that implement the functionality of the command. They can optionally define options for themselves, as well as group those options into logical groups that can go together. The help system is tied into these objects and can extract the syntax and option groupings to display appropriate help for each command.
</p>
	<H3><a name="HEAD_2023bf" href="#TOC_HEAD_2023bf">4.1.4. Core</a></H3>
<p>
	The Core source files contain basic functionality that is required in the debugger as well as the class representing the debugger itself (Debugger). A wide variety of classes are implemented:
</p>
<ul>
	<li>Address (section offset addressing)</li>
	<li>AddressRange</li>
	<li>Broadcaster / Event / Listener</li>
	<li>Communication classes that use Connection objects</li>
	<li>Mangled names</li>
	<li>Source manager</li>
	<li>Value objects</li>
	<br />
</ul>
	<H3><a name="HEAD_59111833" href="#TOC_HEAD_59111833">4.1.5. Dataformatters</a></H3>
<p>
	A collection of classes that implement the data formatters subsystem.
</p>
<p>
	Data formatters provide a set of user&ndash;tweakable hooks in the ValueObjects world that allow to customize presentation aspects of variables. While users interact with formatters mostly through the type command, inside LLDB there are a few layers to the implementation: DataVisualization at the highest end of the spectrum, backed by classes implementing individual formatters, matching rules, etc.
</p>
<p>
	For a general user&ndash;level introduction to data formatters, you can look here.
</p>
<p>
	More details on the architecture are to be found here.
</p>
	<H3><a name="HEAD_bcd6eb8" href="#TOC_HEAD_bcd6eb8">4.1.6. Expression</a></H3>
<p>
	Expression parsing files cover everything from evaluating DWARF expressions, to evaluating expressions using Clang.
</p>
<p>
	The DWARF expression parser has been heavily modified to support type promotion, new opcodes needed for evaluating expressions with symbolic variable references (expression local variables, program variables), and other operators required by typical expressions such as assign, address of, float/double/long double floating point values, casting, and more. The DWARF expression parser uses a stack of lldb_private::Value objects. These objects know how to do the standard C type promotion, and allow for symbolic references to variables in the program and in the LLDB process (expression local and expression global variables).
</p>
<p>
	The expression parser uses a full instance of the Clang compiler in order to accurately evaluate expressions. Hooks have been put into Clang so that the compiler knows to ask about identifiers it doesn&rsquo;t know about. Once expressions have be compiled into an AST, we can then traverse this AST and either generate a DWARF expression that contains simple opcodes that can be quickly re&ndash;evaluated each time an expression needs to be evaluated, or JIT&rsquo;ed up into code that can be run on the process being debugged.
</p>
	<H3><a name="HEAD_2269c8" href="#TOC_HEAD_2269c8">4.1.7. Host</a></H3>
<p>
	LLDB tries to abstract itself from the host upon which it is currently running by providing a host abstraction layer. This layer includes functionality, whose implementation varies wildly from host to host.
</p>
<p>
	Host functionality includes abstraction layers for:
</p>
<ul>
	<li>Information about the host system (triple, list of running processes, etc.)</li>
	<li>Launching processes</li>
	<li>Various OS primitives like pipes and sockets</li>
	<br />
</ul>
<p>
	It also includes the base classes of the NativeProcess/Thread hierarchy, which is used by lldb&ndash;server.
</p>
	<H3><a name="HEAD_ebb9de5a" href="#TOC_HEAD_ebb9de5a">4.1.8. Interpreter</a></H3>
<p>
	The interpreter classes are the classes responsible for being the base classes needed for each command object, and is responsible for tracking and running command line commands.
</p>
	<H3><a name="HEAD_947e61b8" href="#TOC_HEAD_947e61b8">4.1.9. Symbol</a></H3>
<p>
	Symbol classes involve everything needed in order to parse object files and debug symbols. All the needed classes for compilation units (code and debug info for a source file), functions, lexical blocks within functions, inlined functions, types, declaration locations, and variables are in this section.
</p>
	<H3><a name="HEAD_94e35db1" href="#TOC_HEAD_94e35db1">4.1.10. Target</a></H3>
<p>
	Classes that are related to a debug target include:
</p>
<ul>
	<li>Target</li>
	<li>Process</li>
	<li>Thread</li>
	<li>Stack frames</li>
	<li>Stack frame registers</li>
	<li>ABI for function calling in process being debugged</li>
	<li>Execution context batons</li>
	<br />
</ul>
	<H3><a name="HEAD_5c5e294c" href="#TOC_HEAD_5c5e294c">4.1.11. Utility</a></H3>
<p>
	This module contains the lowest layers of LLDB. A lot of these classes don&rsquo;t really have anything to do with debugging – they are just there because the higher layers of the debugger use these classes to implement their functionality. Others are data structures used in many other parts of the debugger. Most of the functionality in this module could be useful in an application that is not a debugger; however, providing a general purpose C++ library is an explicit non&ndash;goal of this module..
</p>
<p>
	This module provides following functionality:
</p>
<ul>
	<li>Abstract path manipulation (FileSpec)</li>
	<li>Architecture specification</li>
	<li>Data buffers (DataBuffer, DataEncoder, DataExtractor)</li>
	<li>Logging</li>
	<li>Structured data manipulation (JSON)</li>
	<li>Streams</li>
	<li>Timers</li>
	<br />
</ul>
<p>
	For historic reasons, some of this functionality overlaps that which is provided by the LLVM support library.
</p>
	<H2><a name="HEAD_79a5c1ac" href="#TOC_HEAD_79a5c1ac">4.2. Scripting Bridge API</a> <a name="MARK_10" href="#TOC_MARK_10"><strong><font color="red">@TODO</font></strong></a></H2><ul></ul>
	<H1><a name="HEAD_404d5f2b" href="#TOC_HEAD_404d5f2b">5. Reference</a> <a name="MARK_11" href="#TOC_MARK_11"><strong><font color="red">@TODO</font></strong></a></H1><ul></ul>
  
        </div>
        <hr>
        <hr>
        <div class="col-xs-10">&copy; 2017-2023 Todd(<a href="mailto:to0d@outlook.com" target="_blank">to0d@outlook.com</a>) <br> &reg; UNI TOOL
        </div>

<canvas id="canvas" width="60" height="60"></canvas>
<script>
var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');
var imageObj = new Image();
imageObj.onload = function() {
var x = canvas.width / 2;
var y = canvas.height / 2;
var radius = 30;
context.save();
context.beginPath();
context.arc(x, y, radius, 0, Math.PI * 2, false);
context.closePath();
context.clip();
context.drawImage(imageObj, 0, 0, canvas.width, canvas.height);
context.beginPath();
context.arc(x, y, radius, 0, Math.PI * 2, false);
context.lineWidth = 5;
context.strokeStyle = '#fff';
context.stroke();
context.restore();
};
imageObj.src = 'files/fab8587d9b55e4b08731759f2be9288e.jpg';
</script>   
        
    </div>
    
    <div id="in-nav">
    <font size="2">
    <b><a href="#HEAD_todo"><font color="red">TODO: 11</font></a></b><br>﻿<div style="border:1px solid rgb(204,204,204); background-color:rgb(238,238,238); padding:4px 20px">
<!-- <p style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px;">
    <span style="float:left">Table of Contents</span>
</p>
<br> -->
	<b><a name="TOC_HEAD_50c8e2f9" href="#HEAD_50c8e2f9">1. Project</a></b><br>
	<menu>
		<li><a name="TOC_HEAD_f287485d" href="#HEAD_f287485d">1.1. Features</a></li>
		<li><a name="TOC_HEAD_9432bc12" href="#HEAD_9432bc12">1.2. Status</a></li>
	</menu>
	<b><a name="TOC_HEAD_5271ff6c" href="#HEAD_5271ff6c">2. Use &amp; Extension</a></b><br>
	<menu>
		<li><a name="TOC_HEAD_f5f8f7e" href="#HEAD_f5f8f7e">2.1. Tutorial</a></li>
		<li><a name="TOC_HEAD_c4c9054f" href="#HEAD_c4c9054f">2.2. GDB to LLDB command map</a></li>
		<li><a name="TOC_HEAD_e52bc31" href="#HEAD_e52bc31">2.3. Frame and Thread Format</a></li>
		<li><a name="TOC_HEAD_55277b89" href="#HEAD_55277b89">2.4. Variable Formatting</a></li>
		<li><a name="TOC_HEAD_5e860d63" href="#HEAD_5e860d63">2.5. Symbolication</a></li>
		<li><a name="TOC_HEAD_82fde2b7" href="#HEAD_82fde2b7">2.6. Symbols on macOS &nbsp;<font color="red">@TODO</font></a></li>
		<li><a name="TOC_HEAD_3efdd467" href="#HEAD_3efdd467">2.7. DWARF Extensions supported by LLDB </a></li>
		<li><a name="TOC_HEAD_93d664f3_0" href="#HEAD_93d664f3_0">2.8. Python Scripting</a></li>
		<li><a name="TOC_HEAD_4dcb9507" href="#HEAD_4dcb9507">2.9. Python Reference &nbsp;<font color="red">@TODO</font></a></li>
		<li><a name="TOC_HEAD_7a19ff94" href="#HEAD_7a19ff94">2.10. Remote Debugging</a></li>
		<li><a name="TOC_HEAD_77a9260a" href="#HEAD_77a9260a">2.11. Testing LLDB using QEMU  &nbsp;<font color="red">@TODO</font></a></li>
		<li><a name="TOC_HEAD_27cccef1" href="#HEAD_27cccef1">2.12. Tracing with Intel Processor Trace </a></li>
		<li><a name="TOC_HEAD_b029cd47" href="#HEAD_b029cd47">2.13. On Demand Symbols </a></li>
		<li><a name="TOC_HEAD_78b6aa3a" href="#HEAD_78b6aa3a">2.14. Troubleshooting</a></li>
		<li><a name="TOC_HEAD_4605f99" href="#HEAD_4605f99">2.15. Links</a></li>
	</menu>
	<b><a name="TOC_HEAD_5603451b" href="#HEAD_5603451b">3. Development</a></b><br>
	<menu>
		<li><a name="TOC_HEAD_e6fc9f0" href="#HEAD_e6fc9f0">3.1. Testing &nbsp;<font color="red">@TODO</font></a></li>
		<li><a name="TOC_HEAD_42a860eb" href="#HEAD_42a860eb">3.2. Fuzzing LLDB &nbsp;<font color="red">@TODO</font></a></li>
	</menu>
	<b><a name="TOC_HEAD_79ceadde" href="#HEAD_79ceadde">4. Design</a></b><br>
	<menu>
		<li><a name="TOC_HEAD_23735199" href="#HEAD_23735199">4.1. Overview</a></li>
		<li><a name="TOC_HEAD_79a5c1ac" href="#HEAD_79a5c1ac">4.2. Scripting Bridge API &nbsp;<font color="red">@TODO</font></a></li>
	</menu>
	<b><a name="TOC_HEAD_404d5f2b" href="#HEAD_404d5f2b">5. Reference &nbsp;<font color="red">@TODO</font></a></b><br>

</div>

    </font>
    
    </div>
    

<script src="js/jquery-2.js"></script>
<script src="js/bootstrap.js"></script>
<script language="javascript" src="js/note-toggle.js"></script>
<script language="javascript" src="js/note-open.js"></script>
</body>
</html>

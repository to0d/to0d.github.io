<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>MLIR入门教程 hunterzju 知乎</title></head>
<body>
	<div class="header"><h1>MLIR入门教程 hunterzju 知乎</h1></div>
	<div><ul>
		<li><b><a name="TOC_HEAD_0" href="#HEAD_0">MLIR入门教程1 Toy语言以及AST 知乎</a></b><br>
		<li><b><a name="TOC_HEAD_1" href="#HEAD_1">MLIR入门教程2 基本MLIR表示 知乎</a></b><br>
		<li><b><a name="TOC_HEAD_2" href="#HEAD_2">MLIR入门教程3 高级语言转换到MLIR 知乎</a></b><br>
		<li><b><a name="TOC_HEAD_3" href="#HEAD_3">MLIR入门教程4 dialect和operation接口 知乎</a></b><br>
		<li><b><a name="TOC_HEAD_4" href="#HEAD_4">MLIR入门教程5 降级到低级方言 知乎</a></b><br>
		<li><b><a name="TOC_HEAD_5" href="#HEAD_5">MLIR入门教程6 降低到LLVM并生成代码 知乎</a></b><br>
		<li><b><a name="TOC_HEAD_6" href="#HEAD_6">MLIR入门教程7 添加struct类型 知乎</a></b><br>
	</ul></div>

		<hr/>
		<H2><a name="HEAD_0" href="#TOC_HEAD_0">MLIR入门教程1 Toy语言以及AST 知乎</a></H2>
		<div>
<!-- AutoExtract Begin-->
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Wed Oct 18 21:38:15 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/435829694" target="_blank">
				<font color="red" size="3">MLIR入门教程1&ndash;Toy语言以及AST&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<p data-first-child data-pid="xoCVZbhX">上周初步完成了LLVM入门教程的翻译，这几天了解了下LLVM项目中的MLIR架构，整体感觉MLIR目的是在高层语言转换到机器码的过程中能够重用更多的优化，核心思想是采用了多层IR，并定义了IR间相互转换的框架。本系列文章将对LLVM项目中的MLIR教程进行翻译。</p>
			<blockquote data-pid="mWSdP_AT">受限于笔者个人的认知水平，翻译效果可能不是很理想，翻译原始文档也会放在github上，供大家参考，如发现问题也欢迎提PR或者Issue:</blockquote>
			<a target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/hunterzju/llvm-tutorial.git" data-draft-node="block" data-draft-type="link-card" data-text="https://github.com/hunterzju/llvm-tutorial.git" class="LinkCard new">
				<span class="LinkCard-contents">
					<span class="LinkCard-title loading" data-text="true"></span>
					<span class="LinkCard-desc loading"></span>
				</span>
				<span class="LinkCard-image LinkCard-image--default"></span>
			</a>
			<h2>Toy教程</h2>
			<p data-pid="Lk8_2UOo">本教程基于MLIR构建了一中基础的Toy语言实现。本教程的目标是介绍MLIR的概念；特别是
				<a href="../LangRef.md#dialects" class="internal">方言(dialects)</a>
				如何帮助轻松支持特定于语言的构造和转换，同时仍然提供一条降低到LLVM或其他代码生成(codegen)基础设施的简单途径。本教程基于
				<a href="https://link.zhihu.com/?target=https%3A//llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">LLVM&nbsp;Kaleidoscope&nbsp;Tutorial</a>
				的模型
			</p>
			<p data-pid="bnOpL5KG">本教程假定您已经克隆并构建了MLIR；如果您还没有这样做，请参阅
				<a href="https://link.zhihu.com/?target=https%3A//mlir.llvm.org/getting_started/" class=" wrap external" target="_blank" rel="nofollow noreferrer">MLIR入门</a>
				.
			</p>
			<p data-pid="Pfi6LBnP">本教程分为以下几章：</p>
			<ul>
				<li data-pid="JmQmb0YR">
					<a href="zh-Ch-1.md" class="internal">第1章</a>
					：Toy语言简介及其AST的定义。
				</li>
				<li data-pid="cRxPcOSj">
					<a href="zh-Ch-2.md" class="internal">第2章</a>
					：遍历AST以发出MLIR中的方言，介绍基本的MLIR概念。这里我们展示了如何开始将语义附加到MLIR中的自定义操作。
				</li>
				<li data-pid="AMLELQYW">
					<a href="zh-Ch-3.md" class="internal">第3章</a>
					：使用模式重写系统的高级语言特定优化。
				</li>
				<li data-pid="cn5o7lnS">
					<a href="zh-Ch-4.md" class="internal">第4章</a>
					：使用接口编写与通用方言无关的转换。在这里，我们将展示如何将特定的方言信息插入到通用转换中，如维度推断和内联。
				</li>
				<li data-pid="PN_R_N-Z">
					<a href="zh-Ch-5.md" class="internal">第5章</a>
					：部分降低到较低级别的方言。为了优化，我们将把一些高级语言特定语义转换为面向仿射的通用方言。
				</li>
				<li data-pid="-TV1_YXm">
					<a href="zh-Ch-6.md" class="internal">第6章</a>
					：降低到LLVM和代码生成。在这里，我们将把LLVM&nbsp;IR作为代码生成的目标，并详细介绍降低框架的更多内容。
				</li>
				<li data-pid="JqwAgGkF">
					<a href="zh-Ch-7.md" class="internal">第7章</a>
					：扩展Toy：添加对复合类型的支持。我们将演示如何将自定义类型添加到MLIR，以及它如何适应现有流程。
				</li>
			</ul>
			<p data-pid="5KF2vbp1">
				<a href="zh-Ch-1.md" class="internal">第一章</a>
				将介绍Toy语言和AST。
			</p>
			<h2>第1章：玩具语言和AST</h2>
			<h2>语言</h2>
			<p data-pid="B_1ttd-E">本教程将用一种简单语言来说明，我们称之为&ldquo;玩具&rdquo;(命名很难&hellip;&hellip;)。Toy是一种基于张量的语言，允许您定义函数、执行一些数学计算和打印结果。</p>
			<p data-pid="wTbRLm2J">考虑到我们希望保持简单，编码生成将被限制为秩&lt;=2的张量，并且Toy中唯一的数据类型是64位浮点类型(在C中也称为&ldquo;DOUBLE&rdquo;)。因此，所有值都是隐式双精度的，&lsquo;Values`是不可变的(即，每个操作都返回一个新分配的值)，并且释放是自动管理的。但长篇大论已经足够了；没有什么比通过一个例子来更好地理解更好的了：</p>
			<div class="highlight">
				<pre>
<code class="language-text">def main() {
  # Define a variable `a` with shape &lt;2, 3&gt;, initialized with the literal value.
  # The shape is inferred from the supplied literal.
  var a = [[1, 2, 3], [4, 5, 6]];

  # b is identical to a, the literal tensor is implicitly reshaped: defining new
  # variables is the way to reshape tensors (element count must match).
  var b&lt;2, 3&gt; = [1, 2, 3, 4, 5, 6];

  # transpose() and print() are the only builtin, the following will transpose
  # a and b and perform an element-wise multiplication before printing the result.
  print(transpose(a) * transpose(b));
}</code>
				</pre>
			</div>
			<p data-pid="2H2kAhbc">类型检查是通过类型推断静态执行的；该语言仅在需要时要求类型声明来指定张量形状。函数是通用的：它们的参数是为无秩的(换句话说，我们知道这些是张量，但我们不知道它们的维数)。它们专门用于调用点的每个新发现的签名。让我们通过添加一个用户定义函数来回顾上一个示例：</p>
			<div class="highlight">
				<pre>
<code class="language-text"># User defined generic function that operates on unknown shaped arguments.
def multiply_transpose(a, b) {
  return transpose(a) * transpose(b);
}

def main() {
  # Define a variable `a` with shape &lt;2, 3&gt;, initialized with the literal value.
  var a = [[1, 2, 3], [4, 5, 6]];
  var b&lt;2, 3&gt; = [1, 2, 3, 4, 5, 6];

  # This call will specialize `multiply_transpose` with &lt;2, 3&gt; for both
  # arguments and deduce a return type of &lt;3, 2&gt; in initialization of `c`.
  var c = multiply_transpose(a, b);

  # A second call to `multiply_transpose` with &lt;2, 3&gt; for both arguments will
  # reuse the previously specialized and inferred version and return &lt;3, 2&gt;.
  var d = multiply_transpose(b, a);

  # A new call with &lt;3, 2&gt; (instead of &lt;2, 3&gt;) for both dimensions will
  # trigger another specialization of `multiply_transpose`.
  var e = multiply_transpose(c, d);

  # Finally, calling into `multiply_transpose` with incompatible shape will
  # trigger a shape inference error.
  var f = multiply_transpose(transpose(a), c);
}</code>
				</pre>
			</div>
			<h2>抽象语法树AST</h2>
			<p data-pid="15vu_z7-">上面代码中的AST相当简单；下面是它的一个转储：</p>
			<div class="highlight">
				<pre>
<code class="language-text">Module:
  Function 
    Proto &#39;multiply_transpose&#39; @test/Examples/Toy/Ch1/ast.toy:4:1&#39;
    Params: [a, b]
    Block {
      Return
        BinOp: * @test/Examples/Toy/Ch1/ast.toy:5:25
          Call &#39;transpose&#39; [ @test/Examples/Toy/Ch1/ast.toy:5:10
            var: a @test/Examples/Toy/Ch1/ast.toy:5:20
          ]
          Call &#39;transpose&#39; [ @test/Examples/Toy/Ch1/ast.toy:5:25
            var: b @test/Examples/Toy/Ch1/ast.toy:5:35
          ]
    } // Block
  Function 
    Proto &#39;main&#39; @test/Examples/Toy/Ch1/ast.toy:8:1&#39;
    Params: []
    Block {
      VarDecl a&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:11:3
        Literal: &lt;2, 3&gt;[ &lt;3&gt;[ 1.000000e+00, 2.000000e+00, 3.000000e+00], &lt;3&gt;[ 4.000000e+00, 5.000000e+00, 6.000000e+00]] @test/Examples/Toy/Ch1/ast.toy:11:11
      VarDecl b&lt;2, 3&gt; @test/Examples/Toy/Ch1/ast.toy:15:3
        Literal: &lt;6&gt;[ 1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00] @test/Examples/Toy/Ch1/ast.toy:15:17
      VarDecl c&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:19:3
        Call &#39;multiply_transpose&#39; [ @test/Examples/Toy/Ch1/ast.toy:19:11
          var: a @test/Examples/Toy/Ch1/ast.toy:19:30
          var: b @test/Examples/Toy/Ch1/ast.toy:19:33
        ]
      VarDecl d&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:22:3
        Call &#39;multiply_transpose&#39; [ @test/Examples/Toy/Ch1/ast.toy:22:11
          var: b @test/Examples/Toy/Ch1/ast.toy:22:30
          var: a @test/Examples/Toy/Ch1/ast.toy:22:33
        ]
      VarDecl e&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:25:3
        Call &#39;multiply_transpose&#39; [ @test/Examples/Toy/Ch1/ast.toy:25:11
          var: b @test/Examples/Toy/Ch1/ast.toy:25:30
          var: c @test/Examples/Toy/Ch1/ast.toy:25:33
        ]
      VarDecl f&lt;&gt; @test/Examples/Toy/Ch1/ast.toy:28:3
        Call &#39;multiply_transpose&#39; [ @test/Examples/Toy/Ch1/ast.toy:28:11
          Call &#39;transpose&#39; [ @test/Examples/Toy/Ch1/ast.toy:28:30
            var: a @test/Examples/Toy/Ch1/ast.toy:28:40
          ]
          var: c @test/Examples/Toy/Ch1/ast.toy:28:44
        ]
    } // Block</code>
				</pre>
			</div>
			<p data-pid="KS-hcJjS">您在
				<code>Examples/Toy/Ch1/</code>
				目录中使用示例重现此结果；尝试运行
				<code>path/to/build/bin/toyc&ndash;ch1test/Examples/Toy/Ch1/ast.toy&nbsp;&ndash;emit=ast</code>
				。
			</p>
			<p data-pid="Xa8iFEQC">lexer的代码相当简单；所有代码都在一个头文件中：
				<code>Examples/Toy/Ch1/Include/Toy/Lexfor.h</code>
				。解析器可以在
				<code>Examples/Toy/ch1/include/toy/Parser.h</code>
				中找到，它是一个递归下降解析器。如果您不熟悉这样的词法分析器/解析器，它们与
				<a href="https://link.zhihu.com/?target=https%3A//llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Kaleidcope&nbsp;Tutorial</a>
				的前两章中详细介绍的LLVM&nbsp;Kaleidoscope非常相似.
			</p>
			<p data-pid="pIDAnuNg">
				<a href="zh-Ch-2.md" class="internal">下一章</a>
				将演示如何将此AST转换为MLIR。
			</p>
		</div>
	<!-- AutoExtract End-->
		</div>

		<hr/>
		<H2><a name="HEAD_1" href="#TOC_HEAD_1">MLIR入门教程2 基本MLIR表示 知乎</a></H2>
		<div>
<!-- AutoExtract Begin-->
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Wed Oct 18 21:38:55 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/436013600" target="_blank">
				<font color="red" size="3">MLIR入门教程2&ndash;基本MLIR表示&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<blockquote data-first-child data-pid="Wc2mclfJ">本文翻译自MLIR社区官方文档，受限于笔者个人的认知水平，翻译效果可能不是很理想，翻译原始文档也会放在github上，供大家参考，如发现问题也欢迎提PR或者Issue:</blockquote>
			<a target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/hunterzju/llvm-tutorial" data-draft-node="block" data-draft-type="link-card" data-text="https://github.com/hunterzju/llvm-tutorial" class="LinkCard new">
				<span class="LinkCard-contents">
					<span class="LinkCard-title loading" data-text="true"></span>
					<span class="LinkCard-desc loading"></span>
				</span>
				<span class="LinkCard-image LinkCard-image--default"></span>
			</a>
			<h2>第2章：发射基本MLIR</h2>
			<p data-pid="lbTD2r3P">现在我们已经熟悉了我们的语言和AST，让我们看看MLIR如何帮助编译Toy。</p>
			<h2>简介：多级中间表示法</h2>
			<p data-pid="ozLlVmY0">其他编译器，如llvm(参见
				<a href="https://link.zhihu.com/?target=https%3A//llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Kaleidcope&nbsp;tutorial</a>
				)，])提供了一组固定的预定义类型和(通常是
				<i>低级</i>
				/risc&ndash;like)指令。在发出LLVM&nbsp;IR之前，由给定语言的前端执行任何特定于语言的类型检查、分析或转换。例如，Clang将不但使用其AST执行静态分析，还执行转换，例如通过AST克隆和重写进行C++模板实例化。最后，具有比C/C++更高级别结构的语言可能需要从其AST降低很多，才能生成LLVM&nbsp;IR。
			</p>
			<p data-pid="YQ19076Y">因此，多个前端最终重新实现重要的基础设施，以支持这些分析和转换的需求。MLIR通过为可扩展性而设计，从而解决了这个问题。因此，预定义的指令(MLIR术语中的
				<i>operations</i>
				)或类型很少。
			</p>
			<h2>与MLIR接口</h2>
			<p data-pid="UsHxT-lF">
				<a href="../LangRef.md" class="internal">语言参考</a>
			</p>
			<p data-pid="xf2MezQq">MLIR被设计为一个完全可扩展的基础设施；没有封闭的属性集(想一想：常量元数据)、操作或类型。MLIR通过
				<a href="../LangRef.md#Dialects" class="internal">方言(Dialects)</a>
				的概念支持这种可扩展性。方言提供了一种分组机制，用于在唯一的&ldquo;命名空间&rdquo;下进行抽象。
			</p>
			<p data-pid="rHW1eKfq">在MLIR中，
				<code>
					<a href="../LangRef.md#Operations" class="internal">Operations</a>
				</code>
				是抽象和计算的核心单元，在很多方面类似于LLVM指令。操作可以具有特定于应用程序的语义，并且可以用来表示LLVM中的所有核心IR结构：指令、全局变量(如函数)、模块等。
			</p>
			<p data-pid="fnYfP3V-">以下是toy
				<code>transspose</code>
				操作的MLIR程序集：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">%t_tensor = &#34;toy.transpose&#34;(%tensor) {inplace = true} : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt; loc(&#34;example/file/path&#34;:12:1)</code>
				</pre>
			</div>
			<p data-pid="RlkgIL5P">让我们来剖析一下这个MLIR操作：</p>
			<ul>
				<li data-pid="Lp9UZjRQ">
					<code>%t_tensor</code>
				</li>
				<li data-pid="aidVkVbi">为此操作定义的结果指定的名称(包括
					<a href="../LangRef.md#identifiers-and-keywords" class="internal">前缀符号以避免碰撞collisions</a>
					)。一个操作可以定义零个或多个结果(在Toy的上下文中，我们将自己限制为单结果操作)，它们是SSA值。该名称在解析期间使用，但不是持久的(例如，在SSA值的内存表示中不跟踪该名称)。
				</li>
				<li data-pid="lKejJ4li">
					<code>&#34;toy.transpose&#34;</code>
				</li>
				<li data-pid="3HWSIY62">操作的名称。它应该是唯一的字符串，在&ldquo;
					<code>.</code>
					&rdquo;之前加上方言的命名空间。这可以理解为
					<code>toy</code>
					方言中的
					<code>transspose</code>
					操作。
				</li>
				<li data-pid="hZXzOJUq">
					<code>(%tensor)</code>
				</li>
				<li data-pid="tYMFuzCQ">零个或多个输入操作数(或参数)的列表，它们是由其他操作定义或指向Block参数的SSA值。</li>
				<li data-pid="le57tc9m">
					<code>{inplace=true}</code>
				</li>
				<li data-pid="Erp8BgU4">一种包含零个或多个属性的字典，这些属性是始终恒定的特殊操作数。在这里，我们定义了一个名为&lsquo;inplace&rsquo;的布尔属性，该属性的常量值为true。</li>
				<li data-pid="uCZEOYTt">
					<code>(tensor&lt;2x3xf64&gt;)&nbsp;&ndash;&gt;&nbsp;tensor&lt;3x2xf64&gt;</code>
				</li>
				<li data-pid="r1LyIJ_e">这指的是函数形式中的操作类型，即括号中的参数类型和随后返回值的类型。</li>
				<li data-pid="B-tb2zA2">
					<code>loc(&#34;example/file/path&#34;:12:1)</code>
				</li>
				<li data-pid="kEsQbAEW">这是源代码中发起此操作的位置。</li>
			</ul>
			<p data-pid="SdlJqbUp">这里显示的是操作的一般形式。如上所述，MLIR中的操作集是可扩展的。使用一小组概念对操作进行建模，从而能够对操作进行一般的推理和操作。这些概念是：</p>
			<ul>
				<li data-pid="7Axaq7tR">操作的名称。</li>
				<li data-pid="IhXG9xsc">SSA操作数值的列表。</li>
				<li data-pid="XtVCy88n">属性列表
					<a href="../LangRef.md#attributes" class="internal">attributes</a>
					。
				</li>
				<li data-pid="33g8DYNq">结果值的
					<a href="../LangRef.md#type-system" class="internal">类型</a>
					列表。
				</li>
				<li data-pid="rDgbONml">用于调试目的的
					<a href="../Diagnostics.md#source-locations" class="internal">源码位置</a>
					。
				</li>
				<li data-pid="iMj2kV-d">后继
					<a href="../LangRef.md#%E5%9D%97" class="internal">块</a>
					列表(主要用于分支)。
				</li>
				<li data-pid="ic5Mak26">区域
					<a href="../LangRef.md#Regions" class="internal">Regions</a>
					列表(用于函数等结构化操作)。
				</li>
			</ul>
			<p data-pid="sXvoUsmZ">在MLIR中，每个操作都有一个与之关联的必需的源码位置。这与LLVM相反，在LLVM中，调试信息源码位置是元数据，可以删除，而在MLIR中，位置是核心需求，API依赖并操作它。因此，丢弃位置是一种显示的选择，不能误删。</p>
			<p data-pid="Y01tj2cF">举例说明：如果转换将一个操作替换为另一个操作，则该新操作必须仍附加有位置。这使得追踪操作的来源成为可能。</p>
			<p data-pid="X8g0X3VJ">值得注意的是，mlir&ndash;opt工具&ndash;用于测试编译器通道的工具&ndash;默认情况下不包括输出中的位置。
				<code>&ndash;mlir&ndash;print&ndash;debuginfo</code>
				标志指定包含位置。(更多选项请运行
				<code>mlir&ndash;opt&nbsp;&ndash;&ndash;help</code>
				。)
			</p>
			<h3>Opaque&nbsp;API</h3>
			<p data-pid="yunQmBQU">MLIR旨在允许自定义大多数IR元素，如属性、操作和类型。同时，IR元素始终可以归结为上述基本概念。这使得对于
				<i>任何</i>
				操作，允许MLIR解析、表示和
				<a href="getting_started/Glossary.md#round-trip" class="internal">round&ndash;trip</a>
				IR。例如，我们可以将上面的Toy操作放到一个
				<code>.mlir</code>
				文件中，并在
				<i>mlir&ndash;opt</i>
				中遍历，而无需注册任何方言：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @toy_func(%tensor: tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt; {
  %t_tensor = &#34;toy.transpose&#34;(%tensor) { inplace = true } : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;
  return %t_tensor : tensor&lt;3x2xf64&gt;
}</code>
				</pre>
			</div>
			<p data-pid="jM0N1U64">对于未注册的属性、操作和类型，MLIR将强制执行一些结构约束(ssa、Block终止等)，但在其他情况下，它们是完全不透明的。例如，MLIR几乎没有关于未注册操作是否可以操作特定数据类型、可以接受多少操作数或产生多少结果的信息。这种灵活性对于引导目的（bootstrapping&nbsp;purposes）很有用，但在成熟的系统中通常不建议这样做。未注册的操作必须通过转换和分析保守地对待，而且它们更难构造和操作。</p>
			<p data-pid="el-PjZ9w">这种情况可以通过为Toy构造无效的IR，并在不触发验证器的情况下在round&nbsp;trip中查看它来验证：</p>
			<div class="highlight">
				<pre><code class="language-text">func @main() {
  %0 = &#34;toy.print&#34;() : () -&gt; tensor&lt;2x3xf64&gt;
}</code></pre>
			</div>
			<p data-pid="s4bWfn9L">这里有多个问题：
				<code>toy.print</code>
				操作不是终止符；它应该接受一个操作数；并且它不应该返回任何值。在下一节中，我们将使用MLIR注册我们的方言和操作，插入验证器，并添加更好的API来操作我们的operations。
			</p>
			<h2>定义toy方言</h2>
			<p data-pid="bXE0Owtl">为了有效地与MLIR交互，我们将定义一个新的toy方言。这种方言将模拟toy语言的结构，并为高级分析和转换提供一条简单的途径。</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// This is the definition of the Toy dialect. A dialect inherits from
</span><span class="c1">/// mlir::Dialect and registers custom attributes, operations, and types (in its
</span><span class="c1">/// constructor). It can also override virtual methods to change some general
</span><span class="c1">/// behavior, which will be demonstrated in later chapters of the tutorial.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">ToyDialect</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">ToyDialect</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

  <span class="c1">/// Provide a utility accessor to the dialect namespace. This is used by
</span><span class="c1"></span>  <span class="c1">/// several utilities.
</span><span class="c1"></span>  <span class="k">static</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span> <span class="n">getDialectNamespace</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;toy&#34;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="cm3GaO9W">现在可以在全局注册表中注册该方言：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">mlir</span><span class="o">::</span><span class="n">registerDialect</span><span class="o">&lt;</span><span class="n">ToyDialect</span><span class="o">&gt;</span><span class="p">();</span>
</code>
				</pre>
			</div>
			<p data-pid="CQi8t17J">从现在开始创建的任何新的
				<code>MLIRContext</code>
				都将包含toy方言的一个实例，并调用特定的钩子hooks来解析属性和类型。
			</p>
			<h2>定义toy操作</h2>
			<p data-pid="5wZbqAd5">既然我们有了
				<code>toy&nbsp;dialect</code>
				，我们就可以开始注册操作了。这将允许提供语义信息给剩余系统调用。下面我们来介绍一下
				<code>toy.constant</code>
				操作的创建过程：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">%4 = &#34;toy.constant&#34;() {value = dense&lt;1.0&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;</code>
				</pre>
			</div>
			<p data-pid="5cOEKJw6">该操作的操作数为零，
				<a href="../LangRef.md#dense-elements-attribute" class="internal">dense&nbsp;elements</a>
				属性名为
				<code>value</code>
				，返回
				<a href="../LangRef.md#tensor-type" class="internal">TensorType</a>
				的单个结果。操作继承自
				<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Curiously_recurring_template_pattern" class=" wrap external" target="_blank" rel="nofollow noreferrer">CRTP</a>
				<code>mlir：：op</code>
				类，该类还需要一些可选的
				<a href="../Traits.md" class="internal">特性Traits</a>
				来自定义其行为。这些特征可以提供额外的访问器、验证等功能。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="k">class</span> <span class="nc">ConstantOp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Op</span><span class="o">&lt;</span><span class="n">ConstantOp</span><span class="p">,</span>
                     <span class="c1">/// The ConstantOp takes no inputs.
</span><span class="c1"></span>                     <span class="n">mlir</span><span class="o">::</span><span class="n">OpTrait</span><span class="o">::</span><span class="n">ZeroOperands</span><span class="p">,</span>
                     <span class="c1">/// The ConstantOp returns a single result.
</span><span class="c1"></span>                     <span class="n">mlir</span><span class="o">::</span><span class="n">OpTrait</span><span class="o">::</span><span class="n">OneResult</span><span class="p">,</span>
                     <span class="c1">/// The result of getType is `Type`.
</span><span class="c1"></span>                     <span class="n">mlir</span><span class="o">::</span><span class="n">OpTraits</span><span class="o">::</span><span class="n">OneTypedResult</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;::</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="p">{</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">/// Inherit the constructors from the base Op class.
</span><span class="c1"></span>  <span class="k">using</span> <span class="n">Op</span><span class="o">::</span><span class="n">Op</span><span class="p">;</span>

  <span class="c1">/// Provide the unique name for this operation. MLIR will use this to register
</span><span class="c1"></span>  <span class="c1">/// the operation and uniquely identify it throughout the system.
</span><span class="c1"></span>  <span class="k">static</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span> <span class="n">getOperationName</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;toy.constant&#34;</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">/// Return the value of the constant by fetching it from the attribute.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">DenseElementsAttr</span> <span class="n">getValue</span><span class="p">();</span>

  <span class="c1">/// Operations can provide additional verification beyond the traits they
</span><span class="c1"></span>  <span class="c1">/// define. Here we will ensure that the specific invariants of the constant
</span><span class="c1"></span>  <span class="c1">/// operation are upheld, for example the result type must be of TensorType.
</span><span class="c1"></span>  <span class="n">LogicalResult</span> <span class="nf">verify</span><span class="p">();</span>

  <span class="c1">/// Provide an interface to build this operation from a set of input values.
</span><span class="c1"></span>  <span class="c1">/// This interface is used by the builder to allow for easily generating
</span><span class="c1"></span>  <span class="c1">/// instances of this operation:
</span><span class="c1"></span>  <span class="c1">///   mlir::OpBuilder::create&lt;ConstantOp&gt;(...)
</span><span class="c1"></span>  <span class="c1">/// This method populates the given `state` that MLIR uses to create
</span><span class="c1"></span>  <span class="c1">/// operations. This state is a collection of all of the discrete elements
</span><span class="c1"></span>  <span class="c1">/// that an operation may contain.
</span><span class="c1"></span>  <span class="c1">/// Build a constant with the given return type and `value` attribute.
</span><span class="c1"></span>  <span class="k">static</span> <span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
                    <span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">result</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">DenseElementsAttr</span> <span class="n">value</span><span class="p">);</span>
  <span class="c1">/// Build a constant and reuse the type from the given &#39;value&#39;.
</span><span class="c1"></span>  <span class="k">static</span> <span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
                    <span class="n">mlir</span><span class="o">::</span><span class="n">DenseElementsAttr</span> <span class="n">value</span><span class="p">);</span>
  <span class="c1">/// Build a constant by broadcasting the given &#39;value&#39;.
</span><span class="c1"></span>  <span class="k">static</span> <span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
                    <span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="rR3r9Y_P">并且我们在
				<code>Toy&nbsp;Dialect</code>
				构造函数中注册此操作：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">ToyDialect</span><span class="o">::</span><span class="n">ToyDialect</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span><span class="p">(</span><span class="n">getDialectNamespace</span><span class="p">(),</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">addOperations</span><span class="o">&lt;</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<h3>Op&nbsp;VS&nbsp;Operation：使用MLIR操作</h3>
			<p data-pid="X8mjuXYF">既然我们已经定义了一个操作，我们将需要访问和转换它。在MLIR中，与操作相关的类主要有两个：
				<code>Operation</code>
				和
				<code>Op</code>
				。
				<code>Operation</code>
				类用于对所有操作进行通用建模。它是&ldquo;不透明的&rdquo;，因为它没有描述特定操作或操作类型的属性。相反，&ldquo;Operation&rdquo;类为操作实例提供了一个通用API。另一方面，每种特定类型的操作都由一个
				<code>Op</code>
				派生类表示。例如，
				<code>ConstantOp</code>
				表示零输入、一输出的操作，始终设置为相同的值。
				<code>Op</code>
				派生类充当
				<code>operation*</code>
				的智能指针包装器，提供特定于操作的访问器方法，以及操作的类型安全属性。这意味着当我们定义toy操作时，我们只是定义了一个干净的、语义上有用的接口，用于构建
				<code>Operation</code>
				类并与其交互。这就是为什么我们的
				<code>ConstantOp</code>
				没有定义类字段；所有的数据结构都存储在引用的
				<code>Operation</code>
				中。一个副作用是，我们总是通过值传递
				<code>Op</code>
				派生类，而不是通过引用或指针(
				<i>按值传递</i>
				是一种常见的习惯用法，类似于属性、类型等)。给定一个通用的
				<code>operation*</code>
				实例，我们始终可以使用LLVM的强制转换基础设施获取具体的
				<code>Op</code>
				实例：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="kt">void</span> <span class="nf">processConstantOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span> <span class="o">*</span><span class="n">operation</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ConstantOp</span> <span class="n">op</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">operation</span><span class="p">);</span>

  <span class="c1">// This operation is not an instance of `ConstantOp`.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Get the internal operation instance wrapped by the smart pointer.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span> <span class="o">*</span><span class="n">internalOperation</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">getOperation</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">internalOperation</span> <span class="o">==</span> <span class="n">operation</span> <span class="o">&amp;&amp;</span>
         <span class="s">&#34;these operation instances are the same&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<h3>使用操作定义规范(ODS)框架</h3>
			<p data-pid="5eYD99Jl">MLIR除了专门化
				<code>mlir：：op</code>
				C++模板外，还支持声明式定义操作。这是通过
				<a href="../OpDefinitions.md" class="internal">操作定义规范</a>
				框架实现的。关于操作的事实被简明地指定到TableGen记录中，该记录将在编译时展开为等效的
				<code>mlir：：Op</code>
				专用C++模板。考虑到面对C++API更改时的简洁性、简明性和一般稳定性，使用ODS框架是在MLIR中定义操作的理想方式。
			</p>
			<p data-pid="hbM8zp2E">让我们看看如何定义ConstantOp的ODS等效项：</p>
			<p data-pid="Zo2420Jq">要做的第一件事是定义一个指向我们用C++定义的toy方言的链接。它用于将我们将定义的所有操作链接到我们的方言：</p>
			<div class="highlight">
				<pre>
<code class="language-text">// Provide a definition of the &#39;toy&#39; dialect in the ODS framework so that we
// can define our operations.
def Toy_Dialect : Dialect {
  // The namespace of our dialect, this corresponds 1-1 with the string we
  // provided in `ToyDialect::getDialectNamespace`.
  let name = &#34;toy&#34;;

  // The C++ namespace that the dialect class definition resides in.
  let cppNamespace = &#34;toy&#34;;
}</code>
				</pre>
			</div>
			<p data-pid="j3ArtJX6">现在我们已经定义了到toy方言的链接，我们可以开始定义操作了。ODS中的操作是通过继承
				<code>Op</code>
				类来定义的。为了简化我们的操作定义，我们将用toy方言为操作定义一个基类。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">// Base class for toy dialect operations. This operation inherits from the base
// `Op` class in OpBase.td, and provides:
//   * The parent dialect of the operation.
//   * The mnemonic for the operation, or the name without the dialect prefix.
//   * A list of traits for the operation.
class Toy_Op&lt;string mnemonic, list&lt;OpTrait&gt; traits = []&gt; :
    Op&lt;Toy_Dialect, mnemonic, traits&gt;;</code>
				</pre>
			</div>
			<p data-pid="Ui-kc6XE">定义了所有的初始部分后，我们可以开始定义常量操作。</p>
			<p data-pid="-T4FJzzp">我们通过继承上面的&ldquo;Toy_Op&rdquo;基类来定义toy操作。在这里，我们提供了助记符和操作的特征列表。这里的
				<a href="../OpDefinitions.md#operation-name" class="internal">mnemonic</a>
				与
				<code>ConstantOp：：getOperationName</code>
				中给出的没有方言前缀
				<code>toy.</code>
				匹配。我们的C++定义中缺少
				<code>ZeroOperands</code>
				和
				<code>OneResult</code>
				特性；这些特性将根据我们稍后定义的
				<code>arguments</code>
				和
				<code>Results</code>
				字段自动推断出来。
			</p>
			<div class="highlight">
				<pre><code class="language-text">def ConstantOp : Toy_Op&lt;&#34;constant&#34;&gt; {
}</code></pre>
			</div>
			<p data-pid="EmCb4x3f">此时，您可能想知道TableGen生成的C++代码是什么样子。只需使用
				<code>Gen&ndash;op&ndash;decls</code>
				或
				<code>Gen&ndash;op&ndash;defs</code>
				操作运行
				<code>mlir&ndash;tblgen</code>
				命令，如下所示：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">${build_root}/bin/mlir-tblgen -gen-op-defs ${mlir_src_root}/examples/toy/Ch2/include/toy/Ops.td -I ${mlir_src_root}/include/</code>
				</pre>
			</div>
			<p data-pid="WobEchdn">根据选择的操作，这将打印
				<code>ConstantOp</code>
				类声明或其实现。在开始使用TableGen时，将此输出与手工创建的实现进行比较非常有用。
			</p>
			<h3>定义参数和结果</h3>
			<p data-pid="I7rJ6qsW">定义了操作的外壳后，我们现在可以为我们的操作提供
				<a href="../OpDefinitions.md#operation-arguments" class="internal">inputs</a>
				和
				<a href="../OpDefinitions.md#operation-results" class="internal">outputs</a>
				。操作的输入或参数可以是SSA操作数值的属性或类型。结果对应于操作生成的值的一组类型：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ConstantOp : Toy_Op&lt;&#34;constant&#34;&gt; {
  // The constant operation takes an attribute as the only input.
  // `F64ElementsAttr` corresponds to a 64-bit floating-point ElementsAttr.
  let arguments = (ins F64ElementsAttr:$value);

  // The constant operation returns a single value of TensorType.
  // F64Tensor corresponds to a 64-bit floating-point TensorType.
  let results = (outs F64Tensor);
}</code>
				</pre>
			</div>
			<p data-pid="XYj8luYW">通过给参数或结果命名，如
				<code>$value</code>
				，ODS会自动生成匹配的访问器：
				<code>DenseElementsAttr&nbsp;ConstantOp：：value()</code>
				。
			</p>
			<h3>添加文档</h3>
			<p data-pid="w_VV0DLy">定义操作后的下一步是对其进行文档记录。操作可以提供[
				<code>=&#34;https://zhuanlan.zhihu.com/OpDefinitions.md#operation&ndash;documentation&#34;&gt;summary&nbsp;and&nbsp;description]字段来描述操作的语义。此信息对该方言的用户很有用，甚至可以用来自动生成Markdown文档。</code>
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ConstantOp : Toy_Op&lt;&#34;constant&#34;&gt; {
  // Provide a summary and description for this operation. This can be used to
  // auto-generate documentation of the operations within our dialect.
  let summary = &#34;constant operation&#34;;
  let description = [{
    Constant operation turns a literal into an SSA value. The data is attached
    to the operation as an attribute. For example:

      %0 = &#34;toy.constant&#34;()
         { value = dense&lt;[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]&gt; : tensor&lt;2x3xf64&gt; }
        : () -&gt; tensor&lt;2x3xf64&gt;
  }];

  // The constant operation takes an attribute as the only input.
  // `F64ElementsAttr` corresponds to a 64-bit floating-point ElementsAttr.
  let arguments = (ins F64ElementsAttr:$value);

  // The generic call operation returns a single value of TensorType.
  // F64Tensor corresponds to a 64-bit floating-point TensorType.
  let results = (outs F64Tensor);
}</code>
				</pre>
			</div>
			<h3>验证操作语义</h3>
			<p data-pid="3d9Maj0l">至此，我们已经介绍了原始C++操作定义的大部分。下一个要定义的部分是验证器。幸运的是，与命名访问器非常相似，ODS框架将根据我们给出的约束自动生成大量必要的验证逻辑。这意味着我们不需要验证返回类型的结构，甚至不需要验证输入属性
				<code>value</code>
				。在许多情况下，对于ODS&nbsp;operations来说不需要额外验证。要添加其他验证逻辑，operation可以重载
				<code>
					<a href="../OpDefinitions.md#custom-verifier-code" class="internal">verifier</a>
				</code>
				字段。
				<code>verifier</code>
				字段允许定义一个C++代码blob，它将作为
				<code>ConstantOp：：verify</code>
				的一部分运行。此BLOB可以假设该操作的所有其他不变量都已经过验证：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ConstantOp : Toy_Op&lt;&#34;constant&#34;&gt; {
  // Provide a summary and description for this operation. This can be used to
  // auto-generate documentation of the operations within our dialect.
  let summary = &#34;constant operation&#34;;
  let description = [{
    Constant operation turns a literal into an SSA value. The data is attached
    to the operation as an attribute. For example:

      %0 = &#34;toy.constant&#34;()
         { value = dense&lt;[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]&gt; : tensor&lt;2x3xf64&gt; }
        : () -&gt; tensor&lt;2x3xf64&gt;
  }];

  // The constant operation takes an attribute as the only input.
  // `F64ElementsAttr` corresponds to a 64-bit floating-point ElementsAttr.
  let arguments = (ins F64ElementsAttr:$value);

  // The generic call operation returns a single value of TensorType.
  // F64Tensor corresponds to a 64-bit floating-point TensorType.
  let results = (outs F64Tensor);

  // Add additional verification logic to the constant operation. Here we invoke
  // a static `verify` method in a C++ source file. This codeblock is executed
  // inside of ConstantOp::verify, so we can use `this` to refer to the current
  // operation instance.
  let verifier = [{ return ::verify(*this); }];
}</code>
				</pre>
			</div>
			<h3>附加
				<code>build</code>
				方法
			</h3>
			<p data-pid="mofIYQ1s">我们的原始C++示例中缺少的最后一个组件是
				<code>build</code>
				方法。ODS可以自动生成一些简单的构建方法，在这种情况下，它将为我们生成我们的第一个构建方法。对于剩余部分，我们定义了
				<code>
					<a href="../OpDefinitions.md#custom-builder-methods" class="internal">builders</a>
				</code>
				字段。此字段包含一个
				<code>OpBuilder</code>
				对象列表，这些对象接受与C++参数列表相对应的字符串，以及一个可选代码Block，该代码可用于指定内联实现。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ConstantOp : Toy_Op&lt;&#34;constant&#34;&gt; {
  ...

  // Add custom build methods for the constant operation. These methods populate
  // the `state` that MLIR uses to create operations, i.e. these are used when
  // using `builder.create&lt;ConstantOp&gt;(...)`.
  let builders = [
    // Build a constant with a given constant tensor value.
    OpBuilderDAG&lt;(ins &#34;DenseElementsAttr&#34;:$value), [{
      // Call into an autogenerated `build` method.
      build(builder, result, value.getType(), value);
    }]&gt;,

    // Build a constant with a given constant floating-point value. This builder
    // creates a declaration for `ConstantOp::build` with the given parameters.
    OpBuilderDAG&lt;(ins &#34;double&#34;:$value)&gt;
  ];
}</code>
				</pre>
			</div>
			<h3>指定自定义装配格式</h3>
			<p data-pid="P8fvfc3g">到现在，我们可以生成我们的&ldquo;toyIR&rdquo;。例如，以下内容：</p>
			<div class="highlight">
				<pre>
<code class="language-text"># User defined generic function that operates on unknown shaped arguments.
def multiply_transpose(a, b) {
  return transpose(a) * transpose(b);
}

def main() {
  var a&lt;2, 3&gt; = [[1, 2, 3], [4, 5, 6]];
  var b&lt;2, 3&gt; = [1, 2, 3, 4, 5, 6];
  var c = multiply_transpose(a, b);
  var d = multiply_transpose(b, a);
  print(d);
}</code>
				</pre>
			</div>
			<p data-pid="SvYnOP5Q">结果为以下IR：</p>
			<div class="highlight">
				<pre>
<code class="language-text">module {
  func @multiply_transpose(%arg0: tensor&lt;*xf64&gt;, %arg1: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
    %0 = &#34;toy.transpose&#34;(%arg0) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:10)
    %1 = &#34;toy.transpose&#34;(%arg1) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:25)
    %2 = &#34;toy.mul&#34;(%0, %1) : (tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:25)
    &#34;toy.return&#34;(%2) : (tensor&lt;*xf64&gt;) -&gt; () loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:3)
  } loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:4:1)
  func @main() {
    %0 = &#34;toy.constant&#34;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:9:17)
    %1 = &#34;toy.reshape&#34;(%0) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;2x3xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:9:3)
    %2 = &#34;toy.constant&#34;() {value = dense&lt;[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00]&gt; : tensor&lt;6xf64&gt;} : () -&gt; tensor&lt;6xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:10:17)
    %3 = &#34;toy.reshape&#34;(%2) : (tensor&lt;6xf64&gt;) -&gt; tensor&lt;2x3xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:10:3)
    %4 = &#34;toy.generic_call&#34;(%1, %3) {callee = @multiply_transpose} : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:11:11)
    %5 = &#34;toy.generic_call&#34;(%3, %1) {callee = @multiply_transpose} : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:12:11)
    &#34;toy.print&#34;(%5) : (tensor&lt;*xf64&gt;) -&gt; () loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:13:3)
    &#34;toy.return&#34;() : () -&gt; () loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:8:1)
  } loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:8:1)
} loc(unknown)</code>
				</pre>
			</div>
			<p data-pid="1-Sw75TZ">这里需要注意的一件事是，我们所有的Toy操作都是使用通用装配格式打印的。此格式是本章开头分解
				<code>toy.transspose</code>
				时显示的格式。MLIR允许操作定义它们自己的自定义程序集格式，可以是
				<a href="../OpDefinitions.md#declarative-assembly-format" class="internal">declaratively</a>
				，也可以是通过C++。定义自定义程序集格式允许将生成的IR裁剪成更具可读性的内容，方法是去掉通用格式所需的大量乱七八糟的东西。让我们来演练一个我们想要简化的操作格式的示例。
			</p>
			<h3>
				<code>toy.print</code>
			</h3>
			<p data-pid="3GVshttf">当前的
				<code>toy.print</code>
				形式有点冗长。我们想要去掉很多额外的字符。让我们首先考虑一下一个好的
				<code>toy.print</code>
				格式是什么样，然后看看如何实现它。看一下
				<code>toy.print</code>
				的基本内容，我们会得到：
			</p>
			<div class="highlight">
				<pre><code class="language-text">toy.print %5 : tensor&lt;*xf64&gt; loc(...)</code></pre>
			</div>
			<p data-pid="2sowToFR">在这里，我们剥离了大部分格式，使其只剩下最基本的部分，可读性也大大提高。为了提供自定义的装配格式，操作可以重载C++格式化操作的
				<code>parser</code>
				和
				<code>printer</code>
				字段，也可以覆盖声明性格式的
				<code>AssemyFormat</code>
				字段。让我们首先看一下C++变体，因为这是声明性格式的内部映射方式。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">/// Consider a stripped definition of `toy.print` here.
def PrintOp : Toy_Op&lt;&#34;print&#34;&gt; {
  let arguments = (ins F64Tensor:$input);

  // Divert the printer and parser to static functions in our .cpp
  // file that correspond to &#39;print&#39; and &#39;printPrintOp&#39;. &#39;printer&#39; and &#39;parser&#39;
  // here correspond to an instance of a &#39;OpAsmParser&#39; and &#39;OpAsmPrinter&#39;. More
  // details on these classes is shown below.
  let printer = [{ return ::print(printer, *this); }];
  let parser = [{ return ::parse$cppClass(parser, result); }];
}</code>
				</pre>
			</div>
			<p data-pid="oITd26vl">
				<code>parser</code>
				和
				<code>printer</code>
				的C++实现如下所示：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// The &#39;OpAsmPrinter&#39; class is a stream that will allows for formatting
</span><span class="c1">/// strings, attributes, operands, types, etc.
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpAsmPrinter</span> <span class="o">&amp;</span><span class="n">printer</span><span class="p">,</span> <span class="n">PrintOp</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printer</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;toy.print &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">op</span><span class="p">.</span><span class="n">input</span><span class="p">();</span>
  <span class="n">printer</span><span class="p">.</span><span class="n">printOptionalAttrDict</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">getAttrs</span><span class="p">());</span>
  <span class="n">printer</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">op</span><span class="p">.</span><span class="n">input</span><span class="p">().</span><span class="n">getType</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// The &#39;OpAsmParser&#39; class provides a collection of methods for parsing
</span><span class="c1">/// various punctuation, as well as attributes, operands, types, etc. Each of
</span><span class="c1">/// these methods returns a `ParseResult`. This class is a wrapper around
</span><span class="c1">/// `LogicalResult` that can be converted to a boolean `true` value on failure,
</span><span class="c1">/// or `false` on success. This allows for easily chaining together a set of
</span><span class="c1">/// parser rules. These rules are used to populate an `mlir::OperationState`
</span><span class="c1">/// similarly to the `build` methods described above.
</span><span class="c1"></span><span class="k">static</span> <span class="n">mlir</span><span class="o">::</span><span class="n">ParseResult</span> <span class="n">parsePrintOp</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpAsmParser</span> <span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span>
                                      <span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Parse the input operand, the attribute dictionary, and the type of the
</span><span class="c1"></span>  <span class="c1">// input.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">OpAsmParser</span><span class="o">::</span><span class="n">OperandType</span> <span class="n">inputOperand</span><span class="p">;</span>
  <span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">inputType</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseOperand</span><span class="p">(</span><span class="n">inputOperand</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">parser</span><span class="p">.</span><span class="n">parseOptionalAttrDict</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">attributes</span><span class="p">)</span> <span class="o">||</span> <span class="n">parser</span><span class="p">.</span><span class="n">parseColon</span><span class="p">()</span> <span class="o">||</span>
      <span class="n">parser</span><span class="p">.</span><span class="n">parseType</span><span class="p">(</span><span class="n">inputType</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">failure</span><span class="p">();</span>

  <span class="c1">// Resolve the input operand to the type we parsed in.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">resolveOperand</span><span class="p">(</span><span class="n">inputOperand</span><span class="p">,</span> <span class="n">inputType</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">operands</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">failure</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">mlir</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="G9lqssNi">定义了C++实现之后，让我们看看如何将其映射到
				<a href="../OpDefinitions.md#declarative-assembly-format" class="internal">declarative&nbsp;format</a>
				.声明性格式主要由三个不同的组件组成：
			</p>
			<ul>
				<li data-pid="RvNMO89o">指令</li>
				<li data-pid="nUcNMkcH">一种内置函数，具有一组可选的参数。</li>
				<li data-pid="VGNcnUYn">文字</li>
				<li data-pid="S4ESEVul">用``括起来的关键字或标点符号。</li>
				<li data-pid="QBT51eG3">变量</li>
				<li data-pid="dG5fQp-X">已在操作本身上注册的实体，即
					<code>PrintOp</code>
					中的参数(属性或操作数)、结果、后继等，在上面的
					<code>PrintOp</code>
					示例中，变量应该是
					<code>$input</code>
					。
				</li>
			</ul>
			<p data-pid="JLFWKgW2">我们的C++格式的直接映射类似于：</p>
			<div class="highlight">
				<pre>
<code class="language-text">/// Consider a stripped definition of `toy.print` here.
def PrintOp : Toy_Op&lt;&#34;print&#34;&gt; {
  let arguments = (ins F64Tensor:$input);

  // In the following format we have two directives, `attr-dict` and `type`.
  // These correspond to the attribute dictionary and the type of a given
  // variable represectively.
  let assemblyFormat = &#34;$input attr-dict `:` type($input)&#34;;
}</code>
				</pre>
			</div>
			<p data-pid="aZpxyAua">
				<a href="../OpDefinitions.md#declarative-assembly-format" class="internal">declarative&nbsp;format</a>
				有更多有趣的特性，因此在用C++实现自定义格式之前一定要检查它。在美化了几个操作的格式之后，我们现在得到一个可读性更强的：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">module {
  func @multiply_transpose(%arg0: tensor&lt;*xf64&gt;, %arg1: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
    %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:10)
    %1 = toy.transpose(%arg1 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:25)
    %2 = toy.mul %0, %1 : tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:25)
    toy.return %2 : tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:5:3)
  } loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:4:1)
  func @main() {
    %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:9:17)
    %1 = toy.reshape(%0 : tensor&lt;2x3xf64&gt;) to tensor&lt;2x3xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:9:3)
    %2 = toy.constant dense&lt;[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00]&gt; : tensor&lt;6xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:10:17)
    %3 = toy.reshape(%2 : tensor&lt;6xf64&gt;) to tensor&lt;2x3xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:10:3)
    %4 = toy.generic_call @multiply_transpose(%1, %3) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:11:11)
    %5 = toy.generic_call @multiply_transpose(%3, %1) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:12:11)
    toy.print %5 : tensor&lt;*xf64&gt; loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:13:3)
    toy.return loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:8:1)
  } loc(&#34;test/Examples/Toy/Ch2/codegen.toy&#34;:8:1)
} loc(unknown)</code>
				</pre>
			</div>
			<p data-pid="Vt7rsa36">上面我们介绍了几个在ODS框架中定义操作的概念，但是还有更多我们还没有机会介绍的概念：区域（regions）、各种操作数（variadic&nbsp;operands）等。有关更多详细信息，请查看
				<a href="../OpDefinitions.md" class="internal">完整规范</a>
				。
			</p>
			<h2>完整的toy示例</h2>
			<p data-pid="H66Mspn6">我们现在可以生成我们的&ldquo;toyIR&rdquo;了。您可以构建
				<code>toyc&ndash;ch2</code>
				，然后尝试上面的示例：
				<code>toyc&ndash;Ch2&nbsp;test/Examples/Toy/CH2/codegen.toy&nbsp;&ndash;emit=mlir&nbsp;&ndash;mlir&ndash;print&ndash;debuginfo</code>
				。我们还可以检查RoundTrip过程：
				<code>toyc&ndash;CH2&nbsp;test/examples/Toy/CH2/codegen.toy&nbsp;&ndash;emit=&nbsp;&ndash;mlir&ndash;print&ndash;debuginfo&nbsp;2&gt;codegen.mlir</code>
				后跟
				<code>toyc&ndash;CH2&nbsp;codegen.mlir&nbsp;&ndash;emit=mlir</code>
				。您还可以对最终的定义文件使用
				<code>mlir&ndash;tblgen</code>
				，并研究生成的C++代码。
			</p>
			<p data-pid="uMdfmhf2">到现在为止，MLIR知道我们的toy方言和操作。在
				<a href="zh-Ch-3.md" class="internal">下一章</a>
				中，我们将利用我们的新方言实现一些针对toy语言的高级语言特定分析和转换。
			</p>
		</div>
	<!-- AutoExtract End-->
		</div>

		<hr/>
		<H2><a name="HEAD_2" href="#TOC_HEAD_2">MLIR入门教程3 高级语言转换到MLIR 知乎</a></H2>
		<div>
<!-- AutoExtract Begin-->
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Wed Oct 18 21:39:05 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/436453771" target="_blank">
				<font color="red" size="3">MLIR入门教程3&ndash;高级语言转换到MLIR&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<blockquote data-first-child data-pid="u20zcZTv">本文翻译自MLIR社区官方文档，受限于笔者个人的认知水平，翻译效果可能不是很理想，翻译原始文档也会放在github上，供大家参考，如发现问题也欢迎提PR或者Issue:</blockquote>
			<a target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/hunterzju/llvm-tutorial" data-draft-node="block" data-draft-type="link-card" data-text="https://github.com/hunterzju/llvm-tutorial" class="LinkCard new">
				<span class="LinkCard-contents">
					<span class="LinkCard-title loading" data-text="true"></span>
					<span class="LinkCard-desc loading"></span>
				</span>
				<span class="LinkCard-image LinkCard-image--default"></span>
			</a>
			<h2>第3章：高级语言特定的分析和转换</h2>
			<p data-pid="DrMf_eKr">创建紧密代表输入语言语义的方言可以实现MLIR中的分析、转换和优化，这些分析、转换和优化需要高级语言信息，并且通常在语言AST上执行。例如，
				<code>clang</code>
				在C++中执行模板实例化时有一个相当复杂的
				<a href="https://link.zhihu.com/?target=https%3A//clang.llvm.org/doxygen/classclang_1_1TreeTransform.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">mechanism</a>
				。
			</p>
			<p data-pid="JthWUwar">我们将编译器转换分为两类：局部和全局。在本章中，我们将重点介绍如何利用toy方言及其高级语义来执行在LLVM中难以实现的本地模式匹配转换。为此，我们使用MLIR的
				<a href="../PatternRewriter.md" class="internal">通用DAG重写器</a>
				。
			</p>
			<p data-pid="01AN2XZm">有两种方法可以实现模式匹配转换：1.命令式，C++模式匹配和重写.2.声明性的、基于规则的模式匹配和重写，使用表驱动的
				<a href="../DeclarativeRewrites.md" class="internal">声明性重写规则Declarative&nbsp;Rewrite&nbsp;Rules</a>
				(DRR)。请注意，DRR的使用要求使用ODS定义操作，如
				<a href="zh-Ch-2.md" class="internal">第2章</a>
				中所述。
			</p>
			<h2>使用C++风格的模式匹配和重写优化转置</h2>
			<p data-pid="LGBUPBgs">让我们从一个简单的模式开始，尝试消除两个相互抵消的转置序列：&lsquo;transspose(transspose(X))&ndash;&gt;X&rsquo;。下面是相应的toy示例：</p>
			<div class="highlight">
				<pre><code class="language-text">def transpose_transpose(x) {
  return transpose(transpose(x));
}</code></pre>
			</div>
			<p data-pid="OmkM6BFv">它对应于以下IR：</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  %1 = toy.transpose(%0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  toy.return %1 : tensor&lt;*xf64&gt;
}</code>
				</pre>
			</div>
			<p data-pid="s2CeqApu">这是一个很好的转换示例，在Toy&nbsp;IR上平常，但是LLVM很难理解。例如，今天的Clang不能优化掉临时数组，使用原生转置的计算可以用以下循环表示：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="cp">#define N 100
</span><span class="cp">#define M 100
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">sink</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">double_transpose</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">sink</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="glFwENrH">对于一种简单的C++重写方法，包括匹配IR中的树形模式并将其替换为一组不同的操作，我们可以通过实现
				<code>RewritePattern</code>
				来插入MLIR的
				<code>Canonicalizer</code>
				过程：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Fold transpose(transpose(x)) -&gt; x
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">SimplifyRedundantTranspose</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">/// We register this pattern to match every toy.transpose in the IR.
</span><span class="c1"></span>  <span class="c1">/// The &#34;benefit&#34; is used by the framework to order the patterns and process
</span><span class="c1"></span>  <span class="c1">/// them in order of profitability.
</span><span class="c1"></span>  <span class="n">SimplifyRedundantTranspose</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="cm">/*benefit=*/</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">/// This method is attempting to match a pattern and rewrite it. The rewriter
</span><span class="c1"></span>  <span class="c1">/// argument is the orchestrator of the sequence of rewrites. It is expected
</span><span class="c1"></span>  <span class="c1">/// to interact with it to perform any changes to the IR from here.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span>
  <span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">TransposeOp</span> <span class="n">op</span><span class="p">,</span>
                  <span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// Look through the input of the current transpose.
</span><span class="c1"></span>    <span class="n">mlir</span><span class="o">::</span><span class="n">Value</span> <span class="n">transposeInput</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">();</span>
    <span class="n">TransposeOp</span> <span class="n">transposeInputOp</span> <span class="o">=</span> <span class="n">transposeInput</span><span class="p">.</span><span class="n">getDefiningOp</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="c1">// Input defined by another transpose? If not, no match.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transposeInputOp</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">failure</span><span class="p">();</span>

    <span class="c1">// Otherwise, we have a redundant transpose. Use the rewriter.
</span><span class="c1"></span>    <span class="n">rewriter</span><span class="p">.</span><span class="n">replaceOp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="p">{</span><span class="n">transposeInputOp</span><span class="p">.</span><span class="n">getOperand</span><span class="p">()});</span>
    <span class="k">return</span> <span class="nf">success</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="yhwQeAB-">该重写器的实现在
				<code>ToyCombine.cpp</code>
				中。
				<a href="../Canonicalization.md" class="internal">canonicalization&nbsp;pass</a>
				以贪婪、迭代的方式应用由操作定义的转换。为了确保规范化过程应用我们的新转换，我们设置
				<a href="../OpDefinitions.md#hascanonicalizer" class="internal">hasCanonicalizer=1</a>
				并将模式注册到规范化框架。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">// Register our patterns for rewrite by the Canonicalization framework.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">TransposeOp</span><span class="o">::</span><span class="n">getCanonicalizationPatterns</span><span class="p">(</span>
    <span class="n">OwningRewritePatternList</span> <span class="o">&amp;</span><span class="n">results</span><span class="p">,</span> <span class="n">MLIRContext</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">results</span><span class="p">.</span><span class="n">insert</span><span class="o">&lt;</span><span class="n">SimplifyRedundantTranspose</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="n39MbwC1">我们还需要更新主文件
				<code>toyc.cpp</code>
				，以添加优化通道。在MLIR中，优化通过
				<code>PassManager</code>
				进行，方式与LLVM类似：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">mlir</span><span class="o">::</span><span class="n">PassManager</span> <span class="n">pm</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
  <span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createCanonicalizerPass</span><span class="p">());</span>
</code>
				</pre>
			</div>
			<p data-pid="eNBrA2K4">最后，我们可以运行
				<code>toyc&ndash;ch3&nbsp;test/Examples/Toy/ch3/transpose_transpose.toy&nbsp;&ndash;emit=mlir&nbsp;&ndash;opt</code>
				并观察我们的模式：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  toy.return %arg0 : tensor&lt;*xf64&gt;
}</code>
				</pre>
			</div>
			<p data-pid="PahfcY5f">不出所料，我们现在直接返回函数参数，绕过任何转置操作。然而，其中一个转置仍然没有被消除。那不是很理想！现在的情况是，我们的模式用函数输入替换了最后一个转置，留下了现在无用的转置输入。Canonicalizer知道清理无效的操作；但是，MLIR保守地假设操作可能有副作用。我们可以通过在我们的
				<code>TransposeOp</code>
				中添加一个新的特征
				<code>NoSideEffect</code>
				来修复这个问题：
			</p>
			<div class="highlight">
				<pre><code class="language-text">def TransposeOp : Toy_Op&lt;&#34;transpose&#34;, [NoSideEffect]&gt; {...}</code></pre>
			</div>
			<p data-pid="-I9gGpl6">现在重试
				<code>toyc&ndash;ch3&nbsp;test/transpose_transpose.toy&nbsp;&ndash;emit=mlir&nbsp;&ndash;opt</code>
				：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  toy.return %arg0 : tensor&lt;*xf64&gt;
}</code>
				</pre>
			</div>
			<p data-pid="6WMBuUBO">太棒了！没有留下&lsquo;转置&rsquo;操作&ndash;代码是最优的。</p>
			<p data-pid="ECc4Exs0">在下一节中，我们将使用DRR进行与重塑操作相关联的模式匹配优化。</p>
			<h2>使用DRR优化Reshape</h2>
			<p data-pid="-U8GdCar">基于规则的声明性模式匹配和重写(DRR)是基于DAG的操作声明性重写器，它为模式匹配和重写规则提供基于表的语法：</p>
			<div class="highlight">
				<pre>
<code class="language-text">class Pattern&lt;
    dag sourcePattern, list&lt;dag&gt; resultPatterns,
    list&lt;dag&gt; additionalConstraints = [],
    dag benefitsAdded = (addBenefit 0)&gt;;</code>
				</pre>
			</div>
			<p data-pid="7SZiLH6K">类似于SimplifyRedundantTranspose的冗余重塑优化可以更简单地使用DRR表示，如下所示：</p>
			<div class="highlight">
				<pre>
<code class="language-text">// Reshape(Reshape(x)) = Reshape(x)
def ReshapeReshapeOptPattern : Pat&lt;(ReshapeOp(ReshapeOp $arg)),
                                   (ReshapeOp $arg)&gt;;</code>
				</pre>
			</div>
			<p data-pid="Ywz8c7CV">可以在
				<code>path/to/BUILD/tools/mlir/examples/toy/Ch3/ToyCombine.inc</code>
				下找到与每个DRR模式相对应的自动生成的C++代码。
			</p>
			<p data-pid="Y9sUaT7C">DRR还提供了一种方法，用于在转换取决于参数和结果的某些属性时添加参数约束。例如，当重塑是冗余的时(即当输入和输出形状相同时)，可以消除重塑。</p>
			<div class="highlight">
				<pre>
<code class="language-text">def TypesAreIdentical : Constraint&lt;CPred&lt;&#34;$0.getType() == $1.getType()&#34;&gt;&gt;;
def RedundantReshapeOptPattern : Pat&lt;
  (ReshapeOp:$res $arg), (replaceWithValue $arg),
  [(TypesAreIdentical $res, $arg)]&gt;;</code>
				</pre>
			</div>
			<p data-pid="SCfMuN7u">某些优化可能需要对指令参数进行额外的转换。这是使用NativeCodeCall实现的，它允许通过调用C++帮助器函数或使用内联C++进行更复杂的转换。这种优化的一个例子是FoldConstantReshape，我们通过就地重塑常量并消除重塑操作来优化常量值的重塑。</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ReshapeConstant : NativeCodeCall&lt;&#34;$0.reshape(($1.getType()).cast&lt;ShapedType&gt;())&#34;&gt;;
def FoldConstantReshapeOptPattern : Pat&lt;
  (ReshapeOp:$res (ConstantOp $arg)),
  (ConstantOp (ReshapeConstant $arg, $res))&gt;;</code>
				</pre>
			</div>
			<p data-pid="WnF_FzOJ">我们使用下面的trivial_reshape.toy程序演示这些重塑优化：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">def</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">a</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
  <span class="n">var</span> <span class="n">b</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">c</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module</span> <span class="p">{</span>
  <span class="n">func</span> <span class="err">@</span><span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">toy</span><span class="p">.</span><span class="n">constant</span> <span class="n">dense</span><span class="o">&lt;</span><span class="p">[</span><span class="mf">1.000000e+00</span><span class="p">,</span> <span class="mf">2.000000e+00</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">xf64</span><span class="o">&gt;</span>
    <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">toy</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span> <span class="o">:</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">xf64</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">to</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x1xf64</span><span class="o">&gt;</span>
    <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">toy</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span> <span class="o">:</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x1xf64</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">to</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x1xf64</span><span class="o">&gt;</span>
    <span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="n">toy</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span> <span class="o">:</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x1xf64</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">to</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x1xf64</span><span class="o">&gt;</span>
    <span class="n">toy</span><span class="p">.</span><span class="n">print</span> <span class="o">%</span><span class="mi">3</span> <span class="o">:</span> <span class="n">tensor</span><span class="o">&lt;</span><span class="mi">2</span><span class="n">x1xf64</span><span class="o">&gt;</span>
    <span class="n">toy</span><span class="p">.</span><span class="k">return</span>
  <span class="p">}</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="TGjAUKFG">我们可以尝试运行
				<code>toyc&ndash;ch3&nbsp;test/Examples/Toy/ch3/trivial_reshape.toy&nbsp;&ndash;emit=mlir&nbsp;&ndash;opt</code>
				，并实际观察我们的模式：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">module {
  func @main() {
    %0 = toy.constant dense&lt;[[1.000000e+00], [2.000000e+00]]&gt; : tensor&lt;2x1xf64&gt;
    toy.print %0 : tensor&lt;2x1xf64&gt;
    toy.return
  }
}</code>
				</pre>
			</div>
			<p data-pid="E-9Ag11Q">正如预期的那样，规范化后不再保留任何重塑操作。</p>
			<p data-pid="y68uEmn4">有关声明性重写方法的更多详细信息，请参阅
				<a href="../DeclarativeRewrites.md" class="internal">表驱动声明性重写规则(DRR)</a>
				。
			</p>
			<p data-pid="iTu8dWiF">在本章中，我们了解了如何通过始终可用的钩子使用特定的核心转换。在
				<a href="zh-Ch-4.md" class="internal">下一章</a>
				中，我们将了解如何使用通过Interfaces更好地扩展的通用解决方案。
			</p>
		</div>
	<!-- AutoExtract End-->
		</div>

		<hr/>
		<H2><a name="HEAD_3" href="#TOC_HEAD_3">MLIR入门教程4 dialect和operation接口 知乎</a></H2>
		<div>
<!-- AutoExtract Begin-->
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Wed Oct 18 21:39:15 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/436909443" target="_blank">
				<font color="red" size="3">MLIR入门教程4&ndash;dialect和operation接口&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<blockquote data-first-child data-pid="j9o65yQv">本文翻译自MLIR社区官方文档，受限于笔者个人的认知水平，翻译效果可能不是很理想，翻译原始文档也会放在github上，供大家参考，如发现问题也欢迎提PR或者Issue:</blockquote>
			<a target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/hunterzju/llvm-tutorial" data-draft-node="block" data-draft-type="link-card" data-text="https://github.com/hunterzju/llvm-tutorial" class="LinkCard new">
				<span class="LinkCard-contents">
					<span class="LinkCard-title loading" data-text="true"></span>
					<span class="LinkCard-desc loading"></span>
				</span>
				<span class="LinkCard-image LinkCard-image--default"></span>
			</a>
			<h2>第4章：使用接口启用泛型转换</h2>
			<h2>背景：努力解决IR的可扩展问题</h2>
			<p data-pid="5gy_8Gl4">通过方言，MLIR允许表示许多不同的抽象级别；我们之前定义的toy方言就是这样一个例子。尽管这些不同的方言可能代表不同的抽象，但我们通常想要执行一组共同的转换和分析。出现的问题是，为每种方言原生实现每个转换都会导致大量代码重复，因为内部算法通常非常相似(如果不是相同的话)。我们希望为转换提供不透明地挂钩到像toy这样的方言的能力，以获得他们需要的信息。</p>
			<p data-pid="tRsGKiu8">MLIR为某些核心转换提供了一组始终可用的钩子，如
				<a href="zh-Ch-3.md" class="internal">上一章</a>
				所示，我们通过操作上的钩子(
				<code>getCanonicalizationPatterns</code>
				)注册了一些规范。然而，这些类型的钩子并不能很好地扩展。因此，设计了一个更通用的解决方案，其形式为
				<a href="../Interfaces.md" class="internal">interface</a>
				，以使MLIR基础设施与表示一样具有可扩展性。接口为方言和操作提供通用机制，以便为转换或分析提供信息。
			</p>
			<h2>形状推断：为代码生成做准备</h2>
			<p data-pid="Ft1WPy49">我们的toyIR当前在泛型张量上操作，这意味着除了在常量初始化期间之外，我们不知道张量的形状。这使得优化和代码生成变得复杂。幸运的是，我们可以简单地在计算过程中传播形状，直到它们都知道为止。问题是如何处理对用户定义的泛型函数的调用：每个调用点可以推导出不同的形状。一种可能性是基于参数类型执行符号推理，但是如果我们要在语言中引入更多的控制流，这将很难推广。另一种方法是函数专门化，每个具有新参数形状的调用点都复制被调用的函数并专门化它。我们对Toy采取的方法是内联所有函数调用，然后执行过程内形状传播。</p>
			<h3>内联</h3>
			<p data-pid="1HBTnrRx">在这里，我们可以编写一个专门为toy方言设计的内联算法，但这可能会变得相当复杂，这取决于我们想要的复杂程度。抛开建模成本不谈，从零开始实现纯粹的结构转换已经很复杂了。值得庆幸的是，MLIR提供了方言可以插入的通用内联算法。在Toy中，我们所需要做的就是提供
				<a href="../Interfaces.md" class="internal">interface</a>
				供内联程序挂接到其中。
			</p>
			<p data-pid="qlHHniUk">我们需要做的第一件事是定义对toy方言内联操作的约束。此信息通过
				<a href="../Interfaces.md#dialect-interfaces" class="internal">方言interface</a>
				提供。这实质上是一个包含一组虚拟钩子的类，方言可以覆盖这些虚拟钩子。在本例中，接口为
				<code>DialectInlinerInterface</code>
				。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// This class defines the interface for handling inlining with Toy operations.
</span><span class="c1">/// We simplify inherit from the base interface class and override
</span><span class="c1">/// the necessary methods.
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">ToyInlinerInterface</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DialectInlinerInterface</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">DialectInlinerInterface</span><span class="o">::</span><span class="n">DialectInlinerInterface</span><span class="p">;</span>

  <span class="c1">/// This hook checks to see if the given callable operation is legal to inline
</span><span class="c1"></span>  <span class="c1">/// into the given call. For Toy this hook can simply return true, as the Toy
</span><span class="c1"></span>  <span class="c1">/// Call operation is always inlinable.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">isLegalToInline</span><span class="p">(</span><span class="n">Operation</span> <span class="o">*</span><span class="n">call</span><span class="p">,</span> <span class="n">Operation</span> <span class="o">*</span><span class="n">callable</span><span class="p">,</span>
                       <span class="kt">bool</span> <span class="n">wouldBeCloned</span><span class="p">)</span> <span class="k">const</span> <span class="k">final</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// This hook checks to see if the given operation is legal to inline into the
</span><span class="c1"></span>  <span class="c1">/// given region. For Toy this hook can simply return true, as all Toy
</span><span class="c1"></span>  <span class="c1">/// operations are inlinable.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">isLegalToInline</span><span class="p">(</span><span class="n">Operation</span> <span class="o">*</span><span class="p">,</span> <span class="n">Region</span> <span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span>
                       <span class="n">BlockAndValueMapping</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="k">final</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// This hook is called when a terminator operation has been inlined. The only
</span><span class="c1"></span>  <span class="c1">/// terminator that we have in the Toy dialect is the return
</span><span class="c1"></span>  <span class="c1">/// operation(toy.return). We handle the return by replacing the values
</span><span class="c1"></span>  <span class="c1">/// previously returned by the call operation with the operands of the
</span><span class="c1"></span>  <span class="c1">/// return.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">handleTerminator</span><span class="p">(</span><span class="n">Operation</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
                        <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">valuesToRepl</span><span class="p">)</span> <span class="k">const</span> <span class="k">final</span> <span class="p">{</span>
    <span class="c1">// Only &#34;toy.return&#34; needs to be handled here.
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">returnOp</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">ReturnOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

    <span class="c1">// Replace the values directly with the return operands.
</span><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">returnOp</span><span class="p">.</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">==</span> <span class="n">valuesToRepl</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">it</span> <span class="p">:</span> <span class="n">llvm</span><span class="o">::</span><span class="n">enumerate</span><span class="p">(</span><span class="n">returnOp</span><span class="p">.</span><span class="n">getOperands</span><span class="p">()))</span>
      <span class="n">valuesToRepl</span><span class="p">[</span><span class="n">it</span><span class="p">.</span><span class="n">index</span><span class="p">()].</span><span class="n">replaceAllUsesWith</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="p-Fd2eG8">然后，我们直接在toy方言上注册我们的方言接口，类似于我们对operations所做的操作。</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">ToyDialect</span><span class="o">::</span><span class="n">ToyDialect</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="o">:</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span><span class="p">(</span><span class="s">&#34;toy&#34;</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">addInterfaces</span><span class="o">&lt;</span><span class="n">ToyInlinerInterface</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="Uvkza8Ba">接下来，我们需要提供一种方法，让内联程序知道
				<code>toy.Generic_call</code>
				表示对函数的调用。MLIR提供了可用于将操作标记为&ldquo;call&ndash;like&rdquo;的
				<a href="../Interfaces.md#operation-interfaces" class="internal">operation&nbsp;interface</a>
				。与方言接口不同，操作接口提供了更精细的信息粒度，这些信息是单个操作的特定和核心信息。这里我们要添加的接口是
				<code>CallOpInterface</code>
				。
			</p>
			<p data-pid="kpZFJ5mQ">要添加此接口，我们只需将定义包含到我们的操作规范文件(
				<code>Ops.td</code>
				)中：
			</p>
			<div class="highlight">
				<pre><code class="language-text">include &#34;mlir/Interfaces/CallInterfaces.td&#34;</code></pre>
			</div>
			<p data-pid="PpIGet-e">并添加到
				<code>GenericCallOp</code>
				的特征列表中：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def GenericCallOp : Toy_Op&lt;&#34;generic_call&#34;,
    [DeclareOpInterfaceMethods&lt;CallOpInterface&gt;]&gt; {
  ...
}</code>
				</pre>
			</div>
			<p data-pid="k5u1v6P3">在上面，我们还使用
				<code>DeclareOpInterfaceMethods</code>
				指令自动声明GenericCallOp的类声明中的所有接口方法。这意味着我们只需要提供一个定义：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Return the callee of the generic call operation, this is required by the
</span><span class="c1">/// call interface.
</span><span class="c1"></span><span class="n">CallInterfaceCallable</span> <span class="n">GenericCallOp</span><span class="o">::</span><span class="n">getCallableForCallee</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">getAttrOfType</span><span class="o">&lt;</span><span class="n">SymbolRefAttr</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;callee&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// Get the argument operands to the called function, this is required by the
</span><span class="c1">/// call interface.
</span><span class="c1"></span><span class="n">Operation</span><span class="o">::</span><span class="n">operand_range</span> <span class="n">GenericCallOp</span><span class="o">::</span><span class="n">getArgOperands</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">inputs</span><span class="p">();</span> <span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="oy63ZYVa">既然已经通知了内嵌器有关toy方言的信息，我们可以将内联过程添加到Toy的过程管理器中：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createInlinerPass</span><span class="p">());</span>
</code>
				</pre>
			</div>
			<p data-pid="GFgudifG">现在，让我们看一个工作示例：</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @multiply_transpose(%arg0: tensor&lt;*xf64&gt;, %arg1: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  %1 = toy.transpose(%arg1 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  %2 = toy.mul %0, %1 : tensor&lt;*xf64&gt;
  toy.return %2 : tensor&lt;*xf64&gt;
}
func @main() {
  %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;
  %1 = toy.reshape(%0 : tensor&lt;2x3xf64&gt;) to tensor&lt;2x3xf64&gt;
  %2 = toy.constant dense&lt;[1.000000e+00, 2.000000e+00, 3.000000e+00, 4.000000e+00, 5.000000e+00, 6.000000e+00]&gt; : tensor&lt;6xf64&gt;
  %3 = toy.reshape(%2 : tensor&lt;6xf64&gt;) to tensor&lt;2x3xf64&gt;
  %4 = toy.generic_call @multiply_transpose(%1, %3) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %5 = toy.generic_call @multiply_transpose(%3, %1) : (tensor&lt;2x3xf64&gt;, tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  toy.print %5 : tensor&lt;*xf64&gt;
  toy.return
}</code>
				</pre>
			</div>
			<p data-pid="epEkseMo">我们有两个对Multiple_Transpose的调用，我们希望将它们内联到main中，但是如果我们查看输出，什么都没有改变。我们遗漏了最后一个细微的部分：在调用的边缘有一个隐藏的类型转换。如果我们查看上面的内容，则Generic_call的操作数类型为
				<code>tensor&lt;2x3xf64&gt;</code>
				，而函数的输入应为
				<code>tensor&lt;*xf64&gt;</code>
				。要解决此差异，内联程序需要插入显式强制转换操作。为此，我们需要向toy方言添加一个新操作
				<code>ToyCastOp</code>
				(toy.cast)，以表示两个不同形状之间的类型转换。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def CastOp : Toy_Op&lt;&#34;cast&#34;, [
    DeclareOpInterfaceMethods&lt;CastOpInterface&gt;,
    NoSideEffect,
    SameOperandsAndResultShape]
  &gt; {
  let summary = &#34;shape cast operation&#34;;
  let description = [{
    The &#34;cast&#34; operation converts a tensor from one type to an equivalent type
    without changing any data elements. The source and destination types
    must both be tensor types with the same element type. If both are ranked,
    then shape is required to match. The operation is invalid if converting
    to a mismatching constant dimension.
  }];

  let arguments = (ins F64Tensor:$input);
  let results = (outs F64Tensor:$output);
}</code>
				</pre>
			</div>
			<p data-pid="fwtAN-up">请注意，此强制转换操作的定义在特征列表中添加了一个
				<code>CastOpInterface</code>
				。此接口为类似强制转换的操作提供了几个实用程序，例如折叠一致性强制转换和验证。我们通过为
				<code>areCastCompatible</code>
				方法提供定义来挂钩到此接口：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Returns true if the given set of input and result types are compatible with
</span><span class="c1">/// this cast operation. This is required by the `CastOpInterface` to verify
</span><span class="c1">/// this operation and provide other additional utilities.
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">CastOp</span><span class="o">::</span><span class="n">areCastCompatible</span><span class="p">(</span><span class="n">TypeRange</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">TypeRange</span> <span class="n">outputs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">outputs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// The inputs must be Tensors with the same element type.
</span><span class="c1"></span>  <span class="n">TensorType</span> <span class="n">input</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">TensorType</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">TensorType</span> <span class="n">output</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">TensorType</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">input</span> <span class="o">||</span> <span class="o">!</span><span class="n">output</span> <span class="o">||</span> <span class="n">input</span><span class="p">.</span><span class="n">getElementType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">output</span><span class="p">.</span><span class="n">getElementType</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// The shape is required to match if both types are ranked.
</span><span class="c1"></span>  <span class="k">return</span> <span class="o">!</span><span class="n">input</span><span class="p">.</span><span class="n">hasRank</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">output</span><span class="p">.</span><span class="n">hasRank</span><span class="p">()</span> <span class="o">||</span> <span class="n">input</span> <span class="o">==</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="HfQb4UVy">通过正确的强制转换操作，我们现在可以覆盖ToyInlinerInterface上的必要挂钩，以便在需要时为我们插入它：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="k">struct</span> <span class="nc">ToyInlinerInterface</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DialectInlinerInterface</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">/// Attempts to materialize a conversion for a type mismatch between a call
</span><span class="c1"></span>  <span class="c1">/// from this dialect, and a callable region. This method should generate an
</span><span class="c1"></span>  <span class="c1">/// operation that takes &#39;input&#39; as the only operand, and produces a single
</span><span class="c1"></span>  <span class="c1">/// result of &#39;resultType&#39;. If a conversion can not be generated, nullptr
</span><span class="c1"></span>  <span class="c1">/// should be returned.
</span><span class="c1"></span>  <span class="n">Operation</span> <span class="o">*</span><span class="n">materializeCallConversion</span><span class="p">(</span><span class="n">OpBuilder</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="n">Value</span> <span class="n">input</span><span class="p">,</span>
                                       <span class="n">Type</span> <span class="n">resultType</span><span class="p">,</span>
                                       <span class="n">Location</span> <span class="n">conversionLoc</span><span class="p">)</span> <span class="k">const</span> <span class="k">final</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">CastOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">conversionLoc</span><span class="p">,</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="a9vdb_L0">如果我们再次按照流程运行工作示例，我们会得到预期的结果：</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @main() {
  %0 = &#34;toy.constant&#34;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %1 = &#34;toy.constant&#34;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %2 = &#34;toy.cast&#34;(%1) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %3 = &#34;toy.cast&#34;(%0) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %4 = &#34;toy.transpose&#34;(%2) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %5 = &#34;toy.transpose&#34;(%3) : (tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  %6 = &#34;toy.mul&#34;(%4, %5) : (tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt;
  toy.print %6 : tensor&lt;*xf64&gt;
  toy.return
}</code>
				</pre>
			</div>
			<p data-pid="r5z1y9RO">注意：泛型内联还将执行简化，因此输出可能比预期的要干净一些。</p>
			<h3>程序内形状推断</h3>
			<p data-pid="nX7cr8PS">现在我们已经内联了所有函数，剩下的主函数包含静态和动态成形操作的混合。现在，我们可以编写一个简单的形状推断过程来在程序内(在单个函数内)传播形状。我们可以将其编写为直接编码toy方言中的操作约束的PASS，并且这似乎是一个可以通用编写的转换的很好选择。作为一个好的经验法则，最好尽可能通用地表达转换，以便将来可以扩展到其他方言。不知道还有多少其他方言可能有类似的需求或遇到同样的问题。</p>
			<p data-pid="mNjcM0J-">对于形状推断，如果我们将问题分解到其核心，我们实际上只希望操作告诉我们给定一组静态已知输入的预期输出。(我们当然可以变得更复杂，但根据我们的需要，我们可以保持简单。)鉴于此属性是特定操作的核心，我们可以定义一个操作接口，该接口可以在需要推断其结果形状的操作上指定。</p>
			<p data-pid="AExW6QDZ">与操作类似，我们也可以使用操作定义规范(ODS)框架
				<a href="../OpDefinitions.md#operation-interfaces" class="internal">定义操作interfaces</a>
				]。
			</p>
			<p data-pid="xvYj85uR">接口是通过继承
				<code>OpInterface</code>
				定义的，
				<code>OpInterface</code>
				将生成的C++接口类的名称作为模板参数。出于我们的目的，我们将简单地将生成的类命名为
				<code>ShapeInference</code>
				。我们还提供了接口的描述。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ShapeInferenceOpInterface : OpInterface&lt;&#34;ShapeInference&#34;&gt; {
  let description = [{
    Interface to access a registered method to infer the return types for an
    operation that can be used during type inference.
  }];
}</code>
				</pre>
			</div>
			<p data-pid="4sFSpsFB">接下来，我们定义操作需要提供的接口方法。接口方法包括：描述；字符串形式的C++返回类型；字符串形式的方法名称；以及一些可选组件，具体取决于需要。有关详细信息，请参阅
				<a href="../OpDefinitions.md#operation-interfaces" class="internal">ODS&nbsp;documentation</a>
				]。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ShapeInferenceOpInterface : OpInterface&lt;&#34;ShapeInference&#34;&gt; {
  ...

  let methods = [
    InterfaceMethod&lt;&#34;Infer and set the output shape for the current operation.&#34;,
                    &#34;void&#34;, &#34;inferShapes&#34;&gt;
  ];
}</code>
				</pre>
			</div>
			<p data-pid="iTsjJ7Z7">现在接口已经定义好了，我们可以将其添加到必要的Toy操作中，方法与将
				<code>CallOpInterface</code>
				添加到GenericCallOp中的方式类似：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def MulOp : Toy_Op&lt;&#34;mul&#34;,
    [..., DeclareOpInterfaceMethods&lt;ShapeInferenceOpInterface&gt;]&gt; {
  ...
}</code>
				</pre>
			</div>
			<p data-pid="6p3p6hkb">然后，这些操作中的每个操作都需要为
				<code>inferShapes()</code>
				方法提供定义。例如，对于mul&nbsp;op，结果形状被推断为输入的形状。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Infer the output shape of the MulOp, this is required by the shape inference
</span><span class="c1">/// interface.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">MulOp</span><span class="o">::</span><span class="n">inferShapes</span><span class="p">()</span> <span class="p">{</span> <span class="n">getResult</span><span class="p">().</span><span class="n">setType</span><span class="p">(</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getType</span><span class="p">());</span> <span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="7i2zAnOY">此时，每个必要的toy操作都提供了一种机制来推断它们的输出形状。ShapeInferencePass是一个FunctionPass：它将在每个函数上独立运行。MLIR还支持在任何孤立操作(即其他类似函数的操作)上运行的通用
				<a href="../PassManagement.md#operation-pass" class="internal">OperationPasses</a>
				，但这里我们的模块只包含函数，因此不需要对所有操作进行泛化。
			</p>
			<p data-pid="tcaxj_kS">通过创建一个继承自
				<code>mlir：：FunctionPass</code>
				的类并覆盖
				<code>runOnFunction()</code>
				方法来实现这样的传递。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="k">class</span> <span class="nc">ShapeInferencePass</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">PassWrapper</span><span class="o">&lt;</span><span class="n">ShapeInferencePass</span><span class="p">,</span> <span class="n">FunctionPass</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="nf">runOnFunction</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">FuncOp</span> <span class="n">function</span> <span class="o">=</span> <span class="n">getFunction</span><span class="p">();</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="CxaJzcJg">同时，让我们还创建一个用于实例化该过程的帮助器方法：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Pass</span><span class="o">&gt;</span> <span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">createShapeInferencePass</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ShapeInferencePass</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="PlywsY47">形状推断算法的操作如下：</p>
			<ol>
				<li data-pid="IuV0Vp8f">构建一个包含返回动态形状张量的所有操作的工作列表：这些操作需要进行形状推断。</li>
			</ol>
			<p data-pid="CL1BVFkN">2.&nbsp;在工作列表上迭代：</p>
			<ul>
				<ul>
					<li data-pid="7pdc6Pl7">查找要处理的操作：工作列表中的下一个就绪操作所有参数都非范型（non&ndash;generic），</li>
					<li data-pid="owH5g-D2">如果找不到任何操作，则中断循环，</li>
					<li data-pid="pP4qYX3t">从工作列表中删除该操作，</li>
					<li data-pid="gHM8rWYp">从参数类型推断其输出的形状。</li>
				</ul>
			</ul>
			<p data-pid="WMruQMjH">3.&nbsp;如果工作列表为空，则算法成功。</p>
			<p data-pid="yAEyIXtn">在处理上述操作时，我们使用以下代码片段查询它是否注册了
				<code>ShapeInference</code>
				接口：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">// Ask the operation to infer its output shapes.
</span><span class="c1"></span>  <span class="n">LLVM_DEBUG</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Inferring shape for: &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">op</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

  <span class="c1">/// We check if an operation has a particular interface by casting.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">ShapeInference</span> <span class="n">shapeOp</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ShapeInference</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">shapeOp</span><span class="p">.</span><span class="n">inferShapes</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">emitError</span><span class="p">(</span><span class="s">&#34;unable to infer shape of operation without shape &#34;</span>
                  <span class="s">&#34;inference interface&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">signalPassFailure</span><span class="p">();</span>
  <span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="ebTFdUNs">然后，我们可以将通行证添加到pass管理器：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createShapeInferencePass</span><span class="p">());</span>
</code>
				</pre>
			</div>
			<p data-pid="4WSQfLH5">如果我们重新运行原始示例，现在会得到以下结果：</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @main() {
  %0 = &#34;toy.constant&#34;() {value = dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;} : () -&gt; tensor&lt;2x3xf64&gt;
  %1 = &#34;toy.transpose&#34;(%0) : (tensor&lt;2x3xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;
  %2 = &#34;toy.mul&#34;(%1, %1) : (tensor&lt;3x2xf64&gt;, tensor&lt;3x2xf64&gt;) -&gt; tensor&lt;3x2xf64&gt;
  toy.print %2 : tensor&lt;3x2xf64&gt;
  toy.return
}</code>
				</pre>
			</div>
			<p data-pid="TB29d7LH">您可以构建
				<code>toyc&ndash;ch4</code>
				并亲自试用：
				<code>toyc&ndash;ch4&nbsp;test/examples/Toy/ch4/codegen.toy&nbsp;&ndash;emit=mlir&nbsp;&ndash;opt</code>
				。
			</p>
			<p data-pid="MVspJgpL">在
				<a href="CH-5.md" class="internal">下一章</a>
				中，我们将以较低级别的方言为目标开始代码生成过程，以优化一些计算量较大的toy操作。
			</p>
		</div>
	<!-- AutoExtract End-->
		</div>

		<hr/>
		<H2><a name="HEAD_4" href="#TOC_HEAD_4">MLIR入门教程5 降级到低级方言 知乎</a></H2>
		<div>
<!-- AutoExtract Begin-->
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Wed Oct 18 21:41:38 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/437397082" target="_blank">
				<font color="red" size="3">MLIR入门教程5&ndash;降级到低级方言&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<blockquote data-first-child data-pid="YnBG5npf">本文翻译自MLIR社区官方文档，受限于笔者个人的认知水平，翻译效果可能不是很理想，翻译原始文档也会放在github上，供大家参考，如发现问题也欢迎提PR或者Issue:</blockquote>
			<a target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/hunterzju/llvm-tutorial" data-draft-node="block" data-draft-type="link-card" data-text="https://github.com/hunterzju/llvm-tutorial" class="LinkCard new">
				<span class="LinkCard-contents">
					<span class="LinkCard-title loading" data-text="true"></span>
					<span class="LinkCard-desc loading"></span>
				</span>
				<span class="LinkCard-image LinkCard-image--default"></span>
			</a>
			<h2>第5章：部分降级到更低级别的方言以进行优化</h2>
			<p data-pid="4aHoXuyK">现在，我们渴望生成实际的代码，并看到我们的Toy语言诞生。我们将使用LLVM生成代码，但是在这里仅仅显示LLVM构建器接口不会非常令人兴奋。取而代之的是，我们将展示如何通过在同一函数中共存的混合方言来执行渐进式降级。</p>
			<p data-pid="AvNXSr4k">为了更有趣，在本章中，我们将考虑重用现有的优化，该优化是一种用方言实现的仿射变换：
				<code>Affine</code>
				。这种方言是为程序的计算量大的部分量身定做的，而且是有限的：例如，它不支持表示我们的
				<code>toy.print</code>
				内置函数，也不应该支持！相反，我们可以将
				<code>Affine</code>
				作为Toy的计算量较大的部分，并在
				<a href="zh-Ch-6.md" class="internal">下一章</a>
				中直接将
				<code>LLVM&nbsp;IR</code>
				方言作为
				<code>print</code>
				的降低目标。作为降低的一部分，我们将从
				<code>Toy</code>
				操作的
				<a href="../LangRef.md#tensor-type" class="internal">TensorType</a>
				降低到通过仿射循环嵌套索引的
				<a href="../LangRef.md#memref-type" class="internal">MemRefType</a>
				。张量表示抽象值类型的数据序列，这意味着它们不存在于任何内存中。另一方面，MemRef表示较低级别的缓冲区访问，因为它们是对内存区域的具体引用。
			</p>
			<h2>方言转换</h2>
			<p data-pid="ap-7yLSV">MLIR有许多不同的方言，因此在它们之间有一个统一的
				<a href="getting_started/Glossary.md#conversion" class="internal">converting</a>
				框架是很重要的。这就是
				<code>DialectConversion</code>
				框架发挥作用的地方。此框架允许将一组
				<i>非法</i>
				操作转换为一组
				<i>合法</i>
				操作。要使用此框架，我们需要提供两个条件(以及可选的第三个条件)：
			</p>
			<ul>
				<li data-pid="IRhbmVWA">一个
					<a href="../DialectConversion.md#CONVERSION-TARGET" class="internal">转换目标</a>
				</li>
				<li data-pid="3Vj8TWGQ">这是一个正式规范，规定了哪些操作或方言对于转换是合法的。不合法的操作将需要重写模式来执行
					<a href="getting_started/Glossary.md#legalization" class="internal">legalization</a>
					.
				</li>
				<li data-pid="pg2vCP0K">一组
					<a href="../DialectConversion.md#rewrite-pattern-specification" class="internal">Rewrite&nbsp;Patterns</a>
				</li>
				<li data-pid="Aop7QEjy">这是一组
					<a href="QuickstartRewrites.md" class="internal">Patterns</a>
					，用于将
					<i>非法</i>
					操作转换为一组零个或多个
					<i>合法</i>
					操作。
				</li>
				<li data-pid="6GKejodI">(可选)一个
					<a href="../DialectConversion.md#type-conversion" class="internal">Type&nbsp;Converter</a>
					.
				</li>
				<li data-pid="0PRJj6so">如果提供，它用于转换模块参数的类型。我们的转换不需要这个。</li>
			</ul>
			<h2>转换目标</h2>
			<p data-pid="N6MPYMWD">出于我们的目的，我们希望将计算密集型的
				<code>toy</code>
				运算转换为来自
				<code>Affine``Standard</code>
				方言的运算组合，以便进一步优化。要开始降低，我们首先定义转换目标：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="kt">void</span> <span class="n">ToyToAffineLoweringPass</span><span class="o">::</span><span class="n">runOnFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// The first thing to define is the conversion target. This will define the
</span><span class="c1"></span>  <span class="c1">// final target for this lowering.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">ConversionTarget</span> <span class="n">target</span><span class="p">(</span><span class="n">getContext</span><span class="p">());</span>

  <span class="c1">// We define the specific operations, or dialects, that are legal targets for
</span><span class="c1"></span>  <span class="c1">// this lowering. In our case, we are lowering to a combination of the
</span><span class="c1"></span>  <span class="c1">// `Affine` and `Standard` dialects.
</span><span class="c1"></span>  <span class="n">target</span><span class="p">.</span><span class="n">addLegalDialect</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">AffineDialect</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">StandardOpsDialect</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// We also define the Toy dialect as Illegal so that the conversion will fail
</span><span class="c1"></span>  <span class="c1">// if any of these operations are *not* converted. Given that we actually want
</span><span class="c1"></span>  <span class="c1">// a partial lowering, we explicitly mark the Toy operations that don&#39;t want
</span><span class="c1"></span>  <span class="c1">// to lower, `toy.print`, as *legal*.
</span><span class="c1"></span>  <span class="n">target</span><span class="p">.</span><span class="n">addIllegalDialect</span><span class="o">&lt;</span><span class="n">ToyDialect</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">target</span><span class="p">.</span><span class="n">addLegalOp</span><span class="o">&lt;</span><span class="n">PrintOp</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="q_s3Gcpz">在上面，我们首先将Toy方言设置为非法，然后将打印操作设置为合法。我们可以反过来做这件事。单个操作始终优先于(更通用的)方言定义，因此顺序无关紧要。详见
				<code>ConversionTarget::getOpInfo</code>
				。
			</p>
			<h2>转换模式</h2>
			<p data-pid="5KSyFnAF">定义转换目标后，我们可以定义如何将
				<i>非法</i>
				操作转换为
				<i>合法</i>
				操作。与
				<a href="zh-Ch-3.md" class="internal">第3章</a>
				中介绍的规范化框架类似，
				<code>
					<a href="https://link.zhihu.com/?target=https%3A//%253C/code%253Ezhuanlan.zhihu.com/DialectConversion.md" class=" wrap external" target="_blank" rel="nofollow noreferrer">DialectConversion框架</a>
					也使用
					<a href="QuickstartRewrites.md" class="internal">RewritePatterns</a>
					来执行转换逻辑。这些模式可以是以前看到的RewritePatterns，也可以是转换框架ConversionPattern特有的新类型的模式。ConversionPatterns与传统的RewritePatterns不同之处在于，它们接受包含已重新映射/替换的操作数的额外的operands参数。这是在处理类型转换时使用的，因为模式希望对新类型的值进行操作，但与旧类型的值匹配。对于我们的降级，此不变量将非常有用，因为它将当前正在操作的
					<a href="../LangRef.md#tensor-type" class="internal">TensorType</a>
					转换为
					<a href="../LangRef.md#memref-type" class="internal">MemRefType</a>
					。让我们来看一段降低toy.transspose操作的代码片段：
				</code>
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Lower the `toy.transpose` operation to an affine loop nest.
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">TransposeOpLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">ConversionPattern</span> <span class="p">{</span>
  <span class="n">TransposeOpLowering</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">mlir</span><span class="o">::</span><span class="n">ConversionPattern</span><span class="p">(</span><span class="n">TransposeOp</span><span class="o">::</span><span class="n">getOperationName</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">/// Match and rewrite the given `toy.transpose` operation, with the given
</span><span class="c1"></span>  <span class="c1">/// operands that have been remapped from `tensor&lt;...&gt;` to `memref&lt;...&gt;`.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span>
  <span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">operands</span><span class="p">,</span>
                  <span class="n">mlir</span><span class="o">::</span><span class="n">ConversionPatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span> <span class="k">const</span> <span class="k">final</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getLoc</span><span class="p">();</span>

    <span class="c1">// Call to a helper function that will lower the current operation to a set
</span><span class="c1"></span>    <span class="c1">// of affine loops. We provide a functor that operates on the remapped
</span><span class="c1"></span>    <span class="c1">// operands, as well as the loop induction variables for the inner most
</span><span class="c1"></span>    <span class="c1">// loop body.
</span><span class="c1"></span>    <span class="n">lowerOpToLoops</span><span class="p">(</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">operands</span><span class="p">,</span> <span class="n">rewriter</span><span class="p">,</span>
        <span class="p">[</span><span class="n">loc</span><span class="p">](</span><span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">,</span>
              <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">memRefOperands</span><span class="p">,</span>
              <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">loopIvs</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Generate an adaptor for the remapped operands of the TransposeOp.
</span><span class="c1"></span>          <span class="c1">// This allows for using the nice named accessors that are generated
</span><span class="c1"></span>          <span class="c1">// by the ODS. This adaptor is automatically provided by the ODS
</span><span class="c1"></span>          <span class="c1">// framework.
</span><span class="c1"></span>          <span class="n">TransposeOpAdaptor</span> <span class="nf">transposeAdaptor</span><span class="p">(</span><span class="n">memRefOperands</span><span class="p">);</span>
          <span class="n">mlir</span><span class="o">::</span><span class="n">Value</span> <span class="n">input</span> <span class="o">=</span> <span class="n">transposeAdaptor</span><span class="p">.</span><span class="n">input</span><span class="p">();</span>

          <span class="c1">// Transpose the elements by generating a load from the reverse
</span><span class="c1"></span>          <span class="c1">// indices.
</span><span class="c1"></span>          <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">reverseIvs</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">loopIvs</span><span class="p">));</span>
          <span class="k">return</span> <span class="n">rewriter</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">AffineLoadOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">reverseIvs</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="k">return</span> <span class="nf">success</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="2GGETFqD">现在我们可以准备在下降过程中使用的pattern列表：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="kt">void</span> <span class="n">ToyToAffineLoweringPass</span><span class="o">::</span><span class="n">runOnFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">// Now that the conversion target has been defined, we just need to provide
</span><span class="c1"></span>  <span class="c1">// the set of patterns that will lower the Toy operations.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">OwningRewritePatternList</span> <span class="n">patterns</span><span class="p">;</span>
  <span class="n">patterns</span><span class="p">.</span><span class="n">insert</span><span class="o">&lt;</span><span class="p">...,</span> <span class="n">TransposeOpLowering</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>

  <span class="p">...</span>
</code>
				</pre>
			</div>
			<h2>局部下降</h2>
			<p data-pid="6RGGhYpi">一旦定义了模式，我们就可以执行实际的下降。
				<code>DialectConversion</code>
				框架提供了几种不同的下调模式，但考虑到我们的目的，我们将执行部分下降，因为我们此时不会转换
				<code>toy.print</code>
				。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="kt">void</span> <span class="n">ToyToAffineLoweringPass</span><span class="o">::</span><span class="n">runOnFunction</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>

  <span class="c1">// With the target and rewrite patterns defined, we can now attempt the
</span><span class="c1"></span>  <span class="c1">// conversion. The conversion will signal failure if any of our *illegal*
</span><span class="c1"></span>  <span class="c1">// operations were not converted successfully.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">function</span> <span class="o">=</span> <span class="n">getFunction</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">failed</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">applyPartialConversion</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">patterns</span><span class="p">)))</span>
    <span class="n">signalPassFailure</span><span class="p">();</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<h3>部分降低时的设计注意事项</h3>
			<p data-pid="jdfbzXX7">在深入研究我们降低的结果之前，现在是讨论部分降低时潜在的设计注意事项的好时机。在我们的降级过程中，我们从原始类型TensorType转换为分配的(类似缓冲区的)类型MemRefType。但是，如果我们不降低
				<code>toy.print</code>
				操作，我们需要临时桥接这两个世界。有很多方法可以做到这一点，每种方法都有自己的tradeoff：
			</p>
			<ul>
				<li data-pid="s8W5HxD3">从缓冲区生成
					<code>load</code>
					操作
				</li>
			</ul>
			<p data-pid="HfLdbOuN">一种选择是从缓冲区类型生成
				<code>load</code>
				操作，以实体化值类型的实例。这允许
				<code>toy.print</code>
				操作的定义保持不变。这种方法的缺点是，对
				<code>affine</code>
				方言的优化是有限的，因为
				<code>load</code>
				实际上会涉及到一个仅可见的完整副本
				<i>之后</i>
				我们已经执行了优化。&nbsp;*&nbsp;生成新版本的
				<code>toy.print</code>
				，它在降低的类型上操作
			</p>
			<p data-pid="3jfY7r3U">另一种选择是让
				<code>toy.print</code>
				的另一个降低变种在降低的类型上操作。此选项的好处是没有到优化器的隐藏的、不必要的副本。缺点是需要另一个操作定义，它可能会重复第一个操作的许多方面。在
				<a href="../OpDefinitions.md" class="internal">ODS</a>
				中定义基类可能会简化这一过程，但您仍然需要单独处理这些操作。&nbsp;*&nbsp;更新
				<code>toy.print</code>
				以允许在降低的类型上操作
			</p>
			<p data-pid="E7nXw9fh">第三个选项是更新
				<code>toy.print</code>
				的当前定义，以允许在降低的类型上操作。这种方法的好处是它很简单，不会引入额外的隐藏副本，也不需要另一个操作定义。此选项的缺点是，它需要混合
				<code>Toy</code>
				方言的抽象层。
			</p>
			<p data-pid="5ylXt0d9">为简单起见，我们将使用第三个选项来降低。这涉及更新操作定义文件中PrintOp的类型约束：</p>
			<div class="highlight">
				<pre>
<code class="language-text">def PrintOp : Toy_Op&lt;&#34;print&#34;&gt; {
  ...

  // The print operation takes an input tensor to print.
  // We also allow a F64MemRef to enable interop during partial lowering.
  let arguments = (ins AnyTypeOf&lt;[F64Tensor, F64MemRef]&gt;:$input);
}</code>
				</pre>
			</div>
			<h2>完整的Toy示例</h2>
			<p data-pid="-rux_LcQ">让我们举一个具体的例子：</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @main() {
  %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;
  %2 = toy.transpose(%0 : tensor&lt;2x3xf64&gt;) to tensor&lt;3x2xf64&gt;
  %3 = toy.mul %2, %2 : tensor&lt;3x2xf64&gt;
  toy.print %3 : tensor&lt;3x2xf64&gt;
  toy.return
}</code>
				</pre>
			</div>
			<p data-pid="TDdNtHcA">通过将仿射降低添加到我们的管道中，我们现在可以生成：</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @main() {
  %cst = constant 1.000000e+00 : f64
  %cst_0 = constant 2.000000e+00 : f64
  %cst_1 = constant 3.000000e+00 : f64
  %cst_2 = constant 4.000000e+00 : f64
  %cst_3 = constant 5.000000e+00 : f64
  %cst_4 = constant 6.000000e+00 : f64

  // Allocating buffers for the inputs and outputs.
  %0 = alloc() : memref&lt;3x2xf64&gt;
  %1 = alloc() : memref&lt;3x2xf64&gt;
  %2 = alloc() : memref&lt;2x3xf64&gt;

  // Initialize the input buffer with the constant values.
  affine.store %cst, %2[0, 0] : memref&lt;2x3xf64&gt;
  affine.store %cst_0, %2[0, 1] : memref&lt;2x3xf64&gt;
  affine.store %cst_1, %2[0, 2] : memref&lt;2x3xf64&gt;
  affine.store %cst_2, %2[1, 0] : memref&lt;2x3xf64&gt;
  affine.store %cst_3, %2[1, 1] : memref&lt;2x3xf64&gt;
  affine.store %cst_4, %2[1, 2] : memref&lt;2x3xf64&gt;

  // Load the transpose value from the input buffer and store it into the
  // next input buffer.
  affine.for %arg0 = 0 to 3 {
    affine.for %arg1 = 0 to 2 {
      %3 = affine.load %2[%arg1, %arg0] : memref&lt;2x3xf64&gt;
      affine.store %3, %1[%arg0, %arg1] : memref&lt;3x2xf64&gt;
    }
  }

  // Multiply and store into the output buffer.
  affine.for %arg0 = 0 to 3 {
    affine.for %arg1 = 0 to 2 {
      %3 = affine.load %1[%arg0, %arg1] : memref&lt;3x2xf64&gt;
      %4 = affine.load %1[%arg0, %arg1] : memref&lt;3x2xf64&gt;
      %5 = mulf %3, %4 : f64
      affine.store %5, %0[%arg0, %arg1] : memref&lt;3x2xf64&gt;
    }
  }

  // Print the value held by the buffer.
  toy.print %0 : memref&lt;3x2xf64&gt;
  dealloc %2 : memref&lt;2x3xf64&gt;
  dealloc %1 : memref&lt;3x2xf64&gt;
  dealloc %0 : memref&lt;3x2xf64&gt;
  return
}</code>
				</pre>
			</div>
			<h2>利用仿射优化的优势</h2>
			<p data-pid="WYakOV0K">我们原生的降低是对的，但在效率上还有很多不尽如人意的地方。例如，
				<code>toy.mul</code>
				的降低产生了一些冗余负载。让我们看看向流程中添加一些现有的优化如何帮助清理这一问题。将
				<code>LoopFusion</code>
				和
				<code>MemRefDataFlowOpt</code>
				pass添加到流程中会得到以下结果：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @main() {
  %cst = constant 1.000000e+00 : f64
  %cst_0 = constant 2.000000e+00 : f64
  %cst_1 = constant 3.000000e+00 : f64
  %cst_2 = constant 4.000000e+00 : f64
  %cst_3 = constant 5.000000e+00 : f64
  %cst_4 = constant 6.000000e+00 : f64

  // Allocating buffers for the inputs and outputs.
  %0 = alloc() : memref&lt;3x2xf64&gt;
  %1 = alloc() : memref&lt;2x3xf64&gt;

  // Initialize the input buffer with the constant values.
  affine.store %cst, %1[0, 0] : memref&lt;2x3xf64&gt;
  affine.store %cst_0, %1[0, 1] : memref&lt;2x3xf64&gt;
  affine.store %cst_1, %1[0, 2] : memref&lt;2x3xf64&gt;
  affine.store %cst_2, %1[1, 0] : memref&lt;2x3xf64&gt;
  affine.store %cst_3, %1[1, 1] : memref&lt;2x3xf64&gt;
  affine.store %cst_4, %1[1, 2] : memref&lt;2x3xf64&gt;

  affine.for %arg0 = 0 to 3 {
    affine.for %arg1 = 0 to 2 {
      // Load the transpose value from the input buffer.
      %2 = affine.load %1[%arg1, %arg0] : memref&lt;2x3xf64&gt;

      // Multiply and store into the output buffer.
      %3 = mulf %2, %2 : f64
      affine.store %3, %0[%arg0, %arg1] : memref&lt;3x2xf64&gt;
    }
  }

  // Print the value held by the buffer.
  toy.print %0 : memref&lt;3x2xf64&gt;
  dealloc %1 : memref&lt;2x3xf64&gt;
  dealloc %0 : memref&lt;3x2xf64&gt;
  return
}</code>
				</pre>
			</div>
			<p data-pid="NYQPAApW">在这里，我们可以看到，删除了冗余分配，融合了两个循环嵌套，并删除了一些不必要的
				<code>load</code>
				操作。您可以构建
				<code>toyc&ndash;ch5</code>
				并亲自试用：
				<code>toyc&ndash;ch5&nbsp;test/examples/Toy/CH5/affine&ndash;lowering.mlir&nbsp;&ndash;emit=mlir&nbsp;&ndash;affine</code>
				。我们也可以通过添加
				<code>&ndash;opt</code>
				来检查我们的优化。
			</p>
			<p data-pid="UMkPEKfw">在这一章中，我们探讨了局部降低的一些方面，目的是进行优化。在
				<a href="zh-Ch-6.md" class="internal">下一章</a>
				中，我们将继续讨论方言转换，将LLVM作为代码生成的目标。
			</p>
		</div>
	<!-- AutoExtract End-->
		</div>

		<hr/>
		<H2><a name="HEAD_5" href="#TOC_HEAD_5">MLIR入门教程6 降低到LLVM并生成代码 知乎</a></H2>
		<div>
<!-- AutoExtract Begin-->
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Wed Oct 18 21:41:07 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/437814394" target="_blank">
				<font color="red" size="3">MLIR入门教程6&ndash;降低到LLVM并生成代码&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<blockquote data-first-child data-pid="g117ctKD">本文翻译自MLIR社区官方文档，受限于笔者个人的认知水平，翻译效果可能不是很理想，翻译原始文档也会放在github上，供大家参考，如发现问题也欢迎提PR或者Issue:</blockquote>
			<a target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/hunterzju/llvm-tutorial" data-draft-node="block" data-draft-type="link-card" data-text="https://github.com/hunterzju/llvm-tutorial" class="LinkCard new">
				<span class="LinkCard-contents">
					<span class="LinkCard-title loading" data-text="true"></span>
					<span class="LinkCard-desc loading"></span>
				</span>
				<span class="LinkCard-image LinkCard-image--default"></span>
			</a>
			<h2>第6章：降低到LLVM和代码生成</h2>
			<p data-pid="-R2GSBFw">在
				<a href="zh-Ch-5.md" class="internal">上一章</a>
				中，我们介绍了
				<a href="../DialectConversion.md" class="internal">方言转换</a>
				框架，并将很多
				<code>toy</code>
				操作部分降为仿射循环嵌套进行优化。在本章中，我们将最终降低到LLVM进行代码生成。
			</p>
			<h2>降低到LLVM</h2>
			<p data-pid="fRreMPB5">对于这一下降，我们将再次使用方言转换框架来执行繁琐的工作。但是，这次我们将执行到
				<a href="../%E6%96%B9%E8%A8%80/LLVM.md" class="internal">LLVM方言</a>
				的完全转换。谢天谢地，我们已经降低了所有的
				<code>toy</code>
				操作，只有一个除外，最后一个是
				<code>toy.print</code>
				。在完成到LLVM的转换之前，我们先降低
				<code>toy.print</code>
				操作。我们将此操作降低到为每个元素调用
				<code>printf</code>
				的非仿射循环嵌套。注意，因为方言转换框架支持
				<a href="getting_started/Glossary.md#transitive-lowering" class="internal">传递性lowering</a>
				，所以我们不需要用LLVM方言直接发出操作。通过传递性降低，我们的意思是转换框架可以应用多个模式来使操作完全合法化。在本例中，我们生成的是结构化循环嵌套，而不是LLVM方言中的分支形式。只要我们有一个从循环操作到LLVM的降级，降级仍然会成功。
			</p>
			<p data-pid="F3SV19Gp">在降低过程中，我们可以通过如下方式获得或构建printf的声明：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Return a symbol reference to the printf function, inserting it into the
</span><span class="c1">/// module if necessary.
</span><span class="c1"></span><span class="k">static</span> <span class="n">FlatSymbolRefAttr</span> <span class="nf">getOrInsertPrintf</span><span class="p">(</span><span class="n">PatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">,</span>
                                           <span class="n">ModuleOp</span> <span class="n">module</span><span class="p">,</span>
                                           <span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMDialect</span> <span class="o">*</span><span class="n">llvmDialect</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">module</span><span class="p">.</span><span class="n">getContext</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">lookupSymbol</span><span class="o">&lt;</span><span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMFuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;printf&#34;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SymbolRefAttr</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;printf&#34;</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>

  <span class="c1">// Create a function declaration for printf, the signature is:
</span><span class="c1"></span>  <span class="c1">//   * `i32 (i8*, ...)`
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">llvmI32Ty</span> <span class="o">=</span> <span class="n">IntegerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">llvmI8PtrTy</span> <span class="o">=</span>
      <span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMPointerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">IntegerType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
  <span class="k">auto</span> <span class="n">llvmFnType</span> <span class="o">=</span> <span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMFunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">llvmI32Ty</span><span class="p">,</span> <span class="n">llvmI8PtrTy</span><span class="p">,</span>
                                                <span class="cm">/*isVarArg=*/</span><span class="nb">true</span><span class="p">);</span>

  <span class="c1">// Insert the printf function into the body of the parent module.
</span><span class="c1"></span>  <span class="n">PatternRewriter</span><span class="o">::</span><span class="n">InsertionGuard</span> <span class="n">insertGuard</span><span class="p">(</span><span class="n">rewriter</span><span class="p">);</span>
  <span class="n">rewriter</span><span class="p">.</span><span class="n">setInsertionPointToStart</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">getBody</span><span class="p">());</span>
  <span class="n">rewriter</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">LLVM</span><span class="o">::</span><span class="n">LLVMFuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">module</span><span class="p">.</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&#34;printf&#34;</span><span class="p">,</span> <span class="n">llvmFnType</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">SymbolRefAttr</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="s">&#34;printf&#34;</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="ZK3u6q8G">既然已经定义了printf操作的降低，我们可以指定降低所需的组件。这些组件与
				<a href="zh-Ch-5.md" class="internal">上一章</a>
				中定义的组件基本相同。
			</p>
			<h3>转换目标</h3>
			<p data-pid="d56iINIe">对于此转换，除了顶级模块之外，我们将把所有内容都降低到LLVM方言。</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">mlir</span><span class="o">::</span><span class="n">ConversionTarget</span> <span class="n">target</span><span class="p">(</span><span class="n">getContext</span><span class="p">());</span>
  <span class="n">target</span><span class="p">.</span><span class="n">addLegalDialect</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">LLVMDialect</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">target</span><span class="p">.</span><span class="n">addLegalOp</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">ModuleTerminatorOp</span><span class="o">&gt;</span><span class="p">();</span>
</code>
				</pre>
			</div>
			<h3>类型转换器</h3>
			<p data-pid="4b8DuerA">这种降低还会将当前正在操作的MemRef类型转换为LLVM中的表示形式。要执行此转换，我们使用TypeConverter作为降级的一部分。此转换器指定一种类型如何映射到另一种类型。由于我们正在执行更复杂的涉及block参数的下降，使用转换器是必要的。假设我们没有任何需要降低的特定于Toy方言的类型，那么对于我们的用例来说，默认的转换器就足够了。</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">LLVMTypeConverter</span> <span class="nf">typeConverter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>
</code>
				</pre>
			</div>
			<h3>转换模式</h3>
			<p data-pid="zVNSDSn0">既然已经定义了转换目标，我们需要提供用于降低的模式。在编译过程中的这一点上，我们组合了
				<code>toy</code>
				、
				<code>affine</code>
				和
				<code>std</code>
				操作。幸运的是，
				<code>std</code>
				和
				<code>affine</code>
				方言已经提供了将它们转换为LLVM方言所需的模式集。这些模式允许通过依赖
				<a href="getting_started/Glossary.md#transitive-lowering" class="internal">传递性lowering</a>
				来通过多个阶段降低IR。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">mlir</span><span class="o">::</span><span class="n">OwningRewritePatternList</span> <span class="n">patterns</span><span class="p">;</span>
  <span class="n">mlir</span><span class="o">::</span><span class="n">populateAffineToStdConversionPatterns</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>
  <span class="n">mlir</span><span class="o">::</span><span class="n">populateLoopToStdConversionPatterns</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>
  <span class="n">mlir</span><span class="o">::</span><span class="n">populateStdToLLVMConversionPatterns</span><span class="p">(</span><span class="n">typeConverter</span><span class="p">,</span> <span class="n">patterns</span><span class="p">);</span>

  <span class="c1">// The only remaining operation, to lower from the `toy` dialect, is the
</span><span class="c1"></span>  <span class="c1">// PrintOp.
</span><span class="c1"></span>  <span class="n">patterns</span><span class="p">.</span><span class="n">insert</span><span class="o">&lt;</span><span class="n">PrintOpLowering</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">getContext</span><span class="p">());</span>
</code>
				</pre>
			</div>
			<h3>完全降级</h3>
			<p data-pid="_XUqao9w">我们希望完全降到LLVM，所以我们使用
				<code>FullConversion</code>
				。这确保在转换后只保留合法的操作。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span> <span class="n">module</span> <span class="o">=</span> <span class="n">getOperation</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">failed</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">applyFullConversion</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">patterns</span><span class="p">)))</span>
    <span class="n">signalPassFailure</span><span class="p">();</span>
</code>
				</pre>
			</div>
			<p data-pid="Rg8bA0ME">回过头来看我们当前的工作示例：</p>
			<div class="highlight">
				<pre>
<code class="language-text">func @main() {
  %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;
  %2 = toy.transpose(%0 : tensor&lt;2x3xf64&gt;) to tensor&lt;3x2xf64&gt;
  %3 = toy.mul %2, %2 : tensor&lt;3x2xf64&gt;
  toy.print %3 : tensor&lt;3x2xf64&gt;
  toy.return
}</code>
				</pre>
			</div>
			<p data-pid="GRCivqrc">现在，我们可以向下查看LLVM方言，它会生成以下代码：</p>
			<div class="highlight">
				<pre>
<code class="language-text">llvm.func @free(!llvm&lt;&#34;i8*&#34;&gt;)
llvm.func @printf(!llvm&lt;&#34;i8*&#34;&gt;, ...) -&gt; i32
llvm.func @malloc(i64) -&gt; !llvm&lt;&#34;i8*&#34;&gt;
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+00 : f64) : f64
  %1 = llvm.mlir.constant(2.000000e+00 : f64) : f64

  ...

^bb16:
  %221 = llvm.extractvalue %25[0 : index] : !llvm&lt;&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;&gt;
  %222 = llvm.mlir.constant(0 : index) : i64
  %223 = llvm.mlir.constant(2 : index) : i64
  %224 = llvm.mul %214, %223 : i64
  %225 = llvm.add %222, %224 : i64
  %226 = llvm.mlir.constant(1 : index) : i64
  %227 = llvm.mul %219, %226 : i64
  %228 = llvm.add %225, %227 : i64
  %229 = llvm.getelementptr %221[%228] : (!llvm.&#34;double*&#34;&gt;, i64) -&gt; !llvm&lt;&#34;f64*&#34;&gt;
  %230 = llvm.load %229 : !llvm&lt;&#34;double*&#34;&gt;
  %231 = llvm.call @printf(%207, %230) : (!llvm&lt;&#34;i8*&#34;&gt;, f64) -&gt; i32
  %232 = llvm.add %219, %218 : i64
  llvm.br ^bb15(%232 : i64)

  ...

^bb18:
  %235 = llvm.extractvalue %65[0 : index] : !llvm&lt;&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;&gt;
  %236 = llvm.bitcast %235 : !llvm&lt;&#34;double*&#34;&gt; to !llvm&lt;&#34;i8*&#34;&gt;
  llvm.call @free(%236) : (!llvm&lt;&#34;i8*&#34;&gt;) -&gt; ()
  %237 = llvm.extractvalue %45[0 : index] : !llvm&lt;&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;&gt;
  %238 = llvm.bitcast %237 : !llvm&lt;&#34;double*&#34;&gt; to !llvm&lt;&#34;i8*&#34;&gt;
  llvm.call @free(%238) : (!llvm&lt;&#34;i8*&#34;&gt;) -&gt; ()
  %239 = llvm.extractvalue %25[0 : index] : !llvm&lt;&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;&gt;
  %240 = llvm.bitcast %239 : !llvm&lt;&#34;double*&#34;&gt; to !llvm&lt;&#34;i8*&#34;&gt;
  llvm.call @free(%240) : (!llvm&lt;&#34;i8*&#34;&gt;) -&gt; ()
  llvm.return
}</code>
				</pre>
			</div>
			<p data-pid="pezHurxP">有关降低到LLVM方言的更多详细信息，请参见
				<a href="../ConversionToLLVMDialect.md" class="internal">转换为LLVM&nbsp;IR方言</a>
				。
			</p>
			<h2>CodeGen：摆脱MLIR</h2>
			<p data-pid="wgZnzQFD">此时，我们正处于代码生成的节骨眼。我们可以用LLVM方言生成代码，所以现在我们只需要导出到LLVM&nbsp;IR并设置一个JIT来运行它。</p>
			<h3>发射LLVM&nbsp;IR</h3>
			<p data-pid="O236actn">既然我们的模块只包含LLVM方言的操作，我们就可以导出到LLVM&nbsp;IR。要以编程方式完成此操作，我们可以调用以下实用程序：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">Module</span><span class="o">&gt;</span> <span class="n">llvmModule</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">::</span><span class="n">translateModuleToLLVMIR</span><span class="p">(</span><span class="n">module</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llvmModule</span><span class="p">)</span>
    <span class="cm">/* ... an error was encountered ... */</span>
</code>
				</pre>
			</div>
			<p data-pid="9lhJsjXs">将我们的模块导出到LLVM&nbsp;IR会生成：</p>
			<div class="highlight">
				<pre>
<code class="language-llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>

<span class="m">102</span><span class="err">:</span>
  <span class="n">%103</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">double</span><span class="p">*,</span> <span class="k">i64</span><span class="p">,</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">]</span> <span class="p">}</span> <span class="n">%8</span><span class="p">,</span> <span class="m">0</span>
  <span class="n">%104</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i64</span> <span class="n">%96</span><span class="p">,</span> <span class="m">2</span>
  <span class="n">%105</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="n">%104</span>
  <span class="n">%106</span> <span class="p">=</span> <span class="k">mul</span> <span class="k">i64</span> <span class="n">%100</span><span class="p">,</span> <span class="m">1</span>
  <span class="n">%107</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="n">%105</span><span class="p">,</span> <span class="n">%106</span>
  <span class="n">%108</span> <span class="p">=</span> <span class="k">getelementptr</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">*</span> <span class="n">%103</span><span class="p">,</span> <span class="k">i64</span> <span class="n">%107</span>
  <span class="n">%109</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">*</span> <span class="n">%108</span>
  <span class="n">%110</span> <span class="p">=</span> <span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@frmt_spec</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">),</span> <span class="kt">double</span> <span class="n">%109</span><span class="p">)</span>
  <span class="n">%111</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i64</span> <span class="n">%100</span><span class="p">,</span> <span class="m">1</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="n">%99</span>

  <span class="p">...</span>

<span class="m">115</span><span class="err">:</span>
  <span class="n">%116</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">double</span><span class="p">*,</span> <span class="k">i64</span><span class="p">,</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">]</span> <span class="p">}</span> <span class="n">%24</span><span class="p">,</span> <span class="m">0</span>
  <span class="n">%117</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span><span class="p">*</span> <span class="n">%116</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@free</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="n">%117</span><span class="p">)</span>
  <span class="n">%118</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">double</span><span class="p">*,</span> <span class="k">i64</span><span class="p">,</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">]</span> <span class="p">}</span> <span class="n">%16</span><span class="p">,</span> <span class="m">0</span>
  <span class="n">%119</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span><span class="p">*</span> <span class="n">%118</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@free</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="n">%119</span><span class="p">)</span>
  <span class="n">%120</span> <span class="p">=</span> <span class="k">extractvalue</span> <span class="p">{</span> <span class="kt">double</span><span class="p">*,</span> <span class="k">i64</span><span class="p">,</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">],</span> <span class="p">[</span><span class="m">2</span> <span class="k">x</span> <span class="k">i64</span><span class="p">]</span> <span class="p">}</span> <span class="n">%8</span><span class="p">,</span> <span class="m">0</span>
  <span class="n">%121</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="kt">double</span><span class="p">*</span> <span class="n">%120</span> <span class="k">to</span> <span class="k">i8</span><span class="p">*</span>
  <span class="k">call</span> <span class="kt">void</span> <span class="vg">@free</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="n">%121</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span></code>
				</pre>
			</div>
			<p data-pid="iuRZjb4u">如果我们对生成的LLVM&nbsp;IR启用优化，我们可以将其大幅削减：</p>
			<div class="highlight">
				<pre>
<code class="language-llvm"><span class="k">define</span> <span class="kt">void</span> <span class="vg">@main</span><span class="p">()</span>
  <span class="n">%0</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nonnull</span> <span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@frmt_spec</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">),</span> <span class="kt">double</span> <span class="m">1.000000e+00</span><span class="p">)</span>
  <span class="n">%1</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nonnull</span> <span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@frmt_spec</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">),</span> <span class="kt">double</span> <span class="m">1.600000e+01</span><span class="p">)</span>
  <span class="nv">%putchar</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@putchar</span><span class="p">(</span><span class="k">i32</span> <span class="m">10</span><span class="p">)</span>
  <span class="n">%2</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nonnull</span> <span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@frmt_spec</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">),</span> <span class="kt">double</span> <span class="m">4.000000e+00</span><span class="p">)</span>
  <span class="n">%3</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nonnull</span> <span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@frmt_spec</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">),</span> <span class="kt">double</span> <span class="m">2.500000e+01</span><span class="p">)</span>
  <span class="nv">%putchar.1</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@putchar</span><span class="p">(</span><span class="k">i32</span> <span class="m">10</span><span class="p">)</span>
  <span class="n">%4</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nonnull</span> <span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@frmt_spec</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">),</span> <span class="kt">double</span> <span class="m">9.000000e+00</span><span class="p">)</span>
  <span class="n">%5</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="p">(</span><span class="k">i8</span><span class="p">*,</span> <span class="p">...)</span> <span class="vg">@printf</span><span class="p">(</span><span class="k">i8</span><span class="p">*</span> <span class="k">nonnull</span> <span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">getelementptr</span> <span class="k">inbounds</span> <span class="p">([</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">],</span> <span class="p">[</span><span class="m">4</span> <span class="k">x</span> <span class="k">i8</span><span class="p">]*</span> <span class="vg">@frmt_spec</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="k">i64</span> <span class="m">0</span><span class="p">),</span> <span class="kt">double</span> <span class="m">3.600000e+01</span><span class="p">)</span>
  <span class="nv">%putchar.2</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="k">i32</span> <span class="vg">@putchar</span><span class="p">(</span><span class="k">i32</span> <span class="m">10</span><span class="p">)</span>
  <span class="k">ret</span> <span class="kt">void</span>
<span class="p">}</span></code>
				</pre>
			</div>
			<p data-pid="GoPonC-D">转储LLVM&nbsp;IR的完整代码清单可在
				<code>Examples/toy/ch6/toy.cpp</code>
				中的
				<code>dumpLLVMIR()</code>
				函数中：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="kt">int</span> <span class="nf">dumpLLVMIR</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span> <span class="n">module</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Translate the module, that contains the LLVM dialect, to LLVM IR. Use a
</span><span class="c1"></span>  <span class="c1">// fresh LLVM IR context. (Note that LLVM is not thread-safe and any
</span><span class="c1"></span>  <span class="c1">// concurrent use of a context requires external locking.)
</span><span class="c1"></span>  <span class="n">llvm</span><span class="o">::</span><span class="n">LLVMContext</span> <span class="n">llvmContext</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">llvmModule</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">::</span><span class="n">translateModuleToLLVMIR</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">llvmContext</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">llvmModule</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to emit LLVM IR</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Initialize LLVM targets.
</span><span class="c1"></span>  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeNativeTarget</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeNativeTargetAsmPrinter</span><span class="p">();</span>
  <span class="n">mlir</span><span class="o">::</span><span class="n">ExecutionEngine</span><span class="o">::</span><span class="n">setupTargetTriple</span><span class="p">(</span><span class="n">llvmModule</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>

  <span class="c1">/// Optionally run an optimization pipeline over the llvm module.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">optPipeline</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">::</span><span class="n">makeOptimizingTransformer</span><span class="p">(</span>
      <span class="cm">/*optLevel=*/</span><span class="n">EnableOpt</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/*sizeLevel=*/</span><span class="mi">0</span><span class="p">,</span>
      <span class="cm">/*targetMachine=*/</span><span class="k">nullptr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">err</span> <span class="o">=</span> <span class="n">optPipeline</span><span class="p">(</span><span class="n">llvmModule</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed to optimize LLVM IR &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">llvmModule</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<h3>设置JIT</h3>
			<p data-pid="XsNb4nR0">可以使用
				<code>mlir::ExecutionEngine</code>
				基础设施设置JIT来运行包含LLVM方言的模块。这是一个围绕LLVM的JIT的实用程序包装，接受
				<code>.mlir</code>
				作为输入。设置JIT的完整代码清单可以在
				<code>ch6/toyc.cpp</code>
				中的
				<code>runJit()</code>
				函数中找到：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="kt">int</span> <span class="nf">runJit</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">ModuleOp</span> <span class="n">module</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Initialize LLVM targets.
</span><span class="c1"></span>  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeNativeTarget</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeNativeTargetAsmPrinter</span><span class="p">();</span>

  <span class="c1">// An optimization pipeline to use within the execution engine.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">optPipeline</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">::</span><span class="n">makeOptimizingTransformer</span><span class="p">(</span>
      <span class="cm">/*optLevel=*/</span><span class="n">EnableOpt</span> <span class="o">?</span> <span class="mi">3</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/*sizeLevel=*/</span><span class="mi">0</span><span class="p">,</span>
      <span class="cm">/*targetMachine=*/</span><span class="k">nullptr</span><span class="p">);</span>

  <span class="c1">// Create an MLIR execution engine. The execution engine eagerly JIT-compiles
</span><span class="c1"></span>  <span class="c1">// the module.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">maybeEngine</span> <span class="o">=</span> <span class="n">mlir</span><span class="o">::</span><span class="n">ExecutionEngine</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">optPipeline</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">maybeEngine</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;failed to construct an execution engine&#34;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="o">&amp;</span><span class="n">engine</span> <span class="o">=</span> <span class="n">maybeEngine</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

  <span class="c1">// Invoke the JIT-compiled function.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">invocationResult</span> <span class="o">=</span> <span class="n">engine</span><span class="o">-&gt;</span><span class="n">invoke</span><span class="p">(</span><span class="s">&#34;main&#34;</span><span class="p">);</span><span class="err">类型</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">invocationResult</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;JIT invocation failed</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="DmvkeKwY">您可以从build目录使用它：</p>
			<div class="highlight">
				<pre>
<code class="language-text">$ echo &#39;def main() { print([[1, 2], [3, 4]]); }&#39; | ./bin/toyc-ch6 -emit=jit
1.000000 2.000000
3.000000 4.000000</code>
				</pre>
			</div>
			<p data-pid="MIwA8Fh2">您也可以通过
				<code>&ndash;emit=mlir</code>
				，
				<code>&ndash;emit=mlir&ndash;affine</code>
				，
				<code>&ndash;emit=mlir&ndash;llvm</code>
				，
				<code>&ndash;emit=llvm</code>
				来比较不同等级的IR。还可以尝试像
				<code>
					<a href="../PassManagement.md#ir-printing" class="internal">&ndash;&ndash;print&ndash;ir&ndash;after&ndash;all</a>
				</code>
				这样的选项来跟踪整个流程中IR的演变。
			</p>
			<p data-pid="pZLiW7um">本节使用的示例代码可以在
				<code>test/Examples/Toy/ch6/llvm&ndash;lowering.mlir</code>
				中找到。
			</p>
			<p data-pid="K7LcCmQX">到目前为止，我们已经使用了原始数据类型。在
				<a href="zh-Ch-7.md" class="internal">下一章</a>
				中，我们将添加一个复合的
				<code>struct</code>
				类型。
			</p>
		</div>
	<!-- AutoExtract End-->
		</div>

		<hr/>
		<H2><a name="HEAD_6" href="#TOC_HEAD_6">MLIR入门教程7 添加struct类型 知乎</a></H2>
		<div>
<!-- AutoExtract Begin-->
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Wed Oct 18 21:41:28 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/437820597" target="_blank">
				<font color="red" size="3">MLIR入门教程7&ndash;添加struct类型&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<blockquote data-first-child data-pid="w0yW2Scr">本文翻译自MLIR社区官方文档，受限于笔者个人的认知水平，翻译效果可能不是很理想，翻译原始文档也会放在github上，供大家参考，如发现问题也欢迎提PR或者Issue:</blockquote>
			<a target="_blank" href="https://link.zhihu.com/?target=https%3A//github.com/hunterzju/llvm-tutorial" data-draft-node="block" data-draft-type="link-card" data-text="https://github.com/hunterzju/llvm-tutorial" class="LinkCard new">
				<span class="LinkCard-contents">
					<span class="LinkCard-title loading" data-text="true"></span>
					<span class="LinkCard-desc loading"></span>
				</span>
				<span class="LinkCard-image LinkCard-image--default"></span>
			</a>
			<h2>第7章：向Toy添加复合类型</h2>
			<p data-pid="If6UoiLu">在
				<a href="zh-Ch-6.md" class="internal">上一章</a>
				中，我们演示了从Toy前端到LLVM&nbsp;IR的端到端编译流程。在本章中，我们将扩展Toy语言以支持新的复合
				<code>struct</code>
				类型。
			</p>
			<h2>在Toy中定义
				<code>struct</code>
			</h2>
			<p data-pid="omzDhKU1">我们需要定义的第一件事是用我们的&ldquo;Toy&rdquo;源语言定义这种类型的接口。Toy中
				<code>struct</code>
				类型的通用语法如下：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text"># A struct is defined by using the `struct` keyword followed by a name.
struct MyStruct {
  # Inside of the struct is a list of variable declarations without initializers
  # or shapes, which may also be other previously defined structs.
  var a;
  var b;
}</code>
				</pre>
			</div>
			<p data-pid="l4JR6Vwt">现在，通过使用结构的名称而不是
				<code>var</code>
				，可以在函数中将结构用作变量或参数。该结构的成员通过
				<code>.</code>
				访问运算符进行访问。
				<code>struct</code>
				类型的值可以用复合初始值设定项初始化，也可以用
				<code>{}</code>
				括起来的其他初始值设定项的逗号分隔列表进行初始化。示例如下所示：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">struct Struct {
  var a;
  var b;
}

# User defined generic function may operate on struct types as well.
def multiply_transpose(Struct value) {
  # We can access the elements of a struct via the &#39;.&#39; operator.
  return transpose(value.a) * transpose(value.b);
}

def main() {
  # We initialize struct values using a composite initializer.
  Struct value = {[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]};

  # We pass these arguments to functions like we do with variables.
  var c = multiply_transpose(value);
  print(c);
}</code>
				</pre>
			</div>
			<h2>在MLIR中定义
				<code>struct</code>
			</h2>
			<p data-pid="uOKn15z6">在MLIR中，我们还需要结构类型的表示形式。MLIR不能提供完全符合我们需要的类型，因此我们需要定义自己的类型。我们将简单地将我们的
				<code>struct</code>
				定义为一组元素类型的未命名容器。
				<code>struct</code>
				的名称及其元素只对我们的
				<code>toy</code>
				编译器的AST有用，所以我们不需要在MLIR表示中对其进行编码。
			</p>
			<h3>定义类型类</h3>
			<h3>定义类型类</h3>
			<p data-pid="ES9m03Z4">如
				<a href="zh-Ch-2.md" class="internal">第2章</a>
				中所述，MLIR中的
				<code>
					<a href="../LangRef.md#type-system" class="internal">Type</a>
				</code>
				对象是值类型的，并且依赖于拥有保存该类型的实际数据的内部存储对象。
				<code>Type</code>
				类本身充当内部
				<code>TypeStorage</code>
				对象的简单包装，该对象在
				<code>MLIRContext</code>
				的实例中是唯一的。在构造
				<code>Type</code>
				时，我们在内部只是构造并唯一化一个存储类的实例。
			</p>
			<p data-pid="0QeNJU8v">在定义包含参数数据的新
				<code>Type</code>
				时(例如
				<code>struct</code>
				类型，需要额外的信息来保存元素类型)，我们需要提供派生的存储类。没有额外数据的
				<code>singleton</code>
				类型(如
				<code>ef=&#34;https://zhuanlan.zhihu.com/LangRef.md#index&ndash;type&#34;&gt;indextype)不需要存储类，使用默认的TypeStorage。</code>
			</p>
			<h3>定义存储类</h3>
			<p data-pid="JGzz9D-v">类型存储对象包含构造和唯一类型实例所需的所有数据。派生存储类必须继承自基本
				<code>mlir::TypeStorage</code>
				，并提供一组别名和钩子，供
				<code>MLIRContext</code>
				用于唯一类型。下面是我们的
				<code>struct</code>
				类型的存储实例的定义，每个必需的要求都内联了详细说明：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// This class represents the internal storage of the Toy `StructType`.
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">StructTypeStorage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">TypeStorage</span> <span class="p">{</span>
  <span class="c1">/// The `KeyTy` is a required type that provides an interface for the storage
</span><span class="c1"></span>  <span class="c1">/// instance. This type will be used when uniquing an instance of the type
</span><span class="c1"></span>  <span class="c1">/// storage. For our struct type, we will unique each instance structurally on
</span><span class="c1"></span>  <span class="c1">/// the elements that it contains.
</span><span class="c1"></span>  <span class="k">using</span> <span class="n">KeyTy</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="c1">/// A constructor for the type storage instance.
</span><span class="c1"></span>  <span class="n">StructTypeStorage</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">elementTypes</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">elementTypes</span><span class="p">(</span><span class="n">elementTypes</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">/// Define the comparison function for the key type with the current storage
</span><span class="c1"></span>  <span class="c1">/// instance. This is used when constructing a new instance to ensure that we
</span><span class="c1"></span>  <span class="c1">/// haven&#39;t already uniqued an instance of the given key.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">KeyTy</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">key</span> <span class="o">==</span> <span class="n">elementTypes</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">/// Define a hash function for the key type. This is used when uniquing
</span><span class="c1"></span>  <span class="c1">/// instances of the storage.
</span><span class="c1"></span>  <span class="c1">/// Note: This method isn&#39;t necessary as both llvm::ArrayRef and mlir::Type
</span><span class="c1"></span>  <span class="c1">/// have hash functions available, so we could just omit this entirely.
</span><span class="c1"></span>  <span class="k">static</span> <span class="n">llvm</span><span class="o">::</span><span class="n">hash_code</span> <span class="n">hashKey</span><span class="p">(</span><span class="k">const</span> <span class="n">KeyTy</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">hash_value</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// Define a construction function for the key type from a set of parameters.
</span><span class="c1"></span>  <span class="c1">/// These parameters will be provided when constructing the storage instance
</span><span class="c1"></span>  <span class="c1">/// itself, see the `StructType::get` method further below.
</span><span class="c1"></span>  <span class="c1">/// Note: This method isn&#39;t necessary because KeyTy can be directly
</span><span class="c1"></span>  <span class="c1">/// constructed with the given parameters.
</span><span class="c1"></span>  <span class="k">static</span> <span class="n">KeyTy</span> <span class="nf">getKey</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">elementTypes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">KeyTy</span><span class="p">(</span><span class="n">elementTypes</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// Define a construction method for creating a new instance of this storage.
</span><span class="c1"></span>  <span class="c1">/// This method takes an instance of a storage allocator, and an instance of a
</span><span class="c1"></span>  <span class="c1">/// `KeyTy`. The given allocator must be used for *all* necessary dynamic
</span><span class="c1"></span>  <span class="c1">/// allocations used to create the type storage and its internal.
</span><span class="c1"></span>  <span class="k">static</span> <span class="n">StructTypeStorage</span> <span class="o">*</span><span class="nf">construct</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">TypeStorageAllocator</span> <span class="o">&amp;</span><span class="n">allocator</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">KeyTy</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Copy the elements from the provided `KeyTy` into the allocator.
</span><span class="c1"></span>    <span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">elementTypes</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">copyInto</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

    <span class="c1">// Allocate the storage instance and construct it.
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="p">(</span><span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="o">&lt;</span><span class="n">StructTypeStorage</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="n">StructTypeStorage</span><span class="p">(</span><span class="n">elementTypes</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// The following field contains the element types of the struct.
</span><span class="c1"></span>  <span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">elementTypes</span><span class="p">;</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<h3>定义类型类</h3>
			<p data-pid="CO_kl4Ur">定义存储类后，我们可以为用户可见的
				<code>StructType</code>
				类添加定义。这是我们将实际与之交互的类。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// This class defines the Toy struct type. It represents a collection of
</span><span class="c1">/// element types. All derived types in MLIR must inherit from the CRTP class
</span><span class="c1">/// &#39;Type::TypeBase&#39;. It takes as template parameters the concrete type
</span><span class="c1">/// (StructType), the base class to use (Type), and the storage class
</span><span class="c1">/// (StructTypeStorage).
</span><span class="c1"></span><span class="k">class</span> <span class="nc">StructType</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">::</span><span class="n">TypeBase</span><span class="o">&lt;</span><span class="n">StructType</span><span class="p">,</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="p">,</span>
                                               <span class="n">StructTypeStorage</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">/// Inherit some necessary constructors from &#39;TypeBase&#39;.
</span><span class="c1"></span>  <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">Base</span><span class="p">;</span>

  <span class="c1">/// Create an instance of a `StructType` with the given element types. There
</span><span class="c1"></span>  <span class="c1">/// *must* be at least one element type.
</span><span class="c1"></span>  <span class="k">static</span> <span class="n">StructType</span> <span class="nf">get</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">elementTypes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">elementTypes</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&#34;expected at least 1 element type&#34;</span><span class="p">);</span>

    <span class="c1">// Call into a helper &#39;get&#39; method in &#39;TypeBase&#39; to get a uniqued instance
</span><span class="c1"></span>    <span class="c1">// of this type. The first parameter is the context to unique in. The
</span><span class="c1"></span>    <span class="c1">// parameters after are forwarded to the storage instance.
</span><span class="c1"></span>    <span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">elementTypes</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">getContext</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">Base</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">elementTypes</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// Returns the element types of this struct type.
</span><span class="c1"></span>  <span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="o">&gt;</span> <span class="n">getElementTypes</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// &#39;getImpl&#39; returns a pointer to the internal storage instance.
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">getImpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">elementTypes</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// Returns the number of element type held by this struct.
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="nf">getNumElementTypes</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">getElementTypes</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="c-jjRAcx">我们在
				<code>Toy&nbsp;Dialect</code>
				构造函数中注册此类型的方式与我们处理操作的方式类似：
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">ToyDialect</span><span class="o">::</span><span class="n">ToyDialect</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span><span class="p">(</span><span class="n">getDialectNamespace</span><span class="p">(),</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">addTypes</span><span class="o">&lt;</span><span class="n">StructType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="GTHrtjT5">有了这个，我们现在可以在从Toy生成MLIR时使用我们的
				<code>StructType</code>
				。有关更多详细信息，请参见
				<code>Examples/toy/ch7/mlir/MLIRGen.cpp</code>
				。
			</p>
			<h3>解析和打印</h3>
			<p data-pid="Yyzk3zGM">此时，我们可以在MLIR生成和转换过程中使用我们的
				<code>StructType</code>
				，但不能输出或解析
				<code>.mlir</code>
				。为此，我们需要增加对
				<code>StructType</code>
				实例的解析和打印支持。这可以通过覆盖
				<code>Toy&nbsp;Dialect</code>
				上的
				<code>parseType</code>
				和
				<code>printType</code>
				方法来实现。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="k">class</span> <span class="nc">ToyDialect</span> <span class="o">:</span> <span class="k">public</span> <span class="n">mlir</span><span class="o">::</span><span class="n">Dialect</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">/// Parse an instance of a type registered to the toy dialect.
</span><span class="c1"></span>  <span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">parseType</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">DialectAsmParser</span> <span class="o">&amp;</span><span class="n">parser</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

  <span class="c1">/// Print an instance of a type registered to the toy dialect.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">printType</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">type</span><span class="p">,</span>
                 <span class="n">mlir</span><span class="o">::</span><span class="n">DialectAsmPrinter</span> <span class="o">&amp;</span><span class="n">printer</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code>
				</pre>
			</div>
			<p data-pid="3ZzlBIjU">这些方法采用允许轻松实现必要功能的高级解析器或打印类的实例。在开始实现之前，让我们先考虑一下打印的IR中的
				<code>struct</code>
				类型所需的语法。如
				<a href="../LangRef.md#dialect-types" class="internal">MLIR语言参考</a>
				中所述，方言类型通常表示为：
				<code>！dialect&ndash;namespace&lt;type&ndash;data&gt;</code>
				，在某些情况下可以使用漂亮的形式。我们的
				<code>toy</code>
				解析器和打印类的职责是提供
				<code>type&ndash;data</code>
				位。我们将我们的
				<code>StructType</code>
				定义为具有以下形式：
			</p>
			<div class="highlight">
				<pre><code class="language-text">struct-type ::= `struct` `&lt;` type (`,` type)* `&gt;`</code></pre>
			</div>
			<h3>解析</h3>
			<p data-pid="FlD74Fet">解析器的实现如下所示：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Parse an instance of a type registered to the toy dialect.
</span><span class="c1"></span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">ToyDialect</span><span class="o">::</span><span class="n">parseType</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">DialectAsmParser</span> <span class="o">&amp;</span><span class="n">parser</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Parse a struct type in the following form:
</span><span class="c1"></span>  <span class="c1">//   struct-type ::= `struct` `&lt;` type (`,` type)* `&gt;`
</span><span class="c1"></span>
  <span class="c1">// NOTE: All MLIR parser function return a ParseResult. This is a
</span><span class="c1"></span>  <span class="c1">// specialization of LogicalResult that auto-converts to a `true` boolean
</span><span class="c1"></span>  <span class="c1">// value on failure to allow for chaining, but may be used with explicit
</span><span class="c1"></span>  <span class="c1">// `mlir::failed/mlir::succeeded` as desired.
</span><span class="c1"></span>
  <span class="c1">// Parse: `struct` `&lt;`
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseKeyword</span><span class="p">(</span><span class="s">&#34;struct&#34;</span><span class="p">)</span> <span class="o">||</span> <span class="n">parser</span><span class="p">.</span><span class="n">parseLess</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">Type</span><span class="p">();</span>

  <span class="c1">// Parse the element types of the struct.
</span><span class="c1"></span>  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">elementTypes</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="c1">// Parse the current element type.
</span><span class="c1"></span>    <span class="n">llvm</span><span class="o">::</span><span class="n">SMLoc</span> <span class="n">typeLoc</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">getCurrentLocation</span><span class="p">();</span>
    <span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">elementType</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseType</span><span class="p">(</span><span class="n">elementType</span><span class="p">))</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// Check that the type is either a TensorType or another StructType.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elementType</span><span class="p">.</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">TensorType</span><span class="p">,</span> <span class="n">StructType</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">parser</span><span class="p">.</span><span class="n">emitError</span><span class="p">(</span><span class="n">typeLoc</span><span class="p">,</span> <span class="s">&#34;element type for a struct must either &#34;</span>
                                <span class="s">&#34;be a TensorType or a StructType, got: &#34;</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="n">elementType</span><span class="p">;</span>
      <span class="k">return</span> <span class="nf">Type</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">elementTypes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elementType</span><span class="p">);</span>

    <span class="c1">// Parse the optional: `,`
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">succeeded</span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseOptionalComma</span><span class="p">()));</span>

  <span class="c1">// Parse: `&gt;`
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseGreater</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">Type</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">StructType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">elementTypes</span><span class="p">);</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<h3>打印</h3>
			<p data-pid="j0P8vgyc">打印类的实现如下所示：</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Print an instance of a type registered to the toy dialect.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">ToyDialect</span><span class="o">::</span><span class="n">printType</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">type</span><span class="p">,</span>
                           <span class="n">mlir</span><span class="o">::</span><span class="n">DialectAsmPrinter</span> <span class="o">&amp;</span><span class="n">printer</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Currently the only toy type is a struct type.
</span><span class="c1"></span>  <span class="n">StructType</span> <span class="n">structType</span> <span class="o">=</span> <span class="n">type</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">StructType</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Print the struct type according to the parser format.
</span><span class="c1"></span>  <span class="n">printer</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;struct&lt;&#34;</span><span class="p">;</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">interleaveComma</span><span class="p">(</span><span class="n">structType</span><span class="p">.</span><span class="n">getElementTypes</span><span class="p">(),</span> <span class="n">printer</span><span class="p">);</span>
  <span class="n">printer</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="CDPFwSWe">在继续之前，让我们先来看一下展示我们现在拥有的功能的快速示例：</p>
			<div class="highlight">
				<pre><code class="language-text">struct Struct {
  var a;
  var b;
}

def multiply_transpose(Struct value) {
}</code></pre>
			</div>
			<p data-pid="ov2vcQcH">它会生成以下内容：</p>
			<div class="highlight">
				<pre>
<code class="language-text">module {
  func @multiply_transpose(%arg0: !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt;) {
    toy.return
  }
}</code>
				</pre>
			</div>
			<h3>在
				<code>StructType</code>
				上操作
			</h3>
			<p data-pid="DcMcPpxQ">现在已经定义了
				<code>struct</code>
				类型，我们可以往返于IR之间。下一步是添加对在我们的操作中使用它的支持。
			</p>
			<h3>更新现有操作</h3>
			<p data-pid="LirTxp_N">我们现有的一些操作需要更新以处理
				<code>StructType</code>
				。第一步是让ODS框架知道我们的Type，这样我们就可以在操作定义中使用它。下面是一个简单的示例：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">// Provide a definition for the Toy StructType for use in ODS. This allows for
// using StructType in a similar way to Tensor or MemRef.
def Toy_StructType :
    Type&lt;CPred&lt;&#34;$_self.isa&lt;StructType&gt;()&#34;&gt;, &#34;Toy struct type&#34;&gt;;

// Provide a definition of the types that are used within the Toy dialect.
def Toy_Type : AnyTypeOf&lt;[F64Tensor, Toy_StructType]&gt;;</code>
				</pre>
			</div>
			<p data-pid="EizFcwX4">然后我们可以更新我们的操作，例如
				<code>ReturnOp</code>
				，以也接受
				<code>Toy_StructType</code>
				：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">def ReturnOp : Toy_Op&lt;&#34;return&#34;, [Terminator, HasParent&lt;&#34;FuncOp&#34;&gt;]&gt; {
  ...
  let arguments = (ins Variadic&lt;Toy_Type&gt;:$input);
  ...
}</code>
				</pre>
			</div>
			<h3>添加新的
				<code>TOY</code>
				操作
			</h3>
			<p data-pid="7wNb301p">除了现有的操作之外，我们还将添加一些新的操作，这些操作将提供对
				<code>structs</code>
				的更具体的处理。
			</p>
			<h3>
				<code>toy.struct_constant</code>
			</h3>
			<p data-pid="6tNX40NR">这个新操作实现了结构的常量值。在我们当前的建模中，我们只使用了一个
				<a href="../LangRef.md#array-attribute" class="internal">数组属性</a>
				，它为每个
				<code>struct</code>
				元素包含一组常量值。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">%0 = toy.struct_constant [
    dense&lt;[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]&gt; : tensor&lt;2x3xf64&gt;
  ] : !toy.struct&lt;tensor&lt;*xf64&gt;&gt;</code>
				</pre>
			</div>
			<h3>
				<code>toy.struct_access</code>
			</h3>
			<p data-pid="0BiL3s5T">这个新操作实现了
				<code>struct</code>
				值的第N个元素。
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">// Using %0 from above
  %1 = toy.struct_access %0[0] : !toy.struct&lt;tensor&lt;*xf64&gt;&gt; -&gt; tensor&lt;*xf64&gt;</code>
				</pre>
			</div>
			<p data-pid="oljtLVkK">通过这些操作，我们可以重新查看最初的示例：</p>
			<div class="highlight">
				<pre>
<code class="language-text">struct Struct {
  var a;
  var b;
}

# User defined generic function may operate on struct types as well.
def multiply_transpose(Struct value) {
  # We can access the elements of a struct via the &#39;.&#39; operator.
  return transpose(value.a) * transpose(value.b);
}

def main() {
  # We initialize struct values using a composite initializer.
  Struct value = {[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]};

  # We pass these arguments to functions like we do with variables.
  var c = multiply_transpose(value);
  print(c);
}</code>
				</pre>
			</div>
			<p data-pid="wFn-b3uG">并最终获得完整的MLIR模块：</p>
			<div class="highlight">
				<pre>
<code class="language-text">module {
  func @multiply_transpose(%arg0: !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt;) -&gt; tensor&lt;*xf64&gt; {
    %0 = toy.struct_access %arg0[0] : !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt; -&gt; tensor&lt;*xf64&gt;
    %1 = toy.transpose(%0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
    %2 = toy.struct_access %arg0[1] : !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt; -&gt; tensor&lt;*xf64&gt;
    %3 = toy.transpose(%2 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
    %4 = toy.mul %1, %3 : tensor&lt;*xf64&gt;
    toy.return %4 : tensor&lt;*xf64&gt;
  }
  func @main() {
    %0 = toy.struct_constant [
      dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;,
      dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;
    ] : !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt;
    %1 = toy.generic_call @multiply_transpose(%0) : (!toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt;) -&gt; tensor&lt;*xf64&gt;
    toy.print %1 : tensor&lt;*xf64&gt;
    toy.return
  }
}</code>
				</pre>
			</div>
			<h3>优化
				<code>StructType</code>
				的操作
			</h3>
			<p data-pid="73te6Ax3">现在我们有几个操作在&ldquo;StructType&rdquo;上，我们也有许多新的常量折叠机会。</p>
			<p data-pid="ty5GdGE6">内联后，上一节中的MLIR模块如下所示：</p>
			<div class="highlight">
				<pre>
<code class="language-text">module {
  func @main() {
    %0 = toy.struct_constant [
      dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;,
      dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;
    ] : !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt;
    %1 = toy.struct_access %0[0] : !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt; -&gt; tensor&lt;*xf64&gt;
    %2 = toy.transpose(%1 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
    %3 = toy.struct_access %0[1] : !toy.struct&lt;tensor&lt;*xf64&gt;, tensor&lt;*xf64&gt;&gt; -&gt; tensor&lt;*xf64&gt;
    %4 = toy.transpose(%3 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
    %5 = toy.mul %2, %4 : tensor&lt;*xf64&gt;
    toy.print %5 : tensor&lt;*xf64&gt;
    toy.return
  }
}</code>
				</pre>
			</div>
			<p data-pid="pmCVB_J-">我们有几个访问
				<code>toy.struct_constant</code>
				的
				<code>toy.struct_access</code>
				操作。如
				<a href="zh-Ch-3.md" class="internal">第3章</a>
				(FoldConstantReshape)所述，我们可以通过在操作定义上设置
				<code>hasFolder</code>
				位并提供
				<code>*Op::fold</code>
				方法的定义来为这些
				<code>toy</code>
				操作添加folder操作。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="c1">/// Fold constants.
</span><span class="c1"></span><span class="n">OpFoldResult</span> <span class="n">ConstantOp</span><span class="o">::</span><span class="n">fold</span><span class="p">(</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span> <span class="n">operands</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">value</span><span class="p">();</span> <span class="p">}</span>

<span class="c1">/// Fold struct constants.
</span><span class="c1"></span><span class="n">OpFoldResult</span> <span class="n">StructConstantOp</span><span class="o">::</span><span class="n">fold</span><span class="p">(</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span> <span class="n">operands</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nf">value</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// Fold simple struct access operations that access into a constant.
</span><span class="c1"></span><span class="n">OpFoldResult</span> <span class="n">StructAccessOp</span><span class="o">::</span><span class="n">fold</span><span class="p">(</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span> <span class="n">operands</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">structAttr</span> <span class="o">=</span> <span class="n">operands</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">dyn_cast_or_null</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ArrayAttr</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">structAttr</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="n">size_t</span> <span class="n">elementIndex</span> <span class="o">=</span> <span class="n">index</span><span class="p">().</span><span class="n">getZExtValue</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">structAttr</span><span class="p">[</span><span class="n">elementIndex</span><span class="p">];</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="RpSIQYOS">为了确保MLIR在折叠我们的
				<code>Toy</code>
				操作时生成正确的常量操作，即
				<code>TensorType</code>
				的
				<code>ConstantOp</code>
				和
				<code>StructType</code>
				的
				<code>StructConstant</code>
				，我们需要提供方言钩子
				<code>MaterializeConstant</code>
				的覆盖。这允许通用MLIR操作在必要时为
				<code>TOY</code>
				方言创建常量。
			</p>
			<div class="highlight">
				<pre>
<code class="language-cpp"><span class="n">mlir</span><span class="o">::</span><span class="n">Operation</span> <span class="o">*</span><span class="n">ToyDialect</span><span class="o">::</span><span class="n">materializeConstant</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span> <span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span>
                                                 <span class="n">mlir</span><span class="o">::</span><span class="n">Attribute</span> <span class="n">value</span><span class="p">,</span>
                                                 <span class="n">mlir</span><span class="o">::</span><span class="n">Type</span> <span class="n">type</span><span class="p">,</span>
                                                 <span class="n">mlir</span><span class="o">::</span><span class="n">Location</span> <span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">StructType</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">StructConstantOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
                                            <span class="n">value</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">ArrayAttr</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="n">create</span><span class="o">&lt;</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
                                    <span class="n">value</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">DenseElementsAttr</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</code>
				</pre>
			</div>
			<p data-pid="7VK8ArFM">有了这一点，我们现在可以生成可以生成到LLVM的代码，而不需要对我们的流程进行任何更改。</p>
			<div class="highlight">
				<pre>
<code class="language-text">module {
  func @main() {
    %0 = toy.constant dense&lt;[[1.000000e+00, 2.000000e+00, 3.000000e+00], [4.000000e+00, 5.000000e+00, 6.000000e+00]]&gt; : tensor&lt;2x3xf64&gt;
    %1 = toy.transpose(%0 : tensor&lt;2x3xf64&gt;) to tensor&lt;3x2xf64&gt;
    %2 = toy.mul %1, %1 : tensor&lt;3x2xf64&gt;
    toy.print %2 : tensor&lt;3x2xf64&gt;
    toy.return
  }
}</code>
				</pre>
			</div>
			<p data-pid="OiLnJeEP">您可以构建
				<code>toyc&ndash;ch7</code>
				并亲自试用：
				<code>toyc&ndash;ch7&nbsp;test/examples/Toy/ch7/struct&ndash;codegen.toy&nbsp;&ndash;emit=mlir</code>
				。有关定义自定义类型的更多详细信息，请参阅
				<a href="DefiningAttributesAndTypes.md" class="internal">DefiningAttributesAndTypes</a>
				.
			</p>
		</div>
	<!-- AutoExtract End-->
		</div>

	<li><font color="#000080" size="2">Update Time: Wed Oct 18 21:42:25 CST 2023</font></li>
	<li><font color="#000080" size="2">&reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com</font></li>
	<hr/>
</body></html>

<html>
	<head>
		<meta charSet="utf-8"></meta>
		<title data-rh="true">linux&nbsp;栈回溯&nbsp;x86_64&nbsp;知乎</title>
	</head>
	<body class="WhiteBg-body PostIndex-body">
		<body>Original&nbsp;Link:&nbsp;
			<b>
				<font color="#000080" size="3">UPDATE by &reg; UNI TOOL - &copy; 2017-2022 TODD - to0d@outlook.com, at Sat Nov 04 17:50:08 CST 2023</font>
			</b>
			<br>

			<a href="https://zhuanlan.zhihu.com/p/302726082" target="_blank">
				<font color="red" size="3">linux&nbsp;栈回溯(x86_64&nbsp;)&nbsp;&ndash;&nbsp;知乎</font>
			</a>
			<p></p>
		</body>
		<div class="RichText ztext Post-RichText css-117anjg" options="[object Object]">
			<h2 data-first-child>前序</h2>
			<p data-pid="Tgn0mKCb">前面几个章节我们了解了《
				<a href="286088470" class="internal">ELF文件格</a>
				式》、《
				<a href="287863861" class="internal">ELF文件加载过程</a>
				》、《
				<a href="288636064" class="internal">x86通用寄存器</a>
				》、《
				<a href="290689333" class="internal">x86栈帧原理</a>
				》和《
				<a href="296750228" class="internal">linux&nbsp;进程内核栈</a>
				》，对x86平台上程序运行和调试机制有了一定认识。接下来我们从程序调试的角度，来一同学习下x86栈回溯的原理和使用。
			</p>
			<h2>栈回溯发展</h2>
			<p data-pid="bQkErsIt">我们在在调试的时候，经常需要获取CFI（Call&nbsp;Frame&nbsp;Information），进行堆栈回溯。在《
				<a href="290689333" class="internal">x86栈帧原理</a>
				》一文中，我们知道x86上栈帧有多种结构，栈回溯根据栈帧结构不同，而采取不同的回溯方式。下面一起来看下栈帧的发展和对应的栈回溯方式。
			</p>
			<p data-pid="QUP9P-xp">【1】
				<b>frame&nbsp;pointer</b>
			</p>
			<p data-pid="GeiXpO8Q">frame&nbsp;pointer是经典栈帧结构。在《
				<a href="290689333" class="internal">X86栈帧原理</a>
				》一文中，介绍过x86经典的栈帧结构：即使用ebp寄存器保存栈帧地址，esp保存栈顶指针，在过程调用时将上一个栈帧地址入栈保存：
			</p>
			<figure data-size="normal">
				<div>
					<img src="files/f4e62dec9bbfefcc61a952ae5f73e9aa.jpg"></img>
				</div>
				<img></img>
				<figcaption>图一</figcaption>
			</figure>
			<p data-pid="UwGueHME">这种方式，在栈回溯时，调试器可以轻松获取旧的堆栈指针并继续展开其他栈帧。这种方式的优缺点如下：</p>
			<p data-pid="PoTV8t0V">优点：使用起来方便快捷，回溯栈比较简单；</p>
			<p data-pid="1bMC5MPj">缺点：</p>
			<blockquote data-pid="qDhJCKDX">1）需要固定占用一个通用寄存器
				<br>2）保存回溯信息有指令开销（保存ebp寄存器）

				<br>3）最主要的是没有足够的信息被编码，只能恢复堆栈寄存器

			</blockquote>
			<p data-pid="762g3f_u">前面章节提到，这种栈帧结构，在x86_64中被抛弃。gcc&nbsp;在64位编译器中默认不使用rbp保存栈帧地址，即不再保存上一个栈帧地址，因此在x86_64中也就无法使用这种栈回溯方式（不过可以使用&ndash;fno&ndash;omit&ndash;frame&ndash;pointer选项保存栈帧rbp）。</p>
			<p data-pid="l5mU6aHf">【2】
				<b>DWARF</b>
			</p>
			<p data-pid="ndHYUeC1">调试信息标准
				<b>DWARF</b>
				(Debugging&nbsp;With&nbsp;Attributed&nbsp;Record&nbsp;Formats)定义了一个
				<b>.debug_frame</b>
				section。该调试信息格式支持处理无基址指针的方法，可以将ebp用作常规寄存器，但是当保存esp时，它必须在.debug_frame节中产生一个注释，告诉调试器什么指令将其保存在何处。
			</p>
			<p data-pid="MQL3VZm2">它可以告诉调试器如何还原更多信息，而不仅仅是ebp。而且没有指令开销。不过方案仍然不足以进行异常处理，因为它不支持指定原始语言，在手写汇编代码时用起来很挣扎。</p>
			<p data-pid="iL_pds0n">【3】
				<b>EH_FRAME</b>
				段
			</p>
			<p data-pid="IS5pW3CG">现代Linux操作系统在LSB&nbsp;(Linux&nbsp;Standard&nbsp;Base)标准中定义了一个.eh_frame&nbsp;section来解决上述的难题。这个section和.debug_frame非常类似，但是它编码紧凑，可以随程序一起加载。</p>
			<p data-pid="7xJ_y5pj">我们在《
				<a href="286088470" class="internal">ELF文件格式</a>
				》一文中简要介绍了.eh_frame&nbsp;section。这个.eh_frame段中存储着跟函数入栈相关的关键数据。当函数执行入栈指令后，在该段会保存跟入栈指令一一对应的编码数据，根据这些编码数据，就能计算出当前函数栈大小和cpu的哪些寄存器入栈了，在栈中什么位置。
			</p>
			<p data-pid="Pol72r4Q">无论是否有&ndash;g选项，gcc默认都会生成.eh_frame和.eh_frame_hdr&nbsp;section。&ndash;fno&ndash;asynchronous&ndash;unwind&ndash;tables选项可以禁止生成.eh_frame和.eh_frame_hdr&nbsp;section。</p>
			<p data-pid="kMG-6GqM">【4】
				<b>CFI&nbsp;directives</b>
			</p>
			<p data-pid="SaSMg8jL">无论是.debug_frame还是.eh_frame，都有一个问题：生成它们的最直接方法是在asm汇编文件中写一个固定格式的长表。由于编译器不知道代码的确切大小，因此这会导致编码效率低下，表格也很难阅读。CFI伪指令是改进.debug_frame和.eh_frame&nbsp;生成的一种方法。</p>
			<p data-pid="r2Nqyvcp">CFI&nbsp;directives伪指令是一组生成CFI调试信息的高级语言，它的形式截取如下：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="p">.</span><span class="n">cfi_startproc</span>
<span class="n">pushl</span> <span class="o">%</span><span class="n">ebp</span>
<span class="p">.</span><span class="n">cfi_def_cfa_offset</span> <span class="mi">8</span>
<span class="p">.</span><span class="n">cfi_offset</span> <span class="n">ebp</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span></code>
				</pre>
			</div>
			<p data-pid="WuLFm62y">关于汇编器利用这些伪指令来生成.debug_frame还是.debug_frame，在.cfi_sections指令中定义。如果只是调试需求可以生成.debug_frame，如果需要在运行时调用需要生成.eh_frame。</p>
			<p data-pid="-EVW0hua">在认识了CFI存储发展历史后，下面会进行详解分析。linux&nbsp;userspace&nbsp;上运行的ELF可执行文件，使用的就是ef_frame这种调试信息格式，我们下面就详细分析ef_frame&nbsp;原理和unwind方式。</p>
			<h2>详解CFI&nbsp;伪指令</h2>
			<p data-pid="jK99oaY1">gcc&nbsp;使用CFI&nbsp;伪指令来生成eh_frame信息，在使用c语言编写时，gcc会自动帮我们产生CFI伪指令。我们在深入了解eh_frame格式之前，先看下CFI&nbsp;伪指令。</p>
			<p data-pid="-YOoiK9f">在GAS(GCC&nbsp;Assembler)汇编编译器
				<a href="https://link.zhihu.com/?target=https%3A//sourceware.org/binutils/docs-2.31/as/CFI-directives.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">CFI(Call&nbsp;Frame&nbsp;Information)</a>
				/
				<a href="https://link.zhihu.com/?target=https%3A//sourceware.org/binutils/docs/as/ARM-Directives.html%23arm_005ffnstart" class=" wrap external" target="_blank" rel="nofollow noreferrer">ARM&nbsp;CFI</a>
				文档中，对所有CFI伪指令的含义有详细描述。这里挑选几个重要的伪指令分析。
			</p>
			<p data-pid="gjwvnD9I">（1）.
				<b>cfi_startproc</b>
			</p>
			<blockquote data-pid="Y2PIOKcF">用在每个函数的入口处。</blockquote>
			<p data-pid="sfwQtUuF">（2）.
				<b>cfi_endproc</b>
			</p>
			<blockquote data-pid="0py9izG8">.cfi_endproc用在函数的结束处，和.cfi_startproc对应。</blockquote>
			<p data-pid="k8KDUoLY">（3）.
				<b>cfi_def_cfa_offset</b>
				[offset]
			</p>
			<blockquote data-pid="xISg-Tpf">用来修改修改CFA计算规则，基址寄存器不变，offset变化：
				<br>CFA&nbsp;=&nbsp;register&nbsp;+&nbsp;offset(new)

			</blockquote>
			<p data-pid="wfqyB1lZ">（4）.
				<b>cfi_def_cfa_register</b>
				register
			</p>
			<blockquote data-pid="JWhPqbRb">用来修改修改CFA计算规则，基址寄存器从rsp转移到新的register。
				<br>register&nbsp;=&nbsp;new&nbsp;register

			</blockquote>
			<p data-pid="iF4LFJ3K">（5）.
				<b>cfi_offset</b>
				register,&nbsp;offset
			</p>
			<blockquote data-pid="wVeN_jHi">寄存器register上一次值保存在CFA偏移offset的堆栈中：
				<br>*(CFA&nbsp;+&nbsp;offset)&nbsp;=&nbsp;register(pre_value)

			</blockquote>
			<p data-pid="yt4Q1O4A">（6）.
				<b>cfi_def_cfa</b>
				register,&nbsp;offset
			</p>
			<blockquote data-pid="sWWgwQ-O">用来定义CFA的计算规则：
				<br>CFA&nbsp;=&nbsp;register&nbsp;+&nbsp;offset

				<br>默认基址寄存器register&nbsp;=&nbsp;rsp。

				<br>x86_64的register编号从0&ndash;15对应下表。rbp的register编号为6，rsp的register编号为7。

				<br>%rax，%rbx，%rcx，%rdx，%esi，%edi，

				<b>%rbp，%rsp</b>
				，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15，参考
				<a href="https://link.zhihu.com/?target=https%3A//refspecs.linuxfoundation.org/elf/x86_64-abi-0.95.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">x86_64&nbsp;ABI</a>
			</blockquote>
			<p data-pid="TNcqOAQS">在使用c语言编写时，gcc会自动帮我们产生CFI伪指令。我们通过一个例子来看下x86_64上汇编里的CFI伪指令：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span> 
<span class="kt">int</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span><span class="mi">10</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello test~, %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span> 
        <span class="n">a</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code>
				</pre>
			</div>
			<p data-pid="eqrfzz3j">test.c&nbsp;程序汇编代码（test函数部分）：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="c1">//gcc -S test.c -o test.s
</span><span class="c1"></span>      <span class="mi">5</span> <span class="nl">test</span><span class="p">:</span>
      <span class="mi">6</span> <span class="p">.</span><span class="nl">LFB0</span><span class="p">:</span>
      <span class="mi">7</span>         <span class="p">.</span><span class="n">cfi_startproc</span>
      <span class="mi">8</span>         <span class="n">pushq</span>   <span class="o">%</span><span class="n">rbp</span>
      <span class="mi">9</span>         <span class="p">.</span><span class="n">cfi_def_cfa_offset</span> <span class="mi">16</span>
     <span class="mi">10</span>         <span class="p">.</span><span class="n">cfi_offset</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">16</span>
     <span class="mi">11</span>         <span class="n">movq</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span> <span class="o">%</span><span class="n">rbp</span>
     <span class="mi">12</span>         <span class="p">.</span><span class="n">cfi_def_cfa_register</span> <span class="mi">6</span>
     <span class="mi">13</span>         <span class="n">movl</span>    <span class="o">%</span><span class="n">edi</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
     <span class="mi">14</span>         <span class="n">movl</span>    <span class="err">$</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
     <span class="mi">15</span>         <span class="n">movl</span>    <span class="o">-</span><span class="mi">20</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
     <span class="mi">16</span>         <span class="n">imull</span>   <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span>
     <span class="mi">17</span>         <span class="n">popq</span>    <span class="o">%</span><span class="n">rbp</span>
     <span class="mi">18</span>         <span class="p">.</span><span class="n">cfi_def_cfa</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span>
     <span class="mi">19</span>         <span class="n">ret</span>
     <span class="mi">20</span>         <span class="p">.</span><span class="n">cfi_endproc</span>
     <span class="mi">21</span> <span class="p">.</span><span class="nl">LFE0</span><span class="p">:</span>
     <span class="mi">22</span>         <span class="p">.</span><span class="n">size</span>   <span class="n">test</span><span class="p">,</span> <span class="p">.</span><span class="o">-</span><span class="n">test</span>
     <span class="mi">23</span>         <span class="p">.</span><span class="n">globl</span>  <span class="n">main</span>
     <span class="mi">24</span>         <span class="p">.</span><span class="n">type</span>   <span class="n">main</span><span class="p">,</span> <span class="err">@</span><span class="n">function</span></code>
				</pre>
			</div>
			<p data-pid="RALIuXjx">FDT中包含PC范围，可以根据函数符号地址，找到函数对应的FDT。</p>
			<p data-pid="X6mJuS4z">readelf&nbsp;&ndash;s&nbsp;找到test和main&nbsp;符号地址：</p>
			<div class="highlight">
				<pre>
<code class="language-c">    <span class="mi">95</span><span class="o">:</span> <span class="mo">000000000040054</span><span class="n">d</span>    <span class="mi">43</span> <span class="n">FUNC</span>    <span class="n">GLOBAL</span> <span class="n">DEFAULT</span>   <span class="mi">11</span> <span class="n">main</span>
    <span class="mi">96</span><span class="o">:</span> <span class="mo">0000000000601020</span>     <span class="mi">0</span> <span class="n">OBJECT</span>  <span class="n">GLOBAL</span> <span class="n">HIDDEN</span>    <span class="mi">21</span> <span class="n">__TMC_END__</span>
    <span class="mi">97</span><span class="o">:</span> <span class="mo">0000000000000000</span>     <span class="mi">0</span> <span class="n">NOTYPE</span>  <span class="n">WEAK</span>   <span class="n">DEFAULT</span>  <span class="n">UND</span> <span class="n">_ITM_registerTMCloneTable</span>
    <span class="mi">98</span><span class="o">:</span> <span class="mo">000000000040042</span><span class="mi">8</span>     <span class="mi">0</span> <span class="n">FUNC</span>    <span class="n">GLOBAL</span> <span class="n">HIDDEN</span>    <span class="mi">10</span> <span class="n">_init</span>
    <span class="mi">99</span><span class="o">:</span> <span class="mo">0000000000400536</span>    <span class="mi">23</span> <span class="n">FUNC</span>    <span class="n">GLOBAL</span> <span class="n">DEFAULT</span>   <span class="mi">11</span> <span class="n">test</span></code>
				</pre>
			</div>
			<p data-pid="5M7KoyGq">readelf&nbsp;&ndash;wF&nbsp;，根据test函数入口地址，找到对应的FDE如下：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="mo">00000040</span> <span class="mo">000000000000001</span><span class="n">c</span> <span class="mo">00000044</span> <span class="n">FDE</span> <span class="n">cie</span><span class="o">=</span><span class="mo">00000000</span> <span class="n">pc</span><span class="o">=</span><span class="mf">0000000000400536..000000000040054</span><span class="n">d</span>
   <span class="n">LOC</span>           <span class="n">CFA</span>      <span class="n">rbp</span>   <span class="n">ra</span>    
<span class="mo">0000000000400536</span> <span class="n">rsp</span><span class="o">+</span><span class="mi">8</span>    <span class="n">u</span>     <span class="n">c</span><span class="o">-</span><span class="mi">8</span>   
<span class="mo">0000000000400537</span> <span class="n">rsp</span><span class="o">+</span><span class="mi">16</span>   <span class="n">c</span><span class="o">-</span><span class="mi">16</span>  <span class="n">c</span><span class="o">-</span><span class="mi">8</span>   
<span class="mo">000000000040053</span><span class="n">a</span> <span class="n">rbp</span><span class="o">+</span><span class="mi">16</span>   <span class="n">c</span><span class="o">-</span><span class="mi">16</span>  <span class="n">c</span><span class="o">-</span><span class="mi">8</span>   
<span class="mo">000000000040054</span><span class="n">c</span> <span class="n">rsp</span><span class="o">+</span><span class="mi">8</span>    <span class="n">c</span><span class="o">-</span><span class="mi">16</span>  <span class="n">c</span><span class="o">-</span><span class="mi">8</span> </code>
				</pre>
			</div>
			<p data-pid="MoiOR35u">FDE和汇编语句对照关系：</p>
			<figure data-size="normal">
				<div>
					<img src="files/ba997c5d67c7059aef6ce8cbee11d8b1.jpg"></img>
				</div>
				<img></img>
			</figure>
			<blockquote data-pid="qG7lRoSK">1、将&nbsp;return&nbsp;addr压栈，此时对应FDE中的&ldquo;CFA&nbsp;=&nbsp;rsp+8&rdquo;;
				<br>2、将rbp压栈，基址寄存器不变情况下修改CFA计算规则，&ldquo;CFA&nbsp;=&nbsp;rsp+16&rdquo;;

				<br>3、寄存器6（rbp）上一次的值，相对CFA的位置。即rbp(old)&nbsp;=&nbsp;CFA&ndash;16；

				<br>4、把rsp的值赋给rbp，后续的堆栈计算，使用rbp作为基址寄存器。3和4组合起来，&ldquo;CFA=rbp+16&rdquo;；

				<br>5、定义CFA的计算规则，将rsp恢复成rbp的值，此时&ldquo;CFA&nbsp;=&nbsp;寄存器7(rsp)+8&rdquo;；

				<br>6、返回上一层函数（main），弹出return&nbsp;addr。

			</blockquote>
			<p class="ztext-empty-paragraph">
				<br>

			</p>
			<h2>详解eh_frame</h2>
			<p data-pid="KgtiFJR7">上面简要介绍了几种调用栈信息保存方式，以及CFI伪指令的使用。本文接下来重点围绕linux&nbsp;中x86_64中，eh_frame&nbsp;格式
				<b>unwind栈回溯</b>
				原理。
			</p>
			<p data-pid="sDY2FDqz">【1】格式</p>
			<p data-pid="t-DTZdMM">每个.eh_frame&nbsp;section&nbsp;包含一个或多个
				<b>CFI</b>
				(Call&nbsp;Frame&nbsp;Information)记录，记录的条目数量由.eh_frame&nbsp;段大小决定。每条CFI记录包含一个
				<b>CIE</b>
				(Common&nbsp;Information&nbsp;Entry&nbsp;Record)记录，每个CIE包含一个或者多个
				<b>FDE</b>
				(Frame&nbsp;Description&nbsp;Entry)记录。
			</p>
			<p data-pid="EINC4H8g">通常情况下，
				<b>CIE对应一个文件，FDE对应一个函数</b>
				。
			</p>
			<p data-pid="aJiFSDln">CFI、FDE格式和字段含义，请参考
				<a href="https://link.zhihu.com/?target=https%3A//refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">LSB官方手册</a>
				，这里不再罗列。接下来通过一个实际的例子来分析下CFI、FDE数据。
			</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span> 
<span class="kt">int</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span><span class="mi">10</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;hello test~, %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span> 
        <span class="n">a</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code>
				</pre>
			</div>
			<p data-pid="dCZmBH9n">gcc&nbsp;test.c&nbsp;编译，使用readelf
				<b>&ndash;wF</b>
				a.out&nbsp;查看elf文件中的.eh_frame解析信息（节选）：
			</p>
			<div class="highlight">
				<pre>
<code class="language-text">Contents of the .eh_frame section:
 
00000000 0000000000000014 00000000 CIE &#34;zR&#34; cf=1 df=-8 ra=16
   LOC           CFA      ra   
0000000000000000 rsp+8    u    
...
000000c8 0000000000000044 0000009c FDE cie=00000030 pc=00000000000006b0..0000000000000715
   LOC           CFA      rbx   rbp   r12   r13   r14   r15   ra   
00000000000006b0 rsp+8    u     u     u     u     u     u     c-8  
00000000000006b2 rsp+16   u     u     u     u     u     c-16  c-8  
00000000000006b4 rsp+24   u     u     u     u     c-24  c-16  c-8  
00000000000006b9 rsp+32   u     u     u     c-32  c-24  c-16  c-8  
00000000000006bb rsp+40   u     u     c-40  c-32  c-24  c-16  c-8  
00000000000006c3 rsp+48   u     c-48  c-40  c-32  c-24  c-16  c-8  
00000000000006cb rsp+56   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
00000000000006d8 rsp+64   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
000000000000070a rsp+56   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
000000000000070b rsp+48   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
000000000000070c rsp+40   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
000000000000070e rsp+32   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
0000000000000710 rsp+24   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
0000000000000712 rsp+16   c-56  c-48  c-40  c-32  c-24  c-16  c-8  
0000000000000714 rsp+8    c-56  c-48  c-40  c-32  c-24  c-16  c-8</code>
				</pre>
			</div>
			<p data-pid="HlxY46iT">可以看到.eh_frame总体架构就是由CIE和FDE组成的。其中最核心的就是FDE的组织，读懂它条目的所有字段基本就理解了unwind的含义：</p>
			<figure data-size="normal">
				<div>
					<img src="files/802020e631512446a9934cf0eeefb1c1.jpg"></img>
				</div>
				<img></img>
			</figure>
			<p data-pid="bG-crtwo">CFA&nbsp;(Canonical&nbsp;Frame&nbsp;Address,&nbsp;which&nbsp;is&nbsp;the&nbsp;address&nbsp;of&nbsp;%rsp&nbsp;in&nbsp;the&nbsp;caller&nbsp;frame)，CFA就是上一级调用者的堆栈指针。</p>
			<p data-pid="lQP5OSI0">上图详细说明了怎么样利用.eh_frame来进行栈回溯：</p>
			<blockquote data-pid="IMJUO6SF">1、根据当前的PC在.eh_frame中找到对应的条目，根据条目提供的各种偏移计算其他信息。
				<br>2、首先根据CFA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;rsp+4，把当前rsp+4得到CFA的值。再根据CFA的值计算出通用寄存器和返回地址在堆栈中的位置。

				<br>3、通用寄存器栈位置计算。例如：rbx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;CFA&ndash;56。

				<br>4、返回地址ra的栈位置计算。ra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;CFA&ndash;8。

				<br>5、根据ra的值，重复步骤1到4，就形成了完整的栈回溯。

			</blockquote>
			<p data-pid="iJjKZKye">还可以使用readelf&nbsp;&ndash;wf&nbsp;xxx命令来查看elf文件中的.eh_frame原始信息，这里不再列出。</p>
			<p class="ztext-empty-paragraph">
				<br>

			</p>
			<h2>用户态栈回溯</h2>
			<p data-pid="ptJ9siUh">在实际编程过程中，我们起始并不需要自己去处理unwind信息来进行栈回溯，在linux上有很多已经封装好的栈回溯API，我们在使用调试工具（如gdb）时，工具本身就集成了栈回溯代码。下面一起来看下有哪些已经实现好的API供调用。</p>
			<p data-pid="cZjr4Rhh">【1】
				<b>gcc提供的取栈&nbsp;API</b>
			</p>
			<p data-pid="GcNNV7fm">gcc提供了__builtin_return_address()&nbsp;宏来获取函数的返回地址（栈中的return&nbsp;addr）。level为参数，如果level为0，那么就是请求当前函数的返回地址；如果level为1，那么就是请求进行调用的函数的返回地址。然后我们通过objdump&nbsp;出来的文件去查找打印出来的函数地址，就可以知道函数调用栈了。</p>
			<p data-pid="vRn2091Z">下面还是通过一个例子来看下效果：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%p,%p</span><span class="se">\n</span><span class="s">&#34;</span> <span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">g</span><span class="p">();</span>
<span class="p">}</span></code>
				</pre>
			</div>
			<p data-pid="qOzrYVDT">执行：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span><span class="p">]</span><span class="err">#</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span> 
<span class="mh">0x4005cc</span><span class="p">,</span> <span class="mh">0x4005dd</span></code>
				</pre>
			</div>
			<p data-pid="eWobCrea">反汇编查看两个地址位置：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="mo">00000000004005</span><span class="mi">96</span> <span class="o">&lt;</span><span class="n">f</span><span class="o">&gt;:</span>
  <span class="mi">400596</span><span class="o">:</span>	<span class="mi">55</span>                   	<span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
	<span class="err">…</span> <span class="err">…</span>
  <span class="mi">4005</span><span class="nl">b6</span><span class="p">:</span>	<span class="n">e8</span> <span class="n">e5</span> <span class="n">fe</span> <span class="n">ff</span> <span class="n">ff</span>       	<span class="n">callq</span>  <span class="mi">4004</span><span class="n">a0</span> <span class="o">&lt;</span><span class="n">printf</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
  <span class="mi">4005</span><span class="nl">bb</span><span class="p">:</span>	<span class="mi">90</span>                   	<span class="n">nop</span>
  <span class="mi">4005</span><span class="nl">bc</span><span class="p">:</span>	<span class="mi">5</span><span class="n">d</span>                   	<span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
  <span class="mi">4005</span><span class="nl">bd</span><span class="p">:</span>	<span class="n">c3</span>                   	<span class="n">retq</span>   

<span class="mo">00000000004005</span><span class="n">be</span> <span class="o">&lt;</span><span class="n">g</span><span class="o">&gt;:</span>
  <span class="mi">4005</span><span class="nl">be</span><span class="p">:</span>	<span class="mi">55</span>                   	<span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
  <span class="mi">4005</span><span class="nl">bf</span><span class="p">:</span>	<span class="mi">48</span> <span class="mi">89</span> <span class="n">e5</span>             	<span class="n">mov</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
  <span class="mi">4005</span><span class="nl">c2</span><span class="p">:</span>	<span class="n">b8</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>       	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
  <span class="mi">4005</span><span class="nl">c7</span><span class="p">:</span>	<span class="n">e8</span> <span class="n">ca</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>       	<span class="n">callq</span>  <span class="mi">400596</span> <span class="o">&lt;</span><span class="n">f</span><span class="o">&gt;</span>
  <span class="mi">4005</span><span class="nl">cc</span><span class="p">:</span>	<span class="mi">90</span>                   	<span class="n">nop</span>
  <span class="mi">4005</span><span class="nl">cd</span><span class="p">:</span>	<span class="mi">5</span><span class="n">d</span>                   	<span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
  <span class="mi">4005</span><span class="nl">ce</span><span class="p">:</span>	<span class="n">c3</span>                   	<span class="n">retq</span>   

<span class="mo">00000000004005</span><span class="n">cf</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;:</span>
  <span class="mi">4005</span><span class="nl">cf</span><span class="p">:</span>	<span class="mi">55</span>                   	<span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
  <span class="mi">4005</span><span class="nl">d0</span><span class="p">:</span>	<span class="mi">48</span> <span class="mi">89</span> <span class="n">e5</span>             	<span class="n">mov</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
  <span class="mi">4005</span><span class="nl">d3</span><span class="p">:</span>	<span class="n">b8</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>       	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
  <span class="mi">4005</span><span class="nl">d8</span><span class="p">:</span>	<span class="n">e8</span> <span class="n">e1</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>       	<span class="n">callq</span>  <span class="mi">4005</span><span class="n">be</span> <span class="o">&lt;</span><span class="n">g</span><span class="o">&gt;</span>
  <span class="mi">4005</span><span class="nl">dd</span><span class="p">:</span>	<span class="n">b8</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>       	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
  <span class="mf">4005e2</span><span class="o">:</span>	<span class="mi">5</span><span class="n">d</span>                   	<span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
<span class="err">…</span> <span class="err">…</span></code>
				</pre>
			</div>
			<blockquote data-pid="YKubqA0K">（1）打印的地址0：0x4005cc
				<br>由于地址是函数返回地址，因此查看其上一句汇编语句是函数g&nbsp;里的&ldquo;callq&nbsp;400596&nbsp;&lt;f&gt;&rdquo;。我们通过《

				<a href="290689333" class="internal">x86栈帧原理</a>
				》知道，call指令其实对应于&ldquo;push&rdquo;和&ldquo;jump&rdquo;两条指令，0x4005cc就是push压栈的返回地址。因此&ldquo;当前函数（printer）&rdquo;上一个函数就是函数g；
				<br>（2）打印的地址0：0x4005dd

				<br>计算同上，找到&ldquo;callq&nbsp;4005be&nbsp;&lt;g&gt;&rdquo;，g的上一个函数就是main函数。

			</blockquote>
			<p class="ztext-empty-paragraph">
				<br>

			</p>
			<p data-pid="naG8sCeh">【2】
				<b>glibc取栈</b>
			</p>
			<p data-pid="wtkypoIU">glibc提供了一对函数
				<b>backtrace</b>
				()和
				<b>backtrace_symbols</b>
				()来回溯栈信息。man手册中函数原型：
			</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="cp">#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
</span><span class="cp"></span>
       <span class="kt">int</span> <span class="nf">backtrace</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

       <span class="kt">char</span> <span class="o">**</span><span class="nf">backtrace_symbols</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>

       <span class="kt">void</span> <span class="nf">backtrace_symbols_fd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>

<span class="o">//</span><span class="n">The</span> <span class="n">array</span> <span class="n">backtrace_symbols</span> <span class="k">return</span> <span class="n">is</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="n">ed</span>  <span class="n">by</span>  <span class="n">backtrace_symbols</span><span class="p">(),</span>  <span class="n">and</span>  <span class="n">must</span>  <span class="n">be</span>  <span class="n">freed</span> <span class="n">by</span> <span class="n">the</span> <span class="n">caller</span><span class="p">.</span></code>
				</pre>
			</div>
			<p data-pid="c4zAcgrv">backtrace_symbols&nbsp;可以将backtrace&nbsp;收到的地址数据翻译成易阅读的&nbsp;符号，因此可以两个组合使用（注意需要主动free掉&nbsp;backtrace_symbols&nbsp;返回的地址！）：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;execinfo.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BACKTRACE_SIZ   64
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">do_backtrace</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span>    <span class="o">*</span><span class="n">array</span><span class="p">[</span><span class="n">BACKTRACE_SIZ</span><span class="p">];</span>
    <span class="n">size_t</span>   <span class="n">size</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span>   <span class="o">**</span><span class="n">strings</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">BACKTRACE_SIZ</span><span class="p">);</span>
    <span class="n">strings</span> <span class="o">=</span> <span class="n">backtrace_symbols</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%p : %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">strings</span><span class="p">);</span>  <span class="c1">// malloced by backtrace_symbols
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">func1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">do_backtrace</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span>  <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">func1</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code>
				</pre>
			</div>
			<p data-pid="WEbnZ7FK">执行：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span><span class="p">]</span><span class="err">#</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span> 
<span class="mh">0x400695</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">()</span> <span class="p">[</span><span class="mh">0x400695</span><span class="p">]</span>
<span class="mh">0x400720</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">()</span> <span class="p">[</span><span class="mh">0x400720</span><span class="p">]</span>
<span class="mh">0x400731</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">()</span> <span class="p">[</span><span class="mh">0x400731</span><span class="p">]</span>
<span class="mh">0x7f94b08666a3</span> <span class="o">:</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span><span class="p">(</span><span class="n">__libc_start_main</span><span class="o">+</span><span class="mh">0xf3</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x7f94b08666a3</span><span class="p">]</span>
<span class="mh">0x4005be</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">()</span> <span class="p">[</span><span class="mh">0x4005be</span><span class="p">]</span></code>
				</pre>
			</div>
			<p data-pid="50KAjQSc">同样采用1&nbsp;中__builtin_return_address()&nbsp;宏&nbsp;的方法，使用objdump&nbsp;&ndash;d反汇编查看汇编地址：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="mo">0000000000400676</span> <span class="o">&lt;</span><span class="n">do_backtrace</span><span class="o">&gt;:</span>
	<span class="err">…</span> <span class="err">…</span>
  <span class="mi">400690</span><span class="o">:</span>	<span class="n">e8</span> <span class="n">db</span> <span class="n">fe</span> <span class="n">ff</span> <span class="n">ff</span>       	<span class="n">callq</span>  <span class="mi">400570</span> <span class="o">&lt;</span><span class="n">backtrace</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
  <span class="mi">400695</span><span class="o">:</span>	<span class="mi">48</span> <span class="mi">98</span>                	<span class="n">cltq</span>   
	<span class="err">…</span> <span class="err">…</span>
<span class="mo">0000000000400712</span> <span class="o">&lt;</span><span class="n">func1</span><span class="o">&gt;:</span>
	<span class="err">…</span> <span class="err">…</span>
  <span class="mi">40071</span><span class="nl">b</span><span class="p">:</span>	<span class="n">e8</span> <span class="mi">56</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>       	<span class="n">callq</span>  <span class="mi">400676</span> <span class="o">&lt;</span><span class="n">do_backtrace</span><span class="o">&gt;</span>
  <span class="mi">400720</span><span class="o">:</span>	<span class="mi">90</span>                   	<span class="n">nop</span>
	<span class="err">…</span> <span class="err">…</span>
<span class="mo">0000000000400723</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;:</span>
	<span class="err">…</span> <span class="err">…</span>
  <span class="mi">40072</span><span class="nl">c</span><span class="p">:</span>	<span class="n">e8</span> <span class="n">e1</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>       	<span class="n">callq</span>  <span class="mi">400712</span> <span class="o">&lt;</span><span class="n">func1</span><span class="o">&gt;</span>
  <span class="mi">400731</span><span class="o">:</span>	<span class="n">b8</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>       	<span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
        <span class="err">…</span> <span class="err">…</span></code>
				</pre>
			</div>
			<p data-pid="EreLJAIM">三个函数返回地址对比，得到函数调用栈。</p>
			<p data-pid="Eko1JNrz">不过可以在编译时使用&ndash;rdynamic把调试信息链接进文件，运行会打印出更详细的符号信息：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="mh">0x400865</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">(</span><span class="n">do_backtrace</span><span class="o">+</span><span class="mh">0x1f</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x400865</span><span class="p">]</span>
<span class="mh">0x4008f0</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">(</span><span class="n">func1</span><span class="o">+</span><span class="mh">0xe</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x4008f0</span><span class="p">]</span>
<span class="mh">0x400901</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">(</span><span class="n">main</span><span class="o">+</span><span class="mh">0xe</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x400901</span><span class="p">]</span>
<span class="mh">0x7f73ee2af6a3</span> <span class="o">:</span> <span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="mf">.6</span><span class="p">(</span><span class="n">__libc_start_main</span><span class="o">+</span><span class="mh">0xf3</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x7f73ee2af6a3</span><span class="p">]</span>
<span class="mh">0x40078e</span> <span class="o">:</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">(</span><span class="n">_start</span><span class="o">+</span><span class="mh">0x2e</span><span class="p">)</span> <span class="p">[</span><span class="mh">0x40078e</span><span class="p">]</span></code>
				</pre>
			</div>
			<p class="ztext-empty-paragraph">
				<br>

			</p>
			<p data-pid="fzsDLDli">（3）
				<b>unwind库</b>
			</p>
			<p data-pid="NChYu3LG">这里的libunwind库指的是非gcc内置的外部库。目前有很多unwind库，有LLVM内置的libunwind&nbsp;、
				<a href="https://link.zhihu.com/?target=http%3A//nongnu.org" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">http://</span>
					<span class="visible">nongnu.org</span>
					<span class="invisible"></span>
				</a>
				的&ldquo;
				<a href="https://link.zhihu.com/?target=https%3A//savannah.nongnu.org/news/%3Fgroup%3Dlibunwind" class=" wrap external" target="_blank" rel="nofollow noreferrer">The&nbsp;libunwind&nbsp;project</a>
				&rdquo;、Android&nbsp;9.0开始使用
				<a href="https://link.zhihu.com/?target=https%3A//android.googlesource.com/platform/system/core/%2B/master/libunwindstack" class=" wrap external" target="_blank" rel="nofollow noreferrer">新的unwind库</a>
				等等。
			</p>
			<p data-pid="lLDbbkYN">本文主要关心x86_64平台主要在用的unwind库。笔者在用的SUSE&nbsp;和&nbsp;centos发行版都是用的
				<a href="https://link.zhihu.com/?target=http%3A//nongnu.org" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">http://</span>
					<span class="visible">nongnu.org</span>
					<span class="invisible"></span>
				</a>
				的&ldquo;
				<a href="https://link.zhihu.com/?target=https%3A//savannah.nongnu.org/news/%3Fgroup%3Dlibunwind" class=" wrap external" target="_blank" rel="nofollow noreferrer">The&nbsp;libunwind&nbsp;project</a>
				&rdquo;版本。因此后面讨论的均以此unwind库为基础。该开源计划网址是：
				<a href="https://link.zhihu.com/?target=http%3A//savannah.nongnu.org/projects/libunwind/" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">http://</span>
					<span class="visible">savannah.nongnu.org/pro</span>
					<span class="invisible">jects/libunwind/</span>
					<span class="ellipsis"></span>
				</a>
				，可选择源码安装或使用如下命令安装：
			</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="c1">// suse11sp4
</span><span class="c1"></span><span class="n">zypper</span> <span class="n">install</span> <span class="n">libunwind</span> <span class="n">libunwind</span><span class="o">-</span><span class="n">devel</span></code>
				</pre>
			</div>
			<p data-pid="HKXkjNfF">本文实验环境是：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="n">suse11sp4</span>
<span class="n">libunwind</span><span class="o">-</span><span class="mf">0.98.6</span><span class="o">-</span><span class="mf">26.6</span>
<span class="n">libunwind</span><span class="o">-</span><span class="n">devel</span><span class="o">-</span><span class="mf">0.98.6</span><span class="o">-</span><span class="mf">26.6</span></code>
				</pre>
			</div>
			<p data-pid="0KoBYq4m">接下来利用libunwind来做栈回溯：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="kt">void</span> <span class="nf">dump_backtrace</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">unw_cursor_t</span> <span class="n">cursor</span><span class="p">;</span>
    <span class="n">unw_context_t</span> <span class="n">uc</span><span class="p">;</span>
    <span class="n">unw_word_t</span> <span class="n">ip</span><span class="p">,</span> <span class="n">sp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="n">unw_word_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">unw_getcontext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>            <span class="c1">// store registers
</span><span class="c1"></span>    <span class="n">unw_init_local</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uc</span><span class="p">);</span>   <span class="c1">// initialze with context
</span><span class="c1"></span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;==========</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">unw_step</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>                         <span class="c1">// unwind to older stack frame
</span><span class="c1"></span>        <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_IP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ip</span><span class="p">);</span>              <span class="c1">// read register, rip
</span><span class="c1"></span>        <span class="n">unw_get_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">UNW_REG_SP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="p">);</span>              <span class="c1">// read register, rbp
</span><span class="c1"></span>        <span class="n">unw_get_proc_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cursor</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4095</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>     <span class="c1">// get name and offset
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;0x%016lx &lt;%s+0x%lx&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>   <span class="c1">// x86_64, unw_word_t == uint64_t
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;==========</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">show_backtrace</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">dump_backtrace</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
        <span class="n">show_backtrace</span><span class="p">();</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code>
				</pre>
			</div>
			<p data-pid="KI7Om-tX">编译：gcc&nbsp;test.c&nbsp;&ndash;o&nbsp;test&nbsp;&ndash;g&nbsp;&ndash;lunwind</p>
			<p data-pid="bA7A5Cgk">运行：</p>
			<div class="highlight">
				<pre>
<code class="language-c"><span class="mh">0x0000000000400936</span> <span class="o">&lt;</span><span class="n">show_backtrace</span><span class="o">+</span><span class="mh">0xe</span><span class="o">&gt;</span>
<span class="mh">0x0000000000400946</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">+</span><span class="mh">0xe</span><span class="o">&gt;</span>
<span class="mh">0x00007f692e189c36</span> <span class="o">&lt;</span><span class="n">__libc_start_main</span><span class="o">+</span><span class="mh">0xe6</span><span class="o">&gt;</span>
<span class="mh">0x0000000000400709</span> <span class="o">&lt;</span><span class="n">_start</span><span class="o">+</span><span class="mh">0x29</span><span class="o">&gt;</span></code>
				</pre>
			</div>
			<p data-pid="GCxHY9yg">其中&nbsp;unw_get_reg&nbsp;函数读取指定的寄存器到变量中。&ldquo;UNW_REG_IP&rdquo;&ldquo;UNW_REG_SP&rdquo;在x86_64中分别表示rip和rsp寄存器。除此之外，还可以通过参数#2&nbsp;指定读取其他寄存器：</p>
			<table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal">
				<tbody>
					<tr>
						<td>UNW_X86_64_RAX&nbsp;&nbsp;&nbsp;rax</td>
					</tr>
					<tr>
						<td>UNW_X86_64_RDX&nbsp;&nbsp;&nbsp;rdx</td>
					</tr>
					<tr>
						<td>UNW_X86_64_RCX&nbsp;&nbsp;&nbsp;rcx</td>
					</tr>
					<tr>
						<td>UNW_X86_64_RBX&nbsp;&nbsp;&nbsp;rbx</td>
					</tr>
					<tr>
						<td>&hellip;&nbsp;&hellip;</td>
					</tr>
				</tbody>
			</table>
			<h2>kernel&nbsp;栈回溯实现</h2>
			<p data-pid="QCVfcDVl">我们在内核开发时，当内核panic后，经常可以看到类似如下的call&nbsp;trace信息：</p>
			<figure data-size="normal">
				<div>
					<img src="files/625a485a1cef21ff42deca495499bf09.jpg"></img>
				</div>
				<img></img>
			</figure>
			<p data-pid="_WsX4dAe">因为在内核中，已经有现成的代码实现了kernel空间的栈回溯。因此我们在自己driver代码里，可以主动调用
				<b>dump_stack</b>
				()函数打印栈回溯信息。下面简要分析下内核空间栈回溯是如何实现的。
			</p>
			<p data-pid="O9i6-udS">不过在x86中，linux内核&nbsp;并非像用户空间那样使用unwind方式进行栈回溯。linux&nbsp;x86体系下栈回溯有一段发展历史：</p>
			<blockquote data-pid="wxXSQWN-">1、在早期时候，内核只支持frame&nbsp;point方式，即&ldquo;CONFIG_FRAME_POINTER=y&rdquo;；
				<br>2、在Linux&nbsp;kernels:&nbsp;2.6.18&nbsp;期间，内核加入了对unwind方式支持，提供&ldquo;CONFIG_STACK_UNWIND&rdquo;，在早期SUSE发行版中有使用（比如作者使用过的

				<b>SUSE11</b>
				）；
				<br>3、不过随后在Linux&nbsp;kernels:&nbsp;2.6.19&nbsp;中就被移除，理由是不稳定引入了过多的问题，感兴趣的可以看

				<a href="https://link.zhihu.com/?target=https%3A//git.congatec.com/android/qmx6_kernel/commit/d1526e2cda64d5a1de56aef50bad9e5df14245c2" class=" wrap external" target="_blank" rel="nofollow noreferrer">linus提交邮件</a>
				；
				<br>4、到了Linux&nbsp;kernels:&nbsp;4.15&nbsp;，内核使用ORC&nbsp;(Oops&nbsp;Rewind&nbsp;Capability)&nbsp;&nbsp;unwinder&nbsp;替代了以前出现过的DWARF&nbsp;&nbsp;unwinder。至此以后，内核提供下面两个kconfig选项供选择：

				<br>CONFIG_UNWINDER_FRAME_POINTER=y&nbsp;(Ubuntu,&nbsp;etc.)&nbsp;or

				<br>CONFIG_UNWINDER_ORC=y&nbsp;(RHEL&nbsp;8,&nbsp;SuSE,&nbsp;Debian,&nbsp;...)

			</blockquote>
			<p data-pid="_PYSMRMS">由于本文重点在unwind栈回溯（user&nbsp;space&nbsp;常用），内核中常见的frame&nbsp;point&nbsp;和&nbsp;ORC栈回溯&nbsp;专门章节介绍。</p>
			<h2>参考</h2>
			<p data-pid="kvCOaSQe">
				<a href="https://link.zhihu.com/?target=http%3A//web.archive.org/web/20130111101034/http%3A/blog.mozilla.org/respindola/2011/05/12/cfi-directives" class=" wrap external" target="_blank" rel="nofollow noreferrer">http://web.archive.org/web/20130111101034/http://blog.mozilla.org/respindola/2011/05/12/cfi&ndash;directives</a>
			</p>
			<p data-pid="XkAY6Bou">
				<a href="https://link.zhihu.com/?target=https%3A//refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">https://</span>
					<span class="visible">refspecs.linuxfoundation.org</span>
					<span class="invisible">/LSB_5.0.0/LSB&ndash;Core&ndash;generic/LSB&ndash;Core&ndash;generic/ehframechpt.html</span>
					<span class="ellipsis"></span>
				</a>
			</p>
			<p data-pid="54R332Zf">
				<a href="https://link.zhihu.com/?target=https%3A//github.com/euspectre/kedr/commit/cc51514f6dc44a42c37a4244ceb4064acdb7d5ec" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">https://</span>
					<span class="visible">github.com/euspectre/ke</span>
					<span class="invisible">dr/commit/cc51514f6dc44a42c37a4244ceb4064acdb7d5ec</span>
					<span class="ellipsis"></span>
				</a>
			</p>
			<p data-pid="yfGE9Ry4">
				<a href="https://link.zhihu.com/?target=https%3A//git.congatec.com/android/qmx6_kernel/commit/d1526e2cda64d5a1de56aef50bad9e5df14245c2" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">https://</span>
					<span class="visible">git.congatec.com/androi</span>
					<span class="invisible">d/qmx6_kernel/commit/d1526e2cda64d5a1de56aef50bad9e5df14245c2</span>
					<span class="ellipsis"></span>
				</a>
			</p>
			<p data-pid="pSR5lHxK">
				<a href="https://link.zhihu.com/?target=https%3A//cateee.net/lkddb/web-lkddb/STACK_UNWIND.html" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">https://</span>
					<span class="visible">cateee.net/lkddb/web&ndash;lk</span>
					<span class="invisible">ddb/STACK_UNWIND.html</span>
					<span class="ellipsis"></span>
				</a>
			</p>
			<p data-pid="Z0uBwBgZ">
				<a href="https://link.zhihu.com/?target=https%3A//lwn.net/Articles/727553/" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">https://</span>
					<span class="visible">lwn.net/Articles/727553</span>
					<span class="invisible">/</span>
					<span class="ellipsis"></span>
				</a>
			</p>
			<p data-pid="e-cE6nv4">
				<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/pwl999/article/details/107569603" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">https://</span>
					<span class="visible">blog.csdn.net/pwl999/ar</span>
					<span class="invisible">ticle/details/107569603</span>
					<span class="ellipsis"></span>
				</a>
			</p>
			<p data-pid="RKWFbmO0">
				<a href="https://link.zhihu.com/?target=https%3A//wdv4758h-notes.readthedocs.io/zh_TW/latest/libunwind.html" class=" external" target="_blank" rel="nofollow noreferrer">
					<span class="invisible">https://</span>
					<span class="visible">wdv4758h&ndash;notes.readthedocs.io</span>
					<span class="invisible">/zh_TW/latest/libunwind.html</span>
					<span class="ellipsis"></span>
				</a>
			</p>
		</div>
	</body>
</html>
